<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Punk Quest DApp</title>

  <!-- --- CSS frameworks & fonts --- -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap">

  <!-- Global style placeholder — Section 12 will be pasted here -->
  <style id="GLOBAL-STYLES"></style>
</head>

<body class="bg-dark text-light" style="font-family:'Share Tech Mono', monospace;">
  <!-- Menu placeholder — Section 3 will inject HTML here -->
  <nav id="MAIN-MENU"></nav>

  <!-- Router outlet where each screen template mounts -->
  <main id="APP" class="container py-4"></main>

  <!-- Global scripts placeholder — every JS section is concatenated below -->
  <script id="GLOBAL-SCRIPTS"></script>

  <!-- Ethers (UMD build) for provider / signer utilities -->
  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>

  <!-- ───────── SECTION 2: PUNK QUEST CONFIG ───────── -->
  <script id="PQ-CONFIG">
  /*  Replace ALL "0x…" placeholders and YOUR_INFURA_KEY_HERE
      with your real addresses / keys before deploying.          */

  (() => {
    /* Core ABIs – only the functions/events we actually call */
    const PUNK_QUEST_ABI = [
      // staking & rewards
      "function stake(uint256 id)",
      "function batchStake(uint256[] ids)",
      "function claimRewards(uint256 id) returns (uint256)",
      "function batchClaimRewards(uint256[] ids) returns (uint256)",
      "function unstake(uint256 id)",
      "function batchUnstake(uint256[] ids)",
      "function purchaseFastLevelUpgrade(uint256 id)",
      // views
      "function pendingPassiveReward(uint256 id) view returns (uint256)",
      "function pendingGameReward(uint256 id) view returns (uint256)",
      "function pendingTotalReward(uint256 id) view returns (uint256)",
      "function getTokenStats(uint256 id) view returns (uint256 passive,uint256 game)",
      "function getWalletStats(address w,uint256[] tokenIds) view returns (uint256[] stakedIds,uint256 pendingPassive,uint256 pendingGame)",
      "function getGlobalStats() view returns (uint256 staked,uint256 base,uint256 socialEnd)",
      // store / armory (templates + instances)
      "function buyItem(uint256 id,uint256 qty)",
      "function batchBuyItems(uint256[] ids,uint256[] qtys)",
      "function equipItem(uint256 tokenId,uint256 itemId)",
      "function equipItemInstance(uint256 tokenId,uint256 instId)",
      "function equipExtraItemInstance(uint256 tokenId,uint256 instId)",
      "function batchArmoryActionsInstances(uint256[] tokenIds,uint8[] acts,uint256[] insts,uint256[] idxs)",
      "function purchaseExtraSlots(uint256 tokenId,uint256 qty)",
      "function repairItem(uint256 inst,uint256 tokenId)",
      // detail helpers
      "function getTokenArmoryDetails(uint256 id) view returns (uint256 weapon,uint256 armor,uint256[] extras,uint256 lastEvent)"
    ];

    const PUNK_NFT_ABI = [
      "function ownerOf(uint256 tokenId) view returns (address)"
    ];

    const ERC20_ABI = [
      "function balanceOf(address) view returns (uint256)",
      "function allowance(address,address) view returns (uint256)",
      "function approve(address,uint256) returns (bool)",
      "function decimals() view returns (uint8)"
    ];

    /* Enumeration helpers for quick look-ups in Armory UI */
    const ENUMS = {
      ArmoryActionType:        { EquipDefault: 0, EquipExtra: 1, UnequipExtra: 2, UnequipAll: 3 },
      AdvancedArmoryActionType:{ EquipDefault: 0, EquipExtra: 1, UnequipExtra: 2, UnequipAll: 3 }
    };

    /* Public, mutable DApp-wide config object */
    window.PQ_CONFIG = {
      /* ── network ── */
      chainId:        1,                         // 1 = Ethereum Mainnet
      chainName:      "Ethereum Mainnet",
      rpcViaInfura:   "https://mainnet.infura.io/v3/YOUR_INFURA_KEY_HERE",
      explorer:       "https://etherscan.io",
      nativeCurrency: { name:"Ether", symbol:"ETH", decimals:18 },

      /* ── contracts ── */
      contracts: {
        punkQuest: {
          address: "0xPUNKQUEST_ADDRESS",
          abi:     PUNK_QUEST_ABI
        },
        punkNFT: {
          address: "0xPUNK_NFT_ADDRESS",
          abi:     PUNK_NFT_ABI
        },
        rewardToken: {
          address: "0xREWARD_TOKEN_ADDRESS",
          abi:     ERC20_ABI
        }
      },

      /* ── ui helpers ── */
      enums: ENUMS,

      /* ── misc constants ── */
      gasLimitBuffer: 1.15                       // add 15 % head-room to estimated gas
    };
  })();
  </script>
  <!-- ───────── END SECTION 2 ───────── -->

  <!-- ───────── SECTION 3: MENU & ROUTER ───────── -->
  <!-- 1️⃣  Template that renders the top navigation bar -->
  <template id="TEMPLATE-MENU">
    <nav class="navbar navbar-expand-lg navbar-dark bg-secondary shadow-sm">
      <div class="container-fluid">
        <a class="navbar-brand fw-bold" href="#/dashboard">PunkQuest</a>

        <button class="navbar-toggler" type="button" data-bs-toggle="collapse"
                data-bs-target="#pqNav" aria-controls="pqNav" aria-expanded="false"
                aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse" id="pqNav">
          <ul class="navbar-nav me-auto mb-2 mb-lg-0">
            <li class="nav-item"><a class="nav-link" href="#/dashboard">Dashboard</a></li>
            <li class="nav-item"><a class="nav-link" href="#/store">Store</a></li>
            <li class="nav-item"><a class="nav-link" href="#/armory">Armory</a></li>
            <li class="nav-item"><a class="nav-link" href="#/events">Events</a></li>
            <li class="nav-item"><a class="nav-link" href="#/stats">Stats</a></li>
          </ul>

          <!-- Connect / account button -->
          <button id="btn-connect" class="btn btn-outline-light">Connect Wallet</button>
        </div>
      </div>
    </nav>
  </template>

  <!-- 2️⃣  Router + menu bootstrapper -->
  <script id="PQ-ROUTER">
  (() => {
    /* ----- Inject the nav bar into #MAIN-MENU ----- */
    const menuClone = document.getElementById('TEMPLATE-MENU').content.cloneNode(true);
    document.getElementById('MAIN-MENU').replaceWith(menuClone);

    /* ----- Basic wallet-connect stub (Section 4 will override) ----- */
    const connectBtn = document.getElementById('btn-connect');
    connectBtn.addEventListener('click', async () => {
      if (window.PQ_WALLET?.connect) {
        return window.PQ_WALLET.connect();
      }
      if (window.ethereum?.request) {
        try {
          await window.ethereum.request({ method: 'eth_requestAccounts' });
        } catch (err) {
          alert(err.message || err);
        }
      } else {
        alert('MetaMask (or a compatible wallet) isn't detected.');
      }
    });

    /* ----- Hash-based router ----- */
    const SCREENS = {
      dashboard : 'screen-dashboard',
      store     : 'screen-store',
      armory    : 'screen-armory',
      events    : 'screen-events',
      stats     : 'screen-stats'
    };

    /* Create (empty) screen containers that later sections will fill */
    const appRoot = document.getElementById('APP');
    Object.values(SCREENS).forEach(id => {
      const el = document.createElement('section');
      el.id = id;
      el.className = 'screen-hidden';
      appRoot.appendChild(el);
    });

    function showScreen(name) {
      const targetId = SCREENS[name] || SCREENS.dashboard;
      Object.values(SCREENS).forEach(id => {
        document.getElementById(id)
          .classList.toggle('screen-hidden', id !== targetId);
      });

      /* Highlight active menu tab */
      document.querySelectorAll('#pqNav .nav-link').forEach(link => {
        link.classList.toggle('active', link.getAttribute('href') === '#/' + name);
      });

      window.scrollTo({ top: 0, behavior: 'instant' });
    }

    function handleRoute() {
      const page = location.hash.replace('#/', '') || 'dashboard';
      showScreen(page);
    }

    window.addEventListener('hashchange', handleRoute);
    handleRoute();            // first load
  })();
  </script>

  <!-- 3️⃣  Bootstrap JS bundle (for navbar toggler) -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
  <!-- ───────── END SECTION 3 ───────── -->

  <!-- ───────── SECTION 4: WALLET MODULE ───────── -->
  <script id="PQ-WALLET">
  (() => {
    const { chainId, chainName, rpcViaInfura, nativeCurrency, contracts } = window.PQ_CONFIG;

    /* ---------- tiny event-bus ---------- */
    const bus = new EventTarget();
    function emit(type, detail={}) { bus.dispatchEvent(new CustomEvent(type,{detail})); }
    function on  (type, fn){ bus.addEventListener(type, fn); }
    function off (type, fn){ bus.removeEventListener(type,fn); }

    /* ---------- state ---------- */
    let provider, signer, account, networkOk = false;

    /* ---------- ethers fall-back (read-only) ---------- */
    const staticProvider = new ethers.providers.JsonRpcProvider(rpcViaInfura, chainId);

    /* ---------- helpers ---------- */
    function short(addr){ return addr.slice(0,6)+'…'+addr.slice(-4); }
    function btn(){ return document.getElementById('btn-connect'); }
    function setBtn(txt, cls='btn-outline-light'){
      const b = btn();
      b.textContent = txt;
      b.className = 'btn '+cls;
    }

    async function ensureCorrectChain(){
      const wanted = '0x'+chainId.toString(16);
      const cur    = await window.ethereum.request({ method:'eth_chainId' });
      if(cur === wanted){ networkOk = true; return true; }

      /* try to switch, else add */
      try{
        await window.ethereum.request({ method:'wallet_switchEthereumChain', params:[{chainId:wanted}] });
        networkOk = true; return true;
      }catch(switchErr){
        if(switchErr.code === 4902){            // chain not added
          try{
            await window.ethereum.request({
              method:'wallet_addEthereumChain',
              params:[{
                chainId: wanted,
                chainName,
                rpcUrls:[rpcViaInfura],
                nativeCurrency
              }]
            });
            networkOk = true; return true;
          }catch(addErr){}
        }
        networkOk = false; return false;
      }
    }

    /* ---------- connect ---------- */
    async function connect(){
      if(!window.ethereum){ alert('MetaMask (or compatible) not detected.'); return; }
      await ensureCorrectChain();
      try{
        const accs = await window.ethereum.request({ method:'eth_requestAccounts' });
        account = ethers.utils.getAddress(accs[0]);
        provider = new ethers.providers.Web3Provider(window.ethereum, 'any');
        signer   = provider.getSigner();
        setBtn(short(account), 'btn-success');
        emit('wallet:connected', { account, provider, signer });
      }catch(err){
        console.error(err);
      }
    }

    /* ---------- auto-reconnect ---------- */
    if(window.ethereum && localStorage.getItem('PQ_AUTO_CONNECT')==='1'){
      connect();
    }

    on('wallet:connected', () => {
      localStorage.setItem('PQ_AUTO_CONNECT','1');
    });

    /* ---------- event listeners ---------- */
    if(window.ethereum){
      window.ethereum.on('accountsChanged', (accs)=>{
        if(accs.length){ connect(); } else { disconnect(); }
      });
      window.ethereum.on('chainChanged', () => location.reload());
    }

    function disconnect(){
      account = signer = provider = undefined;
      localStorage.removeItem('PQ_AUTO_CONNECT');
      setBtn('Connect Wallet', 'btn-outline-light');
      emit('wallet:disconnected');
    }

    /* ---------- contract factories ---------- */
    function pqContract(){
      const { address, abi } = contracts.punkQuest;
      return signer
        ? new ethers.Contract(address, abi, signer)
        : new ethers.Contract(address, abi, staticProvider);
    }
    function nftContract(){
      const { address, abi } = contracts.punkNFT;
      return signer
        ? new ethers.Contract(address, abi, signer)
        : new ethers.Contract(address, abi, staticProvider);
    }
    function rewardTokenContract(){
      const { address, abi } = contracts.rewardToken;
      return signer
        ? new ethers.Contract(address, abi, signer)
        : new ethers.Contract(address, abi, staticProvider);
    }

    /* ---------- public API ---------- */
    window.PQ_WALLET = {
      /* state */
      get account(){ return account; },
      get provider(){ return provider || staticProvider; },
      get signer(){ return signer; },
      /* actions */
      connect, disconnect, ensureCorrectChain,
      /* contracts */
      pqContract, nftContract, rewardTokenContract,
      /* event bus */
      on, off
    };

    /* ---------- init button ---------- */
    btn().addEventListener('click', connect);
  })();
  </script>
  <!-- ───────── END SECTION 4 ───────── -->

  <!-- ───────── SECTION 5: STATE & HELPERS ───────── -->
  <script id="PQ-STATE">
  /*  Light-weight cache layer that wraps PunkQuest reads so every
      screen can grab fresh data with one-liners like:
          await PQ_STATE.refreshGlobal();
          const t = await PQ_STATE.getToken(42);                     */

  (() => {
    const WALLET = window.PQ_WALLET;
    const bus    = new EventTarget();                    /* mini pub-sub */

    /* ---------- in-memory cache ---------- */
    const cache = {
      global   : {},           /* { staked, base, socialEnd } */
      wallet   : {},           /* { stakedIds, passive, game } */
      tokens   : {},           /* tokenId → detailed info     */
      items    : {},           /* itemId  → template meta      */
      inventory: {}            /* wallet → { itemId:qty }      */
    };

    /* ---------- helper: emit events ---------- */
    const emit = (t, d={}) => bus.dispatchEvent(new CustomEvent(t,{detail:d}));

    /* ---------- GLOBAL STATS ---------- */
    async function refreshGlobal() {
      const [staked, base, socialEnd] = await WALLET.pqContract().getGlobalStats();
      cache.global = { staked: staked.toString(), base: base.toString(), socialEnd: Number(socialEnd) };
      emit('state:global', cache.global);
      return cache.global;
    }

    /* ---------- WALLET-LEVEL AGGREGATES ---------- */
    async function refreshWallet(tokenIds = []) {
      if (!WALLET.account) return {};
      const [ids, passive, game] = await WALLET.pqContract()
        .getWalletStats(WALLET.account, tokenIds);
      cache.wallet = { stakedIds: ids.map(n => Number(n)), passive, game };
      emit('state:wallet', cache.wallet);
      return cache.wallet;
    }

    /* ---------- SINGLE TOKEN DETAILS ---------- */
    async function getToken(id) {
      if (cache.tokens[id]) return cache.tokens[id];

      const pq = WALLET.pqContract();
      const [passive, game]                         = await pq.getTokenStats(id);
      const [stakeStart, lastClaim, fast, itemsB,
             spec, fix, pending]                    = await pq.getTokenDetailedInfo(id);
      const [weapon, armor, extras, lastEvent]      = await pq.getTokenArmoryDetails(id);

      cache.tokens[id] = {
        passive, game, stakeStart, lastClaim, fast,
        itemsBonus: itemsB, spec, fix, pending,
        weapon, armor, extras, lastEvent
      };
      emit('state:token', { id, data: cache.tokens[id] });
      return cache.tokens[id];
    }

    /* ---------- STORE TEMPLATES ---------- */
    async function loadStoreTemplates(maxToScan = 60) {
      if (Object.keys(cache.items).length) return cache.items;      // already cached
      const pq = WALLET.pqContract();

      for (let i = 1; i <= maxToScan; i++) {
        try {
          const itm = await pq.items(i);
          if (!itm.exists) break;                                  // stop at first gap
          cache.items[i] = {
            id: i,
            price: itm.price,
            bonus: itm.bonus,
            durability: itm.durability,
            type: itm.itemType,
            degradable: itm.degradable
          };
        } catch { break; }
      }
      emit('state:items', cache.items);
      return cache.items;
    }

    /* ---------- PLAYER INVENTORY (TEMPLATE ITEMS) ---------- */
    async function loadInventory(address = WALLET.account) {
      if (!address) return {};
      if (cache.inventory[address]) return cache.inventory[address];
      await loadStoreTemplates();                                  // ensure we know template IDs
      const inv = {};
      const pq  = WALLET.pqContract();
      for (const id of Object.keys(cache.items)) {
        const bal = await pq.inventory(address, id);
        if (bal.gt(0)) inv[id] = bal;
      }
      cache.inventory[address] = inv;
      emit('state:inventory', { owner: address, data: inv });
      return inv;
    }

    /* ---------- External API ---------- */
    window.PQ_STATE = {
      cache,
      /* event helpers */     on: (t, f) => bus.addEventListener(t, f),
                              off: (t, f) => bus.removeEventListener(t, f),
      /* fetchers */          refreshGlobal,
                              refreshWallet,
                              getToken,
                              loadStoreTemplates,
                              loadInventory
    };

    /* ---------- auto-refresh when wallet connects ---------- */
    WALLET.on('wallet:connected', () => {
      refreshGlobal();
      refreshWallet();
      loadInventory();
    });
  })();
  </script>
  <!-- ───────── END SECTION 5 ───────── -->

  <!-- Global scripts placeholder — every JS section is concatenated below -->
  <script id="GLOBAL-SCRIPTS"></script>
</body>
</html>