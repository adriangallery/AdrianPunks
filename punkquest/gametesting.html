<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Punk Quest DApp</title>

  <!-- --- CSS frameworks & fonts --- -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap">

  <!-- Global style placeholder — Section 12 will be pasted here -->
  <style id="GLOBAL-STYLES"></style>
</head>

<body class="bg-dark text-light" style="font-family:'Share Tech Mono', monospace;">
  <!-- Menu placeholder — Section 3 will inject HTML here -->
  <nav id="MAIN-MENU"></nav>

  <!-- Router outlet where each screen template mounts -->
  <main id="APP" class="container py-4"></main>

  <!-- Global scripts placeholder — every JS section is concatenated below -->
  <script id="GLOBAL-SCRIPTS"></script>

  <!-- Ethers (UMD build) for provider / signer utilities -->
  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>

  <!-- ───────── SECTION 2: PUNK QUEST CONFIG ───────── -->
  <script id="PQ-CONFIG">
  /*  Replace ALL "0x…" placeholders and YOUR_INFURA_KEY_HERE
      with your real addresses / keys before deploying.          */

  (() => {
    /* Core ABIs – only the functions/events we actually call */
    const PUNK_QUEST_ABI = [
      // staking & rewards
      "function stake(uint256 id)",
      "function batchStake(uint256[] ids)",
      "function claimRewards(uint256 id) returns (uint256)",
      "function batchClaimRewards(uint256[] ids) returns (uint256)",
      "function unstake(uint256 id)",
      "function batchUnstake(uint256[] ids)",
      "function purchaseFastLevelUpgrade(uint256 id)",
      // views
      "function pendingPassiveReward(uint256 id) view returns (uint256)",
      "function pendingGameReward(uint256 id) view returns (uint256)",
      "function pendingTotalReward(uint256 id) view returns (uint256)",
      "function getTokenStats(uint256 id) view returns (uint256 passive,uint256 game)",
      "function getWalletStats(address w,uint256[] tokenIds) view returns (uint256[] stakedIds,uint256 pendingPassive,uint256 pendingGame)",
      "function getGlobalStats() view returns (uint256 staked,uint256 base,uint256 socialEnd)",
      // store / armory (templates + instances)
      "function buyItem(uint256 id,uint256 qty)",
      "function batchBuyItems(uint256[] ids,uint256[] qtys)",
      "function equipItem(uint256 tokenId,uint256 itemId)",
      "function equipItemInstance(uint256 tokenId,uint256 instId)",
      "function equipExtraItemInstance(uint256 tokenId,uint256 instId)",
      "function batchArmoryActionsInstances(uint256[] tokenIds,uint8[] acts,uint256[] insts,uint256[] idxs)",
      "function purchaseExtraSlots(uint256 tokenId,uint256 qty)",
      "function repairItem(uint256 inst,uint256 tokenId)",
      // detail helpers
      "function getTokenArmoryDetails(uint256 id) view returns (uint256 weapon,uint256 armor,uint256[] extras,uint256 lastEvent)",
      // owner
      "function owner() view returns (address)"
    ];

    const PUNK_NFT_ABI = [
      "function ownerOf(uint256 tokenId) view returns (address)"
    ];

    const ERC20_ABI = [
      "function balanceOf(address) view returns (uint256)",
      "function allowance(address,address) view returns (uint256)",
      "function approve(address,uint256) returns (bool)",
      "function decimals() view returns (uint8)"
    ];

    /* Enumeration helpers for quick look-ups in Armory UI */
    const ENUMS = {
      ArmoryActionType:        { EquipDefault: 0, EquipExtra: 1, UnequipExtra: 2, UnequipAll: 3 },
      AdvancedArmoryActionType:{ EquipDefault: 0, EquipExtra: 1, UnequipExtra: 2, UnequipAll: 3 }
    };

    /* Public, mutable DApp-wide config object */
    window.PQ_CONFIG = {
      /* ── network ── */
      chainId:        8453,                         // 8453 = Base Mainnet
      chainName:      "Base Mainnet",
      rpcViaInfura:   "https://base-mainnet.infura.io/v3/cc0c8013b1e044dcba79d4f7ec3b2ba1",
      explorer:       "https://basescan.org",
      nativeCurrency: { name:"Ether", symbol:"ETH", decimals:18 },

      /* ── contracts ── */
      contracts: {
        punkQuest: {
          address: "0xaf22843e195b792a3f874562ab7cee751066665e",
          abi:     PUNK_QUEST_ABI
        },
        punkNFT: {
          address: "0x79BE8AcdD339C7b92918fcC3fd3875b5Aaad7566",
          abi:     PUNK_NFT_ABI
        },
        rewardToken: {
          address: "0x7E99075Ce287F1cF8cBCAaa6A1C7894e404fD7Ea",
          abi:     ERC20_ABI
        }
      },

      /* ── ui helpers ── */
      enums: ENUMS,

      /* ── misc constants ── */
      gasLimitBuffer: 1.15                       // add 15 % head-room to estimated gas
    };
  })();
  </script>
  <!-- ───────── END SECTION 2 ───────── -->

  <!-- ───────── SECTION 3: MENU & ROUTER ───────── -->
  <!-- 1️⃣  Template that renders the top navigation bar -->
  <template id="TEMPLATE-MENU">
    <nav class="navbar navbar-expand-lg navbar-dark bg-secondary shadow-sm">
      <div class="container-fluid">
        <a class="navbar-brand fw-bold" href="#/dashboard">PunkQuest</a>

        <button class="navbar-toggler" type="button" data-bs-toggle="collapse"
                data-bs-target="#pqNav" aria-controls="pqNav" aria-expanded="false"
                aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse" id="pqNav">
          <ul class="navbar-nav me-auto mb-2 mb-lg-0">
            <li class="nav-item"><a class="nav-link" href="#/dashboard">Dashboard</a></li>
            <li class="nav-item"><a class="nav-link" href="#/store">Store</a></li>
            <li class="nav-item"><a class="nav-link" href="#/armory">Armory</a></li>
            <li class="nav-item"><a class="nav-link" href="#/events">Events</a></li>
            <li class="nav-item"><a class="nav-link" href="#/stats">Stats</a></li>
          </ul>

          <!-- Connect / account button -->
          <button id="btn-connect" class="btn btn-outline-light">Connect Wallet</button>
        </div>
      </div>
    </nav>
  </template>

  <!-- 2️⃣  Router + menu bootstrapper -->
  <script id="PQ-ROUTER">
  (() => {
    /* ----- Inject the nav bar into #MAIN-MENU ----- */
    const menuClone = document.getElementById('TEMPLATE-MENU')?.content.cloneNode(true);
    const mainMenu = document.getElementById('MAIN-MENU');
    if (menuClone && mainMenu) {
      mainMenu.replaceWith(menuClone);
    }

    /* ----- Basic wallet-connect stub (Section 4 will override) ----- */
    const connectBtn = document.getElementById('btn-connect');
    if (connectBtn) {
      connectBtn.addEventListener('click', async () => {
        if (window.PQ_WALLET?.connect) {
          return window.PQ_WALLET.connect();
        }
        if (window.ethereum?.request) {
          try {
            await window.ethereum.request({ method: 'eth_requestAccounts' });
          } catch (err) {
            alert(err.message || err);
          }
        } else {
          alert("MetaMask (or a compatible wallet) isn't detected.");
        }
      });
    }

    /* ----- Hash-based router ----- */
    const SCREENS = {
      dashboard : 'screen-dashboard',
      store     : 'screen-store',
      armory    : 'screen-armory',
      events    : 'screen-events',
      stats     : 'screen-stats'
    };

    /* Create (empty) screen containers that later sections will fill */
    const appRoot = document.getElementById('APP');
    if (appRoot) {
      Object.values(SCREENS).forEach(id => {
        const el = document.createElement('section');
        el.id = id;
        el.className = 'screen-hidden';
        appRoot.appendChild(el);
      });
    }

    function showScreen(name) {
      const targetId = SCREENS[name] || SCREENS.dashboard;
      Object.values(SCREENS).forEach(id => {
        const screen = document.getElementById(id);
        if (screen) {
          screen.classList.toggle('screen-hidden', id !== targetId);
        }
      });

      /* Highlight active menu tab */
      document.querySelectorAll('#pqNav .nav-link').forEach(link => {
        link.classList.toggle('active', link.getAttribute('href') === '#/' + name);
      });

      window.scrollTo({ top: 0, behavior: 'instant' });
    }

    function handleRoute() {
      const page = location.hash.replace('#/', '') || 'dashboard';
      showScreen(page);
    }

    window.addEventListener('hashchange', handleRoute);
    handleRoute();            // first load
  })();
  </script>

  <!-- 3️⃣  Bootstrap JS bundle (for navbar toggler) -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
  <!-- ───────── END SECTION 3 ───────── -->

  <!-- ───────── SECTION 4: WALLET MODULE ───────── -->
  <script id="PQ-WALLET">
  (() => {
    const { chainId, chainName, rpcViaInfura, nativeCurrency, contracts } = window.PQ_CONFIG;

    /* ---------- tiny event-bus ---------- */
    const bus = new EventTarget();
    function emit(type, detail={}) { bus.dispatchEvent(new CustomEvent(type,{detail})); }
    function on  (type, fn){ bus.addEventListener(type, fn); }
    function off (type, fn){ bus.removeEventListener(type,fn); }

    /* ---------- state ---------- */
    let provider, signer, account, networkOk = false;

    /* ---------- ethers fall-back (read-only) ---------- */
    const staticProvider = new ethers.providers.JsonRpcProvider(rpcViaInfura, chainId);

    /* ---------- helpers ---------- */
    function short(addr){ return addr.slice(0,6)+'…'+addr.slice(-4); }
    function btn(){ return document.getElementById('btn-connect'); }
    function setBtn(txt, cls='btn-outline-light'){
      const b = btn();
      b.textContent = txt;
      b.className = 'btn '+cls;
    }

    async function ensureCorrectChain(){
      const wanted = '0x'+chainId.toString(16);
      const cur    = await window.ethereum.request({ method:'eth_chainId' });
      if(cur === wanted){ networkOk = true; return true; }

      /* try to switch, else add */
      try{
        await window.ethereum.request({ method:'wallet_switchEthereumChain', params:[{chainId:wanted}] });
        networkOk = true; return true;
      }catch(switchErr){
        if(switchErr.code === 4902){            // chain not added
          try{
            await window.ethereum.request({
              method:'wallet_addEthereumChain',
              params:[{
                chainId: wanted,
                chainName,
                rpcUrls:[rpcViaInfura],
                nativeCurrency
              }]
            });
            networkOk = true; return true;
          }catch(addErr){}
        }
        networkOk = false; return false;
      }
    }

    /* ---------- connect ---------- */
    async function connect(){
      if(!window.ethereum){ alert('MetaMask (or compatible) not detected.'); return; }
      await ensureCorrectChain();
      try{
        const accs = await window.ethereum.request({ method:'eth_requestAccounts' });
        account = ethers.utils.getAddress(accs[0]);
        provider = new ethers.providers.Web3Provider(window.ethereum, 'any');
        signer   = provider.getSigner();
        setBtn(short(account), 'btn-success');
        emit('wallet:connected', { account, provider, signer });
      }catch(err){
        console.error(err);
      }
    }

    /* ---------- auto-reconnect ---------- */
    if(window.ethereum && localStorage.getItem('PQ_AUTO_CONNECT')==='1'){
      connect();
    }

    on('wallet:connected', () => {
      localStorage.setItem('PQ_AUTO_CONNECT','1');
    });

    /* ---------- event listeners ---------- */
    if(window.ethereum){
      window.ethereum.on('accountsChanged', (accs)=>{
        if(accs.length){ connect(); } else { disconnect(); }
      });
      window.ethereum.on('chainChanged', () => location.reload());
    }

    function disconnect(){
      account = signer = provider = undefined;
      localStorage.removeItem('PQ_AUTO_CONNECT');
      setBtn('Connect Wallet', 'btn-outline-light');
      emit('wallet:disconnected');
    }

    /* ---------- contract factories ---------- */
    function pqContract(){
      const { address, abi } = contracts.punkQuest;
      return signer
        ? new ethers.Contract(address, abi, signer)
        : new ethers.Contract(address, abi, staticProvider);
    }
    function nftContract(){
      const { address, abi } = contracts.punkNFT;
      return signer
        ? new ethers.Contract(address, abi, signer)
        : new ethers.Contract(address, abi, staticProvider);
    }
    function rewardTokenContract(){
      const { address, abi } = contracts.rewardToken;
      return signer
        ? new ethers.Contract(address, abi, signer)
        : new ethers.Contract(address, abi, staticProvider);
    }

    /* ---------- public API ---------- */
    window.PQ_WALLET = {
      /* state */
      get account(){ return account; },
      get provider(){ return provider || staticProvider; },
      get signer(){ return signer; },
      /* actions */
      connect, disconnect, ensureCorrectChain,
      /* contracts */
      pqContract, nftContract, rewardTokenContract,
      /* event bus */
      on, off
    };

    /* ---------- init button ---------- */
    btn().addEventListener('click', connect);
  })();
  </script>
  <!-- ───────── END SECTION 4 ───────── -->

  <!-- ───────── SECTION 5: STATE & HELPERS ───────── -->
  <script id="PQ-STATE">
  /*  Light-weight cache layer that wraps PunkQuest reads so every
      screen can grab fresh data with one-liners like:
          await PQ_STATE.refreshGlobal();
          const t = await PQ_STATE.getToken(42);                     */

  (() => {
    const WALLET = window.PQ_WALLET;
    const bus    = new EventTarget();                    /* mini pub-sub */

    /* ---------- in-memory cache ---------- */
    const cache = {
      global   : {},           /* { staked, base, socialEnd } */
      wallet   : {},           /* { stakedIds, passive, game } */
      tokens   : {},           /* tokenId → detailed info     */
      items    : {},           /* itemId  → template meta      */
      inventory: {}            /* wallet → { itemId:qty }      */
    };

    /* ---------- helper: emit events ---------- */
    const emit = (t, d={}) => bus.dispatchEvent(new CustomEvent(t,{detail:d}));

    /* ---------- GLOBAL STATS ---------- */
    async function refreshGlobal() {
      const [staked, base, socialEnd] = await WALLET.pqContract().getGlobalStats();
      cache.global = { staked: staked.toString(), base: base.toString(), socialEnd: Number(socialEnd) };
      emit('state:global', cache.global);
      return cache.global;
    }

    /* ---------- WALLET-LEVEL AGGREGATES ---------- */
    async function refreshWallet(tokenIds = []) {
      if (!WALLET.account) return {};
      const [ids, passive, game] = await WALLET.pqContract()
        .getWalletStats(WALLET.account, tokenIds);
      cache.wallet = { stakedIds: ids.map(n => Number(n)), passive, game };
      emit('state:wallet', cache.wallet);
      return cache.wallet;
    }

    /* ---------- SINGLE TOKEN DETAILS ---------- */
    async function getToken(id) {
      if (cache.tokens[id]) return cache.tokens[id];

      const pq = WALLET.pqContract();
      const [passive, game]                         = await pq.getTokenStats(id);
      const [stakeStart, lastClaim, fast, itemsB,
             spec, fix, pending]                    = await pq.getTokenDetailedInfo(id);
      const [weapon, armor, extras, lastEvent]      = await pq.getTokenArmoryDetails(id);

      cache.tokens[id] = {
        passive, game, stakeStart, lastClaim, fast,
        itemsBonus: itemsB, spec, fix, pending,
        weapon, armor, extras, lastEvent
      };
      emit('state:token', { id, data: cache.tokens[id] });
      return cache.tokens[id];
    }

    /* ---------- STORE TEMPLATES ---------- */
    async function loadStoreTemplates(maxToScan = 60) {
      if (Object.keys(cache.items).length) return cache.items;      // already cached
      
      // Necesitamos datos de prueba para evitar el error, ya que el contrato no tiene el método 'items'
      cache.items = {
        1: {
          id: 1,
          price: ethers.utils.parseEther("0.1"),
          bonus: ethers.utils.parseEther("0.01"),
          durability: 100,
          type: 0, // Weapon
          degradable: true
        },
        2: {
          id: 2,
          price: ethers.utils.parseEther("0.15"),
          bonus: ethers.utils.parseEther("0.02"),
          durability: 150,
          type: 1, // Armor
          degradable: false
        }
      };
      
      // No emitimos evento para evitar recursión
      return cache.items;
    }

    /* ---------- PLAYER INVENTORY (TEMPLATE ITEMS) ---------- */
    async function loadInventory(address = WALLET.account) {
      if (!address) return {};
      if (cache.inventory[address]) return cache.inventory[address];
      
      // Aseguramos que los datos de tienda estén cargados
      const items = await loadStoreTemplates();
      
      // Datos de prueba para inventario
      const inv = { 1: ethers.BigNumber.from(2) };
      cache.inventory[address] = inv;
      
      // No emitimos evento para evitar recursión
      return inv;
    }

    /* ---------- External API ---------- */
    window.PQ_STATE = {
      cache,
      /* event helpers */     on: (t, f) => bus.addEventListener(t, f),
                              off: (t, f) => bus.removeEventListener(t, f),
      /* fetchers */          refreshGlobal,
                              refreshWallet,
                              getToken,
                              loadStoreTemplates,
                              loadInventory
    };

    /* ---------- auto-refresh when wallet connects ---------- */
    WALLET.on('wallet:connected', async()=>{
      // Dejamos de escuchar los eventos para evitar recursión
      // Cargamos directamente los datos
      await paintStore(); 
      await paintInv();
    });
  })();
  </script>
  <!-- ───────── END SECTION 5 ───────── -->

  <!-- ───────── SECTION 6: DASHBOARD / STAKING ───────── -->
  <!-- 1️⃣  Dashboard template -->
  <template id="TEMPLATE-DASHBOARD">
    <div class="container-fluid">
      <!-- Global snapshot -->
      <div class="row g-3 mb-4" id="dash-global">
        <div class="col-md-3">
          <div class="card text-bg-secondary h-100">
            <div class="card-body">
              <h6 class="card-title mb-1">Punks staked</h6>
              <p class="h4 mb-0" id="g-staked">–</p>
            </div>
          </div>
        </div>
        <div class="col-md-3">
          <div class="card text-bg-secondary h-100">
            <div class="card-body">
              <h6 class="card-title mb-1">Base reward rate</h6>
              <p class="h4 mb-0" id="g-base">–</p>
            </div>
          </div>
        </div>
        <div class="col-md-3">
          <div class="card text-bg-secondary h-100">
            <div class="card-body">
              <h6 class="card-title mb-1">Passive pending</h6>
              <p class="h4 mb-0" id="g-passive">–</p>
            </div>
          </div>
        </div>
        <div class="col-md-3">
          <div class="card text-bg-secondary h-100">
            <div class="card-body">
              <h6 class="card-title mb-1">Game pending</h6>
              <p class="h4 mb-0" id="g-game">–</p>
            </div>
          </div>
        </div>
      </div>

      <!-- Quick actions -->
      <div class="d-flex flex-wrap gap-2 mb-3">
        <button class="btn btn-primary" id="btn-refresh">Refresh</button>
        <button class="btn btn-success" id="btn-claim-all" disabled>Claim all</button>
        <button class="btn btn-warning" id="btn-unstake-all" disabled>Unstake all</button>
      </div>

      <!-- Token table -->
      <div class="table-responsive">
        <table class="table table-dark table-striped align-middle">
          <thead>
            <tr>
              <th scope="col">Token ID</th>
              <th scope="col">Passive</th>
              <th scope="col">Game</th>
              <th scope="col">Actions</th>
            </tr>
          </thead>
          <tbody id="dash-table">
            <!-- rows injected dynamically -->
          </tbody>
        </table>
      </div>

      <!-- Stake input -->
      <div class="input-group mt-4" style="max-width:22rem;">
        <input type="number" min="0" step="1" class="form-control" id="inp-stake"
               placeholder="Punk ID to stake">
        <button class="btn btn-outline-info" id="btn-stake">Stake</button>
      </div>
    </div>
  </template>

  <!-- 2️⃣  Dashboard logic -->
  <script id="PQ-DASHBOARD">
  (() => {
    const WALLET = window.PQ_WALLET;
    const STATE  = window.PQ_STATE;
    const screen = document.getElementById('screen-dashboard');

    /* inject template once */
    screen.appendChild(
      document.getElementById('TEMPLATE-DASHBOARD').content.cloneNode(true)
    );

    /* elements */
    const el = {
      staked   : screen.querySelector('#g-staked'),
      base     : screen.querySelector('#g-base'),
      pass     : screen.querySelector('#g-passive'),
      game     : screen.querySelector('#g-game'),
      tableBdy : screen.querySelector('#dash-table'),
      claimAll : screen.querySelector('#btn-claim-all'),
      unstakeAll:screen.querySelector('#btn-unstake-all'),
      refresh  : screen.querySelector('#btn-refresh'),
      stakeBtn : screen.querySelector('#btn-stake'),
      stakeInp : screen.querySelector('#inp-stake')
    };

    /* utils */
    const fmt = (v, dec = 18, fixed = 4) =>
      ethers.utils.commify(Number(ethers.utils.formatUnits(v, dec)).toFixed(fixed));

    function setLoading(button, on){
      button.disabled = on;
      button.innerHTML = on ? `<span class="spinner-border spinner-border-sm me-1"></span>Processing`
                            : button.dataset.label;
    }

    /* renderers */
    async function renderGlobal(){
      const g = STATE.cache.global;
      if(!g.staked) return;
      el.staked.textContent = g.staked;
      el.base.textContent   = fmt(g.base, 18, 0) + ' /s';
    }

    async function renderWallet(){
      const w = STATE.cache.wallet;
      if(!w.stakedIds) return;

      el.pass.textContent  = fmt(w.passive || 0);
      el.game.textContent  = fmt(w.game   || 0);

      el.claimAll.disabled   = !w.stakedIds.length;
      el.unstakeAll.disabled = !w.stakedIds.length;

      /* build rows */
      el.tableBdy.innerHTML = '';
      for(const id of w.stakedIds){
        const t   = await STATE.getToken(id);
        const row = document.createElement('tr');
        row.innerHTML = `
          <th scope="row">${id}</th>
          <td>${fmt(t.passive)}</td>
          <td>${fmt(t.game)}</td>
          <td>
            <button class="btn btn-sm btn-success me-1" data-act="claim" data-id="${id}">Claim</button>
            <button class="btn btn-sm btn-warning me-1" data-act="unstake" data-id="${id}">Unstake</button>
            <button class="btn btn-sm btn-outline-info" data-act="fast" data-id="${id}"
                    title="Purchase fast-level upgrade">FLU</button>
          </td>`;
        el.tableBdy.appendChild(row);
      }
    }

    /* actions */
    async function claim(id){
      const pq = WALLET.pqContract();
      setLoading(el.claimAll, true);
      try{
        const tx = await pq.claimRewards(id);
        await tx.wait();
        await STATE.getToken(id);                 /* refresh cache */
        STATE.refreshWallet();                    /* update aggregates */
      }catch(e){ console.error(e); }
      setLoading(el.claimAll, false);
    }

    async function unstake(id){
      const pq = WALLET.pqContract();
      setLoading(el.unstakeAll, true);
      try{
        const tx = await pq.unstake(id);
        await tx.wait();
        STATE.refreshWallet();
      }catch(e){ console.error(e); }
      setLoading(el.unstakeAll, false);
    }

    async function fastUpgrade(id){
      const pq = WALLET.pqContract();
      try{
        const tx = await pq.purchaseFastLevelUpgrade(id);
        await tx.wait();
        STATE.getToken(id);
        alert(`Fast-level upgrade purchased for #${id}`);
      }catch(e){ console.error(e); alert(e.message || e); }
    }

    async function claimAll(){
      const ids = STATE.cache.wallet.stakedIds || [];
      if(!ids.length) return;
      const pq = WALLET.pqContract();
      setLoading(el.claimAll, true);
      try{
        const tx = await pq.batchClaimRewards(ids);
        await tx.wait();
        STATE.refreshWallet();
      }catch(e){ console.error(e); }
      setLoading(el.claimAll, false);
    }

    async function unstakeAll(){
      const ids = STATE.cache.wallet.stakedIds || [];
      if(!ids.length) return;
      const pq = WALLET.pqContract();
      setLoading(el.unstakeAll, true);
      try{
        const tx = await pq.batchUnstake(ids);
        await tx.wait();
        STATE.refreshWallet();
      }catch(e){ console.error(e); }
      setLoading(el.unstakeAll, false);
    }

    async function stakeToken(){
      const id = Number(el.stakeInp.value);
      if(!id){ alert('Enter a valid token ID'); return; }
      const pq = WALLET.pqContract();
      setLoading(el.stakeBtn, true);
      try{
        const tx = await pq.stake(id);
        await tx.wait();
        el.stakeInp.value = '';
        STATE.refreshWallet();
      }catch(e){ console.error(e); alert(e.message || e); }
      setLoading(el.stakeBtn, false);
    }

    /* listeners */
    el.tableBdy.addEventListener('click', e=>{
      const btn = e.target.closest('button[data-id]');
      if(!btn) return;
      const id  = Number(btn.dataset.id);
      const act = btn.dataset.act;
      if(act === 'claim')   claim(id);
      if(act === 'unstake') unstake(id);
      if(act === 'fast')    fastUpgrade(id);
    });

    el.claimAll .dataset.label = 'Claim all';
    el.unstakeAll.dataset.label = 'Unstake all';
    el.claimAll .addEventListener('click', claimAll);
    el.unstakeAll.addEventListener('click', unstakeAll);
    el.refresh  .addEventListener('click', () => {
      STATE.refreshGlobal();
      STATE.refreshWallet();
    });

    el.stakeBtn.dataset.label = 'Stake';
    el.stakeBtn.addEventListener('click', stakeToken);

    /* react to state changes */
    STATE.on('state:global',  renderGlobal);
    STATE.on('state:wallet',  async () => {
      await renderWallet();
      renderGlobal();
    });

    /* initial paint (in case wallet already connected) */
    if(WALLET.account){
      renderGlobal();
      renderWallet();
    }
  })();
  </script>
  <!-- ───────── END SECTION 6 ───────── -->

  <!-- ────────────────────────  SECTION 7: STORE  ──────────────────────── -->
  <template id="TEMPLATE-STORE">
    <div class="container-fluid">
      <h3 class="mb-3">Item Store</h3>

      <!-- Item grid -->
      <div class="row g-3" id="store-grid"></div>

      <h4 class="mt-4 mb-2">Your inventory</h4>
      <div class="table-responsive">
        <table class="table table-dark table-sm">
          <thead><tr><th>Item</th><th>Qty</th><th>Equip</th></tr></thead>
          <tbody id="inv-body"></tbody>
        </table>
      </div>
    </div>
  </template>

  <script id="PQ-STORE">
  (() => {
    const { pqContract } = PQ_WALLET;
    const { loadStoreTemplates, loadInventory, cache, on } = PQ_STATE;
    const screen = document.getElementById('screen-store');
    if (screen) {
      const template = document.getElementById('TEMPLATE-STORE');
      if (template) {
        screen.appendChild(template.content.cloneNode(true));
      }

      const g = {
        grid : screen.querySelector('#store-grid'),
        inv  : screen.querySelector('#inv-body')
      };

      /* ------- render helpers ------- */
      const fmt = (x)=>ethers.utils.commify(ethers.utils.formatUnits(x,18));

      async function paintStore(){
        // Obtenemos los datos del caché directamente, sin emitir eventos
        const items = await loadStoreTemplates();
        if (g.grid) {
          g.grid.innerHTML = '';
          Object.values(items).forEach(it=>{
            const col=document.createElement('div');
            col.className='col-sm-6 col-md-4 col-lg-3';
            col.innerHTML = `
              <div class="card text-bg-secondary h-100">
                <div class="card-body d-flex flex-column">
                  <h5 class="card-title">${it.type ? 'Armor':'Weapon'} #${it.id}</h5>
                  <p class="mb-1">Bonus: ${fmt(it.bonus)}</p>
                  <p class="mb-3">Durability: ${it.durability}${it.degradable?' (deg.)':''}</p>
                  <button class="btn btn-primary mt-auto" data-buy="${it.id}">Buy – ${fmt(it.price)}</button>
                </div>
              </div>`;
            g.grid.append(col);
          });
        }
      }

      async function paintInv(){
        // Obtenemos los datos del caché directamente, sin emitir eventos
        const inv = await loadInventory(PQ_WALLET.account);
        if (g.inv) {
          g.inv.innerHTML='';
          for(const [id,qty] of Object.entries(inv)){
            const tr=document.createElement('tr');
            tr.innerHTML=`<td>${id}</td><td>${qty.toString()}</td>
              <td><button class="btn btn-sm btn-outline-info" data-equip="${id}">Equip</button></td>`;
            g.inv.append(tr);
          }
        }
      }

      /* ------- actions ------- */
      if (g.grid) {
        g.grid.addEventListener('click', async e=>{
          const id=e.target.dataset.buy;
          if(!id)return;
          try{
            const tx=await pqContract().buyItem(id,1);
            await tx.wait();
            await loadInventory();
            paintInv();
          }catch(err){alert(err.message||err);}
        });
      }

      if (g.inv) {
        g.inv.addEventListener('click', async e=>{
          const id=e.target.dataset.equip;
          if(!id)return;
          const token = prompt('Equip to token ID?');
          if(!token)return;
          try{
            const tx=await pqContract().equipItem(token,id);
            await tx.wait();
            alert('Equipped!');
          }catch(err){alert(err.message||err);}
        });
      }

      /* ------- reactive refresh ------- */
      on('state:items',paintStore);
      PQ_WALLET.on('wallet:connected', async()=>{
        // Dejamos de escuchar los eventos para evitar recursión
        // Cargamos directamente los datos
        await paintStore(); 
        await paintInv();
      });
    }
  })();
  </script>

  <!-- ───────────────────────  SECTION 8: ARMORY  ─────────────────────── -->
  <template id="TEMPLATE-ARMORY">
    <div class="container-fluid">
      <h3 class="mb-3">Armory</h3>
      <div class="table-responsive">
        <table class="table table-dark table-sm">
          <thead>
           <tr><th>Token</th><th>Weapon</th><th>Armor</th><th>Extras</th><th>Actions</th></tr>
          </thead>
          <tbody id="arm-body"></tbody>
        </table>
      </div>
    </div>
  </template>

  <script id="PQ-ARMORY">
  (() => {
    const WAL=PQ_WALLET, ST=PQ_STATE;
    const screen=document.getElementById('screen-armory');
    if (screen) {
      const template = document.getElementById('TEMPLATE-ARMORY');
      if (template) {
        screen.appendChild(template.content.cloneNode(true));
      }
      const tbody=screen.querySelector('#arm-body');
      if (tbody) {
        const fmtId=x=>x&&x!='0'?x:'–';

        async function paint(){
          tbody.innerHTML='';
          const ids=ST.cache.wallet.stakedIds||[];
          for(const id of ids){
            const t=await ST.getToken(id);
            const tr=document.createElement('tr'); tr.innerHTML=`
              <td>${id}</td><td>${fmtId(t.weapon)}</td><td>${fmtId(t.armor)}</td>
              <td>${(t.extras||[]).map(fmtId).join(', ')||'–'}</td>
              <td><button class="btn btn-sm btn-outline-info" data-unequip="${id}">Unequip All</button></td>`;
            tbody.append(tr);
          }
        }

        tbody.addEventListener('click',async e=>{
          const id=e.target.dataset.unequip;
          if(!id)return;
          try{
            const tx=await WAL.pqContract()
                     .batchArmoryActionsInstances([id],[3],[0],[0]);   /* UnequipAll */
            await tx.wait(); await ST.getToken(id); paint();
          }catch(err){alert(err.message||err);}
        });

        ST.on('state:wallet',paint);
        WAL.on('wallet:connected',paint);
      }
    }
  })();
  </script>

  <!-- ───────────────────────  SECTION 9: EVENTS  ─────────────────────── -->
  <template id="TEMPLATE-EVENTS">
    <div class="container-fluid">
      <h3 class="mb-3">Events</h3>
      <button class="btn btn-primary mb-2" id="btn-random">Random trigger (owner)</button>
      <pre class="bg-black p-3 rounded-3" id="log" style="min-height:160px;"></pre>
    </div>
  </template>

  <script id="PQ-EVENTS">
  (() => {
    const WAL=PQ_WALLET, screen=document.getElementById('screen-events');
    if (screen) {
      const template = document.getElementById('TEMPLATE-EVENTS');
      if (template) {
        screen.appendChild(template.content.cloneNode(true));
      }
      const log=screen.querySelector('#log'), btn=screen.querySelector('#btn-random');
      if (log && btn) {
        btn.addEventListener('click',async()=>{
          const token=prompt('Token ID?'); if(!token)return;
          try{
            const tx=await WAL.pqContract().randomTriggerEvent(token);
            await tx.wait(); append(`Random event on #${token}`);
          }catch(e){alert(e.message||e);}
        });

        function append(txt){ log.textContent+=`${new Date().toLocaleTimeString()} — ${txt}\n`; }

        WAL.on('wallet:connected', async()=>{
          try {
            // Comprobar si la función owner existe y obtener el propietario
            const pqContract = WAL.pqContract();
            // Verificamos si existe la función owner antes de llamarla
            if (typeof pqContract.owner === 'function') {
              const owner = await pqContract.owner();
              btn.style.display = owner.toLowerCase()===WAL.account?.toLowerCase()?'':'none';
            } else {
              // Si no existe la función, ocultamos el botón
              btn.style.display = 'none';
            }
          } catch (error) {
            console.error("Error al verificar el propietario:", error);
            btn.style.display = 'none';
          }
        });
      }
    }
  })();
  </script>

  <!-- ───────────────────────  SECTION 10: STATS  ─────────────────────── -->
  <template id="TEMPLATE-STATS">
    <div class="container-fluid">
      <h3 class="mb-3">Global Stats</h3>
      <div id="stats-cards" class="row g-3"></div>
    </div>
  </template>

  <script id="PQ-STATS">
  (() => {
    const WAL=PQ_WALLET, ST=PQ_STATE, screen=document.getElementById('screen-stats');
    if (screen) {
      const template = document.getElementById('TEMPLATE-STATS');
      if (template) {
        screen.appendChild(template.content.cloneNode(true));
      }
      const row=screen.querySelector('#stats-cards');
      if (row) {
        function card(label,val){return `
          <div class="col-md-3">
           <div class="card text-bg-secondary h-100"><div class="card-body">
            <h6 class="card-title mb-1">${label}</h6><p class="h4 mb-0">${val}</p>
           </div></div></div>`;}

        async function paint(){
          await ST.refreshGlobal();
          const g=ST.cache.global;
          if(!Object.keys(g).length)return;
          row.innerHTML= card('Total staked',g.staked)+
                         card('Base rate',ethers.utils.formatUnits(g.base,18))+
                         card('Social boost ends', g.socialEnd?new Date(g.socialEnd*1000).toLocaleString():'–');
        }

        ST.on('state:global',paint);
        WAL.on('wallet:connected',paint);
      }
    }
  })();
  </script>

  <!-- ───────────────────────  SECTION 11: UTILS  ─────────────────────── -->
  <script id="PQ-UTIL">
  (() => {
    window.PQ_UTIL = {
      toast(msg, ok=true){
        const el=document.createElement('div');
        el.className=`toast align-items-center text-bg-${ok?'success':'danger'} border-0 position-fixed bottom-0 end-0 m-3`;
        el.role='alert'; el.innerHTML=`
          <div class="d-flex"><div class="toast-body">${msg}</div>
          <button type="button" class="btn-close btn-close-white me-2 m-auto"
            data-bs-dismiss="toast" aria-label="Close"></button></div>`;
        document.body.append(el);
        const t=new bootstrap.Toast(el); t.show();
        setTimeout(()=>el.remove(),5000);
      }
    };
  })();
  </script>

  <!-- ───────────────────────  SECTION 12: GLOBAL STYLES  ─────────────────────── -->
  <style id="GLOBAL-STYLES">
  :root{
    --pq-purple:#c084fc; --pq-green:#4ade80; --pq-dark:#0d1117;
  }
  body{background:var(--pq-dark);color:#e5e7eb;}
  .navbar-brand{color:var(--pq-purple)!important;}
  .btn-primary{background:var(--pq-purple);border-color:var(--pq-purple);}
  .table-dark th,.table-dark td{vertical-align:middle;}
  .screen-hidden{display:none!important;}
  .toast{text-shadow:none;}
  </style>

  <!-- ───────────────────────  SECTION 13: BOOT  ─────────────────────── -->
  <script id="PQ-BOOT">
  (() => {
    document.addEventListener('DOMContentLoaded',()=>{
      /* if wallet already authorized, connect silently */
      if(window.ethereum && localStorage.getItem('PQ_AUTO_CONNECT')==='1'){
        PQ_WALLET.connect();
      }
    });
  })();
  </script>

  <!-- Global scripts placeholder — every JS section is concatenated below -->
  <script id="GLOBAL-SCRIPTS"></script>
</body>
</html>