<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PunkQuest Armería</title>
    <style>
        :root {
            --punk-primary: #ff3864;
            --punk-secondary: #2de2e6;
            --punk-dark: #0d0221;
            --punk-light: #f2f2f2;
            --punk-accent: #9e43ff;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Courier New', monospace;
            background-color: var(--punk-dark);
            color: var(--punk-light);
            line-height: 1.6;
        }

        .app {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .app-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 0;
            border-bottom: 2px solid var(--punk-primary);
            margin-bottom: 30px;
        }

        h1 {
            font-size: 2.5rem;
            color: var(--punk-primary);
            text-shadow: 0 0 10px rgba(255, 56, 100, 0.5);
        }

        .connect-button {
            background-color: var(--punk-secondary);
            color: var(--punk-dark);
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: 'Courier New', monospace;
        }

        .connect-button:hover {
            background-color: var(--punk-accent);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(46, 229, 157, 0.4);
        }

        .wallet-address {
            background-color: rgba(255, 255, 255, 0.1);
            padding: 8px 15px;
            border-radius: 20px;
            font-size: 0.9rem;
            border: 1px solid var(--punk-secondary);
        }

        .message {
            padding: 10px 20px;
            margin: 20px 0;
            border-radius: 5px;
        }

        .error-message {
            background-color: rgba(255, 56, 100, 0.2);
            border-left: 4px solid var(--punk-primary);
        }

        .success-message {
            background-color: rgba(46, 229, 157, 0.2);
            border-left: 4px solid var(--punk-secondary);
        }

        .weapons-container {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 30px;
            margin-top: 40px;
        }

        .weapon-card {
            background-color: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            overflow: hidden;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            border: 1px solid var(--punk-secondary);
            padding-bottom: 20px;
        }

        .weapon-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 20px rgba(46, 229, 157, 0.2);
        }

        .weapon-image {
            width: 100%;
            height: 250px;
            object-fit: cover;
            border-bottom: 2px solid var(--punk-secondary);
        }

        .weapon-card h2 {
            color: var(--punk-secondary);
            padding: 15px;
            text-align: center;
            font-size: 1.8rem;
        }

        .weapon-description {
            color: var(--punk-light);
            padding: 0 15px 15px;
            font-size: 0.9rem;
            min-height: 80px;
        }

        .weapon-stats {
            display: flex;
            justify-content: space-around;
            background-color: rgba(255, 255, 255, 0.05);
            padding: 10px;
            margin: 0 15px 15px;
            border-radius: 5px;
        }

        .weapon-stats p {
            font-size: 0.9rem;
            color: var(--punk-secondary);
        }

        .owned-badge {
            background-color: var(--punk-accent);
            color: var(--punk-light);
            text-align: center;
            padding: 5px 10px;
            margin: 15px;
            border-radius: 5px;
            font-size: 0.9rem;
        }

        .quantity-selector {
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 15px;
            gap: 10px;
        }

        .quantity-selector input {
            width: 60px;
            background-color: rgba(255, 255, 255, 0.1);
            border: 1px solid var(--punk-secondary);
            color: var(--punk-light);
            padding: 5px;
            border-radius: 5px;
            text-align: center;
            font-family: 'Courier New', monospace;
        }

        .approve-button, .buy-button {
            background-color: var(--punk-primary);
            color: var(--punk-light);
            border: none;
            padding: 10px 25px;
            border-radius: 5px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            display: block;
            margin: 0 auto;
            font-family: 'Courier New', monospace;
        }

        .approve-button {
            background-color: var(--punk-accent);
        }

        .approve-button:hover:not(:disabled), .buy-button:hover:not(:disabled) {
            transform: scale(1.05);
            box-shadow: 0 5px 15px rgba(255, 56, 100, 0.3);
        }

        .approve-button:disabled, .buy-button:disabled {
            background-color: #666;
            cursor: not-allowed;
        }

        .token-balance {
            color: var(--punk-secondary);
            font-size: 0.9rem;
            text-align: right;
            margin-bottom: 10px;
        }

        .network-info {
            color: var(--punk-secondary);
            font-size: 0.9rem;
            padding: 5px 10px;
            background-color: rgba(255, 255, 255, 0.05);
            border-radius: 5px;
            display: inline-block;
            margin-top: 10px;
        }

        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(13, 2, 33, 0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 1000;
        }

        .loading-spinner {
            border: 5px solid rgba(46, 229, 157, 0.3);
            border-radius: 50%;
            border-top: 5px solid var(--punk-secondary);
            width: 50px;
            height: 50px;
            animation: spin 2s linear infinite;
            margin-bottom: 20px;
        }

        .loading-text {
            color: var(--punk-secondary);
            font-size: 1.2rem;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @media (max-width: 768px) {
            .app-header {
                flex-direction: column;
                gap: 15px;
            }
            
            .weapons-container {
                grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            }
        }
    </style>
</head>
<body>
    <div class="app" id="app">
        <header class="app-header">
            <h1>PunkQuest Armería</h1>
            <div>
                <button id="connectButton" class="connect-button">Conectar Wallet</button>
                <div id="walletInfo" style="display: none;" class="wallet-address"></div>
                <div id="networkInfo" class="network-info" style="display: none;"></div>
            </div>
        </header>
        
        <div id="messageContainer"></div>
        
        <div class="network-notice" style="text-align: center; margin: 20px 0; padding: 10px; background-color: rgba(46, 229, 157, 0.1); border-radius: 5px; border: 1px solid var(--punk-secondary);">
            <p>⚠️ Esta aplicación funciona exclusivamente en la red <strong>BASE</strong> (L2 de Ethereum) ⚠️</p>
            <p style="font-size: 0.9rem; margin-top: 5px;">Al conectar tu wallet, se te solicitará cambiar a esta red si es necesario.</p>
        </div>
        
        <div id="tokenBalance" class="token-balance"></div>
        
        <div id="weaponsContainer" class="weapons-container">
            <!-- Las armas se cargarán aquí dinámicamente -->
        </div>
    </div>

    <div id="loadingOverlay" class="loading-overlay" style="display: none;">
        <div class="loading-spinner"></div>
        <div class="loading-text" id="loadingText">Procesando...</div>
    </div>

    <!-- Scripts -->
    <!-- Ethers.js desde CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/5.7.2/ethers.umd.min.js"></script>
    
    <script>
        // Configuración de contratos - DIRECCIONES ACTUALIZADAS PARA BASE
        const PUNK_QUEST_ADDRESS = "0x2BaC85c0deE0b243C2CcA3D5CBE95dA835934639"; // Dirección del contrato en BASE
        const TOKEN_ADDRESS = "0x79B0a67a4045A7a8DC04b17456F4fe15339cBA34"; // Dirección del token ADRIAN en BASE
        
        // ABIs simplificados para los contratos
        const punkQuestABI = [
            "function buyItem(uint256 id, uint256 qty) external",
            "function items(uint256) view returns (uint256 price, uint256 bonus, uint256 durability, bool exists, uint8 itemType, bool degradable)",
            "function inventory(address, uint256) view returns (uint256)"
        ];
        
        const erc20ABI = [
            "function approve(address spender, uint256 amount) external returns (bool)",
            "function allowance(address owner, address spender) view returns (uint256)",
            "function balanceOf(address account) view returns (uint256)",
            "function symbol() view returns (string)",
            "function decimals() view returns (uint8)"
        ];
        
        // Datos de armas (de weapons.json)
        const weaponsData = [
            {
                "id": 1,
                "name": "Molotow",
                "type": "Weapon",
                "price": "100", 
                "bonus": "1%",
                "durability": 1,
                "description": "Set the scene ablaze with one explosive burst! A one-time fiery boost to ignite the punk spirit.",
                "image": "https://emerald-above-tick-265.mypinata.cloud/ipfs/bafybeicmy7xqtfe4xji4dcffiwkzodbotujre63wzavbbp7im673p2io5a/Molotow.png"
            }
        ];
        
        // Estado de la aplicación
        let state = {
            provider: null,
            signer: null,
            account: null,
            punkQuestContract: null,
            tokenContract: null,
            tokenSymbol: 'ADRIAN',
            tokenDecimals: 18,
            isLoading: false,
            chainId: null,
            networkName: null
        };
        
        // Referencias a elementos del DOM
        const connectButton = document.getElementById('connectButton');
        const walletInfo = document.getElementById('walletInfo');
        const networkInfo = document.getElementById('networkInfo');
        const messageContainer = document.getElementById('messageContainer');
        const weaponsContainer = document.getElementById('weaponsContainer');
        const tokenBalance = document.getElementById('tokenBalance');
        const loadingOverlay = document.getElementById('loadingOverlay');
        const loadingText = document.getElementById('loadingText');
        
        // Mapeo de chainId a nombres de red
        const networkNames = {
            1: 'Ethereum Mainnet',
            3: 'Ropsten Testnet',
            4: 'Rinkeby Testnet',
            5: 'Goerli Testnet',
            42: 'Kovan Testnet',
            56: 'Binance Smart Chain',
            97: 'BSC Testnet',
            137: 'Polygon Mainnet',
            80001: 'Mumbai Testnet',
            8453: 'Base Mainnet',
            84531: 'Base Goerli Testnet',
            31337: 'Hardhat Local',
            1337: 'Local Testnet'
        };
        
        // ChainId de BASE - IMPORTANTE: Esta app solo funciona en la red BASE
        const BASE_CHAIN_ID = 8453;
        const BASE_RPC_URL = "https://mainnet.base.org";
        
        // Función para cambiar a la red BASE - Hacerla global
        // Esta función necesita ser accesible globalmente para el botón en el HTML
        window.switchToBaseNetwork = async function() {
            if (!window.ethereum) {
                showMessage("No se detectó MetaMask. Por favor instala MetaMask para cambiar de red.", true);
                return false;
            }
            
            try {
                showLoading('Cambiando a red BASE...');
                
                // Intentar cambiar a BASE
                await window.ethereum.request({
                    method: 'wallet_switchEthereumChain',
                    params: [{ chainId: "0x" + BASE_CHAIN_ID.toString(16) }]
                });
                
                hideLoading();
                showMessage("¡Conectado a la red BASE con éxito!");
                
                // Recargar la página después del cambio para actualizar el estado
                setTimeout(() => {
                    window.location.reload();
                }, 1500);
                
                return true;
            } catch (switchError) {
                // Si el error es 4902, la red no está añadida en MetaMask
                if (switchError.code === 4902) {
                    try {
                        await window.ethereum.request({
                            method: 'wallet_addEthereumChain',
                            params: [{
                                chainId: "0x" + BASE_CHAIN_ID.toString(16),
                                chainName: 'Base Mainnet',
                                nativeCurrency: {
                                    name: 'ETH',
                                    symbol: 'ETH',
                                    decimals: 18
                                },
                                rpcUrls: [BASE_RPC_URL],
                                blockExplorerUrls: ['https://basescan.org']
                            }]
                        });
                        
                        hideLoading();
                        showMessage("Red BASE añadida. Conectando...");
                        
                        // Recargar la página después de añadir la red
                        setTimeout(() => {
                            window.location.reload();
                        }, 1500);
                        
                        return true;
                    } catch (addError) {
                        hideLoading();
                        console.error('Error al añadir la red BASE', addError);
                        showMessage("Error al añadir la red BASE: " + (addError.message || "Desconocido"), true);
                        return false;
                    }
                }
                
                hideLoading();
                console.error('Error al cambiar a la red BASE', switchError);
                showMessage("Error al cambiar a la red BASE: " + (switchError.message || "Desconocido"), true);
                return false;
            }
        };
        
        // Funciones de utilidad
        function showMessage(message, isError = false) {
            const messageElement = document.createElement('div');
            messageElement.className = isError ? 'message error-message' : 'message success-message';
            messageElement.textContent = message;
            
            messageContainer.innerHTML = '';
            messageContainer.appendChild(messageElement);
            
            // Auto-eliminar después de 5 segundos
            setTimeout(() => {
                messageElement.remove();
            }, 5000);
        }
        
        function showLoading(text = 'Procesando...') {
            state.isLoading = true;
            loadingText.textContent = text;
            loadingOverlay.style.display = 'flex';
        }
        
        function hideLoading() {
            state.isLoading = false;
            loadingOverlay.style.display = 'none';
        }
        
        function formatAddress(address) {
            return `${address.substring(0, 6)}...${address.substring(address.length - 4)}`;
        }
        
        function formatPrice(priceWei) {
            if (!priceWei) return '...';
            return `${ethers.utils.formatUnits(priceWei, state.tokenDecimals)} ${state.tokenSymbol}`;
        }
        
        // Funciones principales
        async function connectWallet() {
            try {
                showLoading('Conectando wallet...');
                
                if (!window.ethereum) {
                    throw new Error("Por favor instala MetaMask para usar esta aplicación");
                }
                
                // Solicitar cuentas primero
                const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
                if (!accounts || accounts.length === 0) {
                    throw new Error("No se pudo obtener una cuenta. Por favor, habilita MetaMask.");
                }
                
                // Obtener chainId directamente desde ethereum
                const chainIdHex = await window.ethereum.request({ method: 'eth_chainId' });
                const chainId = parseInt(chainIdHex, 16);
                state.chainId = chainId;
                state.networkName = networkNames[chainId] || `Red ${chainId}`;
                
                // Verificar si el usuario está en la red BASE y solicitar cambio si es necesario
                if (chainId !== BASE_CHAIN_ID) {
                    showMessage("Esta aplicación requiere conectarse a la red BASE (L2 de Ethereum). Solicitando cambio de red...", false);
                    const switched = await switchToBaseNetwork();
                    if (!switched) {
                        throw new Error("Para usar esta aplicación, debes conectarte a la red BASE (L2 de Ethereum)");
                    }
                    
                    // Actualizar chainId después del cambio
                    const newChainIdHex = await window.ethereum.request({ method: 'eth_chainId' });
                    const newChainId = parseInt(newChainIdHex, 16);
                    state.chainId = newChainId;
                    state.networkName = networkNames[newChainId] || `Red ${newChainId}`;
                }
                
                // Configurar provider directamente desde window.ethereum para mayor compatibilidad
                state.provider = new ethers.providers.Web3Provider(window.ethereum);
                state.signer = state.provider.getSigner();
                state.account = accounts[0];
                
                // Inicializar contratos con provider y signer
                state.punkQuestContract = new ethers.Contract(
                    PUNK_QUEST_ADDRESS,
                    punkQuestABI,
                    state.provider
                );
                
                state.tokenContract = new ethers.Contract(
                    TOKEN_ADDRESS,
                    erc20ABI,
                    state.provider
                );
                
                // Conectar contratos con signer para operaciones de escritura
                state.punkQuestContract = state.punkQuestContract.connect(state.signer);
                state.tokenContract = state.tokenContract.connect(state.signer);
                
                // Obtener símbolo y decimales del token
                try {
                    state.tokenSymbol = await state.tokenContract.symbol();
                    state.tokenDecimals = await state.tokenContract.decimals();
                } catch (error) {
                    console.warn('Error al obtener información del token, usando valores predeterminados', error);
                    // Mantener valores predeterminados
                }
                
                // Actualizar UI
                connectButton.style.display = 'none';
                walletInfo.style.display = 'block';
                walletInfo.textContent = `Wallet: ${formatAddress(state.account)}`;
                
                networkInfo.style.display = 'block';
                networkInfo.textContent = state.networkName;
                
                // Cargar balance
                updateTokenBalance();
                
                // Cargar armas
                await renderWeapons();
                
                hideLoading();
                showMessage(`Wallet conectada: ${formatAddress(state.account)}`);
                
                // Listener para cambios de cuenta
                window.ethereum.on('accountsChanged', handleAccountChange);
                
                // Listener para cambios de red
                window.ethereum.on('chainChanged', handleChainChange);
                
            } catch (error) {
                hideLoading();
                showMessage(`Error al conectar wallet: ${error.message}`, true);
                console.error('Error al conectar wallet:', error);
            }
        }
        
        function handleAccountChange(accounts) {
            showMessage("Cuenta cambiada, recargando...");
            setTimeout(() => {
                window.location.reload();
            }, 1000);
        }
        
        function handleChainChange(chainId) {
            showMessage("Red cambiada, recargando...");
            setTimeout(() => {
                window.location.reload();
            }, 1000);
        }
        
        async function updateTokenBalance() {
            if (!state.tokenContract || !state.account) return;
            
            try {
                // Verificar que estamos conectados a la red BASE antes de intentar obtener el balance
                if (state.chainId !== BASE_CHAIN_ID) {
                    console.warn('Red incorrecta. Se requiere BASE para obtener el balance.');
                    tokenBalance.textContent = 'Cambia a la red BASE para ver tu balance';
                    return;
                }
                
                // Llamada directa sin ENS
                const balanceResult = await state.tokenContract.balanceOf(state.account);
                const balance = ethers.BigNumber.from(balanceResult);
                tokenBalance.textContent = `Balance: ${formatPrice(balance)}`;
            } catch (error) {
                console.error('Error al obtener balance:', error);
                tokenBalance.textContent = 'Error al cargar balance. Verifica que estás en la red BASE.';
            }
        }
        
        async function getItemDetails(itemId) {
            try {
                if (!state.punkQuestContract) return null;
                
                // Verificar que estamos conectados a la red BASE antes de intentar obtener los detalles
                if (state.chainId !== BASE_CHAIN_ID) {
                    console.warn('Red incorrecta. Se requiere BASE para obtener detalles del ítem.');
                    return null;
                }
                
                // Usar valores BigNumber para evitar errores de conversión
                const itemIdBN = ethers.BigNumber.from(itemId);
                
                // Llamada directa sin ENS
                const itemResult = await state.punkQuestContract.items(itemIdBN);
                
                return {
                    price: ethers.BigNumber.from(itemResult.price || 0),
                    bonus: ethers.BigNumber.from(itemResult.bonus || 0),
                    durability: ethers.BigNumber.from(itemResult.durability || 0),
                    exists: itemResult.exists || false,
                    itemType: itemResult.itemType || 0,
                    degradable: itemResult.degradable || false
                };
            } catch (error) {
                console.error('Error al obtener detalles del ítem:', error);
                // Usar datos de respaldo del JSON en lugar de mostrar error
                const weaponData = weaponsData.find(w => w.id === parseInt(itemId));
                if (weaponData) {
                    return {
                        price: ethers.utils.parseUnits(weaponData.price, state.tokenDecimals),
                        bonus: ethers.BigNumber.from(parseInt(weaponData.bonus) || 0),
                        durability: ethers.BigNumber.from(weaponData.durability || 0),
                        exists: true,
                        itemType: 0, // Weapon
                        degradable: true
                    };
                }
                return null;
            }
        }
        
        async function getInventoryCount(itemId) {
            try {
                if (!state.punkQuestContract || !state.account) return ethers.BigNumber.from(0);
                
                // Verificar que estamos conectados a la red BASE antes de intentar obtener el inventario
                if (state.chainId !== BASE_CHAIN_ID) {
                    console.warn('Red incorrecta. Se requiere BASE para obtener el inventario.');
                    return ethers.BigNumber.from(0);
                }
                
                // Usar valores BigNumber para evitar errores de conversión
                const itemIdBN = ethers.BigNumber.from(itemId);
                
                // Llamada directa sin ENS
                const countResult = await state.punkQuestContract.inventory(state.account, itemIdBN);
                return ethers.BigNumber.from(countResult);
            } catch (error) {
                console.error('Error al obtener cantidad en inventario:', error);
                return ethers.BigNumber.from(0);
            }
        }
        
        async function checkAllowance(price, quantity) {
            try {
                if (!state.tokenContract || !state.account) return false;
                
                const totalCost = price.mul(ethers.BigNumber.from(quantity));
                
                // Llamada directa sin ENS
                const allowanceResult = await state.tokenContract.allowance(state.account, PUNK_QUEST_ADDRESS);
                const allowance = ethers.BigNumber.from(allowanceResult);
                
                return allowance.gte(totalCost);
            } catch (error) {
                console.error('Error al verificar allowance:', error);
                return false;
            }
        }
        
        async function approveTokens(itemId, quantity) {
            try {
                showLoading('Aprobando tokens...');
                
                // Si no tenemos detalles del ítem, usamos un valor por defecto convertido a wei
                let totalCost;
                const itemDetails = await getItemDetails(itemId);
                
                if (itemDetails && itemDetails.price) {
                    totalCost = itemDetails.price.mul(ethers.BigNumber.from(quantity));
                } else {
                    // Convertir el precio de string a wei como fallback
                    const defaultPrice = ethers.utils.parseUnits(
                        weaponsData.find(w => w.id === itemId)?.price || "100", 
                        state.tokenDecimals
                    );
                    totalCost = defaultPrice.mul(ethers.BigNumber.from(quantity));
                    showMessage("Usando precio predeterminado del JSON para la aprobación", false);
                }
                
                // Necesitamos tener un Signer para transacciones de escritura
                if (!state.signer) {
                    const provider = new ethers.providers.Web3Provider(window.ethereum);
                    state.signer = provider.getSigner();
                    state.tokenContract = state.tokenContract.connect(state.signer);
                }
                
                const tx = await state.tokenContract.approve(PUNK_QUEST_ADDRESS, totalCost);
                await tx.wait();
                
                hideLoading();
                showMessage('Tokens aprobados correctamente');
                return true;
            } catch (error) {
                hideLoading();
                showMessage(`Error al aprobar tokens: ${error.message}`, true);
                console.error('Error al aprobar tokens:', error);
                return false;
            }
        }
        
        async function buyItem(itemId, quantity) {
            try {
                showLoading('Comprando ítem...');
                
                // Convertir valores a BigNumber para evitar errores
                const itemIdBN = ethers.BigNumber.from(itemId);
                const quantityBN = ethers.BigNumber.from(quantity);
                
                // Necesitamos tener un Signer para transacciones de escritura
                if (!state.signer) {
                    const provider = new ethers.providers.Web3Provider(window.ethereum);
                    state.signer = provider.getSigner();
                    state.punkQuestContract = state.punkQuestContract.connect(state.signer);
                }
                
                // Intentar comprar ítem
                const tx = await state.punkQuestContract.buyItem(itemIdBN, quantityBN);
                await tx.wait();
                
                // Actualizar UI
                updateTokenBalance();
                renderWeapons(); // Re-renderizar para actualizar inventario
                
                hideLoading();
                showMessage(`¡Compra exitosa! Has adquirido ${quantity} unidad(es) del arma.`);
                return true;
            } catch (error) {
                hideLoading();
                showMessage(`Error al comprar ítem: ${error.message}`, true);
                console.error('Error al comprar ítem:', error);
                return false;
            }
        }
        
        async function renderWeapons() {
            weaponsContainer.innerHTML = '';
            
            // Si no hay wallet conectada, mostrar sólo info básica
            if (!state.account) {
                for (const weapon of weaponsData) {
                    renderBasicWeaponCard(weapon);
                }
                return;
            }
            
            // Verificar que estamos en la red correcta
            if (state.chainId !== BASE_CHAIN_ID) {
                const errorDiv = document.createElement('div');
                errorDiv.className = 'error-message';
                errorDiv.style.width = '100%';
                errorDiv.style.textAlign = 'center';
                errorDiv.style.padding = '20px';
                errorDiv.style.margin = '20px 0';
                errorDiv.innerHTML = `
                    <h3>Error de Red</h3>
                    <p>Debes estar conectado a la red BASE para ver tus armas.</p>
                    <p>Red actual: ${state.networkName || 'Desconocida'}</p>
                    <button onclick="switchToBaseNetwork()" class="connect-button" style="margin-top: 10px;">
                        Cambiar a BASE
                    </button>
                `;
                weaponsContainer.appendChild(errorDiv);
                return;
            }
            
            let errorCount = 0;
            
            // Con wallet conectada, intentar obtener datos adicionales
            for (const weapon of weaponsData) {
                // Crear contenedor de tarjeta
                const weaponCard = document.createElement('div');
                weaponCard.className = 'weapon-card';
                
                // Obtener datos del ítem desde el contrato
                let itemDetails = null;
                let inventoryCount = ethers.BigNumber.from(0);
                let hasAllowance = false;
                
                if (state.punkQuestContract && state.account) {
                    try {
                        itemDetails = await getItemDetails(weapon.id);
                    } catch (error) {
                        console.warn(`No se pudieron obtener detalles del ítem ${weapon.id} del contrato`);
                        errorCount++;
                    }
                    
                    try {
                        inventoryCount = await getInventoryCount(weapon.id);
                    } catch (error) {
                        console.warn(`No se pudo obtener cantidad en inventario para el ítem ${weapon.id}`);
                        errorCount++;
                    }
                }
                
                // Si hay demasiados errores, mostrar mensaje de fallback
                if (errorCount >= 3) {
                    const errorDiv = document.createElement('div');
                    errorDiv.className = 'error-message';
                    errorDiv.style.width = '100%';
                    errorDiv.style.textAlign = 'center';
                    errorDiv.style.padding = '20px';
                    errorDiv.style.margin = '20px 0';
                    errorDiv.innerHTML = `
                        <h3>Error de Conexión</h3>
                        <p>No se pudieron cargar los datos de los contratos inteligentes en la red BASE.</p>
                        <p>Por favor, verifica que:</p>
                        <ul style="text-align: left; margin: 10px 0; padding-left: 40px;">
                            <li>Estás conectado a la red BASE (L2 de Ethereum)</li>
                            <li>Las direcciones de contratos son correctas</li>
                            <li>Tu wallet tiene suficiente ETH para pagar gas</li>
                        </ul>
                        <button onclick="window.location.reload()" class="connect-button" style="margin-top: 10px;">
                            Recargar Página
                        </button>
                    `;
                    weaponsContainer.innerHTML = '';
                    weaponsContainer.appendChild(errorDiv);
                    return;
                }
                
                // Precio por defecto si no se puede obtener del contrato
                const priceText = itemDetails && itemDetails.price 
                    ? formatPrice(itemDetails.price) 
                    : `${weapon.price} ${state.tokenSymbol}`;
                
                // Verificar si ya tiene allowance suficiente
                if (itemDetails && itemDetails.price) {
                    try {
                        hasAllowance = await checkAllowance(itemDetails.price, 1);
                    } catch (error) {
                        console.warn(`No se pudo verificar allowance para el ítem ${weapon.id}`);
                    }
                }
                
                // Construir contenido de tarjeta
                weaponCard.innerHTML = `
                    <img src="${weapon.image}" alt="${weapon.name}" class="weapon-image">
                    <h2>${weapon.name}</h2>
                    <p class="weapon-description">${weapon.description}</p>
                    
                    <div class="weapon-stats">
                        <p>Precio: ${priceText}</p>
                        <p>Bonus: ${weapon.bonus}</p>
                        <p>Durabilidad: ${weapon.durability}</p>
                    </div>
                `;
                
                // Mostrar cantidad en inventario si tiene
                if (inventoryCount && inventoryCount.gt && inventoryCount.gt(0)) {
                    const ownedBadge = document.createElement('div');
                    ownedBadge.className = 'owned-badge';
                    ownedBadge.textContent = `En inventario: ${inventoryCount.toString()}`;
                    weaponCard.appendChild(ownedBadge);
                }
                
                // Selector de cantidad
                const quantitySelector = document.createElement('div');
                quantitySelector.className = 'quantity-selector';
                quantitySelector.innerHTML = `
                    <label for="quantity-${weapon.id}">Cantidad:</label>
                    <input 
                        type="number" 
                        id="quantity-${weapon.id}" 
                        min="1" 
                        value="1"
                        ${state.isLoading ? 'disabled' : ''}
                    >
                `;
                weaponCard.appendChild(quantitySelector);
                
                // Botón aprobar/comprar
                const actionButton = document.createElement('button');
                
                if (!hasAllowance) {
                    actionButton.textContent = `Aprobar ${state.tokenSymbol}`;
                    actionButton.className = 'approve-button';
                    actionButton.onclick = async () => {
                        const quantity = parseInt(document.getElementById(`quantity-${weapon.id}`).value) || 1;
                        await approveTokens(weapon.id, quantity);
                        renderWeapons(); // Actualizar UI después de aprobar
                    };
                } else {
                    actionButton.textContent = 'Comprar';
                    actionButton.className = 'buy-button';
                    actionButton.onclick = async () => {
                        const quantity = parseInt(document.getElementById(`quantity-${weapon.id}`).value) || 1;
                        await buyItem(weapon.id, quantity);
                    };
                }
                
                if (state.isLoading) {
                    actionButton.disabled = true;
                }
                
                weaponCard.appendChild(actionButton);
                
                // Añadir tarjeta al contenedor
                weaponsContainer.appendChild(weaponCard);
            }
        }
        
        function renderBasicWeaponCard(weapon) {
            const weaponCard = document.createElement('div');
            weaponCard.className = 'weapon-card';
            
            weaponCard.innerHTML = `
                <img src="${weapon.image}" alt="${weapon.name}" class="weapon-image">
                <h2>${weapon.name}</h2>
                <p class="weapon-description">${weapon.description}</p>
                
                <div class="weapon-stats">
                    <p>Precio: ${weapon.price} ${state.tokenSymbol}</p>
                    <p>Bonus: ${weapon.bonus}</p>
                    <p>Durabilidad: ${weapon.durability}</p>
                </div>
            `;
            
            weaponsContainer.appendChild(weaponCard);
        }
        
        // Event Listeners
        connectButton.addEventListener('click', connectWallet);
        
        // Iniciar aplicación
        function init() {
            renderWeapons();
        }
        
        // Iniciar cuando el DOM esté listo
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
<!-- Update: Thu May 9 14:29:45 CDT 2024 -->