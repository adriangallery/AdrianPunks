<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PunkQuest Armería</title>
    <style>
        :root {
            --punk-primary: #ff3864;
            --punk-secondary: #2de2e6;
            --punk-dark: #0d0221;
            --punk-light: #f2f2f2;
            --punk-accent: #9e43ff;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Courier New', monospace;
            background-color: var(--punk-dark);
            color: var(--punk-light);
            line-height: 1.6;
        }

        .app {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .app-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 0;
            border-bottom: 2px solid var(--punk-primary);
            margin-bottom: 30px;
        }

        h1 {
            font-size: 2.5rem;
            color: var(--punk-primary);
            text-shadow: 0 0 10px rgba(255, 56, 100, 0.5);
        }

        .connect-button {
            background-color: var(--punk-secondary);
            color: var(--punk-dark);
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: 'Courier New', monospace;
        }

        .connect-button:hover {
            background-color: var(--punk-accent);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(46, 229, 157, 0.4);
        }

        .wallet-address {
            background-color: rgba(255, 255, 255, 0.1);
            padding: 8px 15px;
            border-radius: 20px;
            font-size: 0.9rem;
            border: 1px solid var(--punk-secondary);
        }

        .message {
            padding: 10px 20px;
            margin: 20px 0;
            border-radius: 5px;
        }

        .error-message {
            background-color: rgba(255, 56, 100, 0.2);
            border-left: 4px solid var(--punk-primary);
        }

        .success-message {
            background-color: rgba(46, 229, 157, 0.2);
            border-left: 4px solid var(--punk-secondary);
        }

        .weapons-container {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 30px;
            margin-top: 40px;
        }

        .weapon-card {
            background-color: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            overflow: hidden;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            border: 1px solid var(--punk-secondary);
            padding-bottom: 20px;
        }

        .weapon-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 20px rgba(46, 229, 157, 0.2);
        }

        .weapon-image {
            width: 100%;
            height: 250px;
            object-fit: cover;
            border-bottom: 2px solid var(--punk-secondary);
        }

        .weapon-card h2 {
            color: var(--punk-secondary);
            padding: 15px;
            text-align: center;
            font-size: 1.8rem;
        }

        .weapon-description {
            color: var(--punk-light);
            padding: 0 15px 15px;
            font-size: 0.9rem;
            min-height: 80px;
        }

        .weapon-stats {
            display: flex;
            justify-content: space-around;
            background-color: rgba(255, 255, 255, 0.05);
            padding: 10px;
            margin: 0 15px 15px;
            border-radius: 5px;
        }

        .weapon-stats p {
            font-size: 0.9rem;
            color: var(--punk-secondary);
        }

        .owned-badge {
            background-color: var(--punk-accent);
            color: var(--punk-light);
            text-align: center;
            padding: 5px 10px;
            margin: 15px;
            border-radius: 5px;
            font-size: 0.9rem;
        }

        .quantity-selector {
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 15px;
            gap: 10px;
        }

        .quantity-selector input {
            width: 60px;
            background-color: rgba(255, 255, 255, 0.1);
            border: 1px solid var(--punk-secondary);
            color: var(--punk-light);
            padding: 5px;
            border-radius: 5px;
            text-align: center;
            font-family: 'Courier New', monospace;
        }

        .approve-button, .buy-button {
            background-color: var(--punk-primary);
            color: var(--punk-light);
            border: none;
            padding: 10px 25px;
            border-radius: 5px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            display: block;
            margin: 0 auto;
            font-family: 'Courier New', monospace;
        }

        .approve-button {
            background-color: var(--punk-accent);
        }

        .approve-button:hover:not(:disabled), .buy-button:hover:not(:disabled) {
            transform: scale(1.05);
            box-shadow: 0 5px 15px rgba(255, 56, 100, 0.3);
        }

        .approve-button:disabled, .buy-button:disabled {
            background-color: #666;
            cursor: not-allowed;
        }

        .token-balance {
            color: var(--punk-secondary);
            font-size: 0.9rem;
            text-align: right;
            margin-bottom: 10px;
        }

        .network-info {
            color: var(--punk-secondary);
            font-size: 0.9rem;
            padding: 5px 10px;
            background-color: rgba(255, 255, 255, 0.05);
            border-radius: 5px;
            display: inline-block;
            margin-top: 10px;
        }

        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(13, 2, 33, 0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 1000;
        }

        .loading-spinner {
            border: 5px solid rgba(46, 229, 157, 0.3);
            border-radius: 50%;
            border-top: 5px solid var(--punk-secondary);
            width: 50px;
            height: 50px;
            animation: spin 2s linear infinite;
            margin-bottom: 20px;
        }

        .loading-text {
            color: var(--punk-secondary);
            font-size: 1.2rem;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @media (max-width: 768px) {
            .app-header {
                flex-direction: column;
                gap: 15px;
            }
            
            .weapons-container {
                grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            }
        }
    </style>
</head>
<body>
    <div class="app" id="app">
        <header class="app-header">
            <h1>PunkQuest Armería</h1>
            <div>
                <button id="connectButton" class="connect-button">Conectar Wallet</button>
                <div id="walletInfo" style="display: none;" class="wallet-address"></div>
                <div id="networkInfo" class="network-info" style="display: none;"></div>
            </div>
        </header>
        
        <div id="messageContainer"></div>
        
        <div id="tokenBalance" class="token-balance"></div>
        
        <div id="weaponsContainer" class="weapons-container">
            <!-- Las armas se cargarán aquí dinámicamente -->
        </div>
    </div>

    <div id="loadingOverlay" class="loading-overlay" style="display: none;">
        <div class="loading-spinner"></div>
        <div class="loading-text" id="loadingText">Procesando...</div>
    </div>

    <!-- Scripts -->
    <!-- Ethers.js desde CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/5.7.2/ethers.umd.min.js"></script>
    
    <script>
        // Configuración de contratos - REEMPLAZA ESTAS DIRECCIONES CON LAS REALES
        const PUNK_QUEST_ADDRESS = "0x123456789abcdef123456789abcdef123456789a"; // ¡Actualiza esta dirección!
        const TOKEN_ADDRESS = "0xabcdef123456789abcdef123456789abcdef1234"; // ¡Actualiza esta dirección!
        
        // ABIs simplificados para los contratos
        const punkQuestABI = [
            "function buyItem(uint256 id, uint256 qty) external",
            "function items(uint256) view returns (uint256 price, uint256 bonus, uint256 durability, bool exists, uint8 itemType, bool degradable)",
            "function inventory(address, uint256) view returns (uint256)"
        ];
        
        const erc20ABI = [
            "function approve(address spender, uint256 amount) external returns (bool)",
            "function allowance(address owner, address spender) view returns (uint256)",
            "function balanceOf(address account) view returns (uint256)",
            "function symbol() view returns (string)",
            "function decimals() view returns (uint8)"
        ];
        
        // Datos de armas (de weapons.json)
        const weaponsData = [
            {
                "id": 1,
                "name": "Molotow",
                "type": "Weapon",
                "price": "100", 
                "bonus": "1%",
                "durability": 1,
                "description": "Set the scene ablaze with one explosive burst! A one-time fiery boost to ignite the punk spirit.",
                "image": "https://emerald-above-tick-265.mypinata.cloud/ipfs/bafybeicmy7xqtfe4xji4dcffiwkzodbotujre63wzavbbp7im673p2io5a/Molotow.png"
            }
        ];
        
        // Estado de la aplicación
        let state = {
            provider: null,
            signer: null,
            account: null,
            punkQuestContract: null,
            tokenContract: null,
            tokenSymbol: 'ADRIAN',
            tokenDecimals: 18,
            isLoading: false,
            chainId: null,
            networkName: null
        };
        
        // Referencias a elementos del DOM
        const connectButton = document.getElementById('connectButton');
        const walletInfo = document.getElementById('walletInfo');
        const networkInfo = document.getElementById('networkInfo');
        const messageContainer = document.getElementById('messageContainer');
        const weaponsContainer = document.getElementById('weaponsContainer');
        const tokenBalance = document.getElementById('tokenBalance');
        const loadingOverlay = document.getElementById('loadingOverlay');
        const loadingText = document.getElementById('loadingText');
        
        // Mapeo de chainId a nombres de red
        const networkNames = {
            1: 'Ethereum Mainnet',
            3: 'Ropsten Testnet',
            4: 'Rinkeby Testnet',
            5: 'Goerli Testnet',
            42: 'Kovan Testnet',
            56: 'Binance Smart Chain',
            97: 'BSC Testnet',
            137: 'Polygon Mainnet',
            80001: 'Mumbai Testnet',
            31337: 'Hardhat Local',
            1337: 'Local Testnet'
        };
        
        // Funciones de utilidad
        function showMessage(message, isError = false) {
            const messageElement = document.createElement('div');
            messageElement.className = isError ? 'message error-message' : 'message success-message';
            messageElement.textContent = message;
            
            messageContainer.innerHTML = '';
            messageContainer.appendChild(messageElement);
            
            // Auto-eliminar después de 5 segundos
            setTimeout(() => {
                messageElement.remove();
            }, 5000);
        }
        
        function showLoading(text = 'Procesando...') {
            state.isLoading = true;
            loadingText.textContent = text;
            loadingOverlay.style.display = 'flex';
        }
        
        function hideLoading() {
            state.isLoading = false;
            loadingOverlay.style.display = 'none';
        }
        
        function formatAddress(address) {
            return `${address.substring(0, 6)}...${address.substring(address.length - 4)}`;
        }
        
        function formatPrice(priceWei) {
            if (!priceWei) return '...';
            return `${ethers.utils.formatUnits(priceWei, state.tokenDecimals)} ${state.tokenSymbol}`;
        }
        
        // Funciones principales
        async function connectWallet() {
            try {
                showLoading('Conectando wallet...');
                
                if (!window.ethereum) {
                    throw new Error("Por favor instala MetaMask para usar esta aplicación");
                }
                
                // Solicitar cuentas primero
                const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
                if (!accounts || accounts.length === 0) {
                    throw new Error("No se pudo obtener una cuenta. Por favor, habilita MetaMask.");
                }
                
                // Obtener chainId directamente desde ethereum
                const chainIdHex = await window.ethereum.request({ method: 'eth_chainId' });
                const chainId = parseInt(chainIdHex, 16);
                state.chainId = chainId;
                state.networkName = networkNames[chainId] || `Red ${chainId}`;
                
                // Configurar provider con una red específica para evitar problemas de ENS
                // Usamos JsonRpcProvider directo en lugar de Web3Provider
                const jsonRpcUrl = window.ethereum.providers?.[0]?.rpcUrl || 
                                  "https://rpc-mainnet.maticvigil.com"; // Fallback a Polygon
                                  
                state.provider = new ethers.providers.JsonRpcProvider(jsonRpcUrl);
                
                // Creamos un proveedor de solo lectura para evitar problemas de ENS
                state.account = accounts[0];
                
                // Inicializar contratos - Usamos un método alternativo para crear contratos
                const punkQuestInterface = new ethers.utils.Interface(punkQuestABI);
                state.punkQuestContract = new ethers.Contract(
                    PUNK_QUEST_ADDRESS,
                    punkQuestInterface.format(ethers.utils.FormatTypes.full),
                    state.provider
                );
                
                const erc20Interface = new ethers.utils.Interface(erc20ABI);
                state.tokenContract = new ethers.Contract(
                    TOKEN_ADDRESS,
                    erc20Interface.format(ethers.utils.FormatTypes.full),
                    state.provider
                );
                
                // Para operaciones de escritura, necesitamos un signer
                if (accounts.length > 0) {
                    state.signer = new ethers.providers.Web3Provider(window.ethereum).getSigner();
                    
                    // Reemplazamos contratos con versiones que incluyen signer
                    state.punkQuestContract = state.punkQuestContract.connect(state.signer);
                    state.tokenContract = state.tokenContract.connect(state.signer);
                }
                
                // Obtener símbolo y decimales del token
                try {
                    state.tokenSymbol = await state.tokenContract.symbol();
                    state.tokenDecimals = await state.tokenContract.decimals();
                } catch (error) {
                    console.warn('Error al obtener información del token, usando valores predeterminados');
                }
                
                // Actualizar UI
                connectButton.style.display = 'none';
                walletInfo.style.display = 'block';
                walletInfo.textContent = `Wallet: ${formatAddress(state.account)}`;
                
                networkInfo.style.display = 'block';
                networkInfo.textContent = state.networkName;
                
                // Cargar balance
                updateTokenBalance();
                
                // Cargar armas
                await renderWeapons();
                
                hideLoading();
                showMessage(`Wallet conectada: ${formatAddress(state.account)}`);
                
                // Listener para cambios de cuenta
                window.ethereum.on('accountsChanged', handleAccountChange);
                
                // Listener para cambios de red
                window.ethereum.on('chainChanged', handleChainChange);
                
            } catch (error) {
                hideLoading();
                showMessage(`Error al conectar wallet: ${error.message}`, true);
                console.error('Error al conectar wallet:', error);
            }
        }
        
        function handleAccountChange(accounts) {
            showMessage("Cuenta cambiada, recargando...");
            setTimeout(() => {
                window.location.reload();
            }, 1000);
        }
        
        function handleChainChange(chainId) {
            showMessage("Red cambiada, recargando...");
            setTimeout(() => {
                window.location.reload();
            }, 1000);
        }
        
        async function updateTokenBalance() {
            if (!state.tokenContract || !state.account) return;
            
            try {
                // Llamada directa sin ENS
                const balanceResult = await state.tokenContract.balanceOf(state.account);
                const balance = ethers.BigNumber.from(balanceResult);
                tokenBalance.textContent = `Balance: ${formatPrice(balance)}`;
            } catch (error) {
                console.error('Error al obtener balance:', error);
                tokenBalance.textContent = 'Error al cargar balance';
            }
        }
        
        async function getItemDetails(itemId) {
            try {
                if (!state.punkQuestContract) return null;
                
                // Usar valores BigNumber para evitar errores de conversión
                const itemIdBN = ethers.BigNumber.from(itemId);
                
                // Llamada directa sin ENS
                const itemResult = await state.punkQuestContract.items(itemIdBN);
                
                return {
                    price: ethers.BigNumber.from(itemResult.price || 0),
                    bonus: ethers.BigNumber.from(itemResult.bonus || 0),
                    durability: ethers.BigNumber.from(itemResult.durability || 0),
                    exists: itemResult.exists || false,
                    itemType: itemResult.itemType || 0,
                    degradable: itemResult.degradable || false
                };
            } catch (error) {
                console.error('Error al obtener detalles del ítem:', error);
                // En vez de mostrar mensaje de error, simplemente retornamos null para usar fallback
                return null;
            }
        }
        
        async function getInventoryCount(itemId) {
            try {
                if (!state.punkQuestContract || !state.account) return ethers.BigNumber.from(0);
                
                // Usar valores BigNumber para evitar errores de conversión
                const itemIdBN = ethers.BigNumber.from(itemId);
                
                // Llamada directa sin ENS
                const countResult = await state.punkQuestContract.inventory(state.account, itemIdBN);
                return ethers.BigNumber.from(countResult);
            } catch (error) {
                console.error('Error al obtener cantidad en inventario:', error);
                return ethers.BigNumber.from(0);
            }
        }
        
        async function checkAllowance(price, quantity) {
            try {
                if (!state.tokenContract || !state.account) return false;
                
                const totalCost = price.mul(ethers.BigNumber.from(quantity));
                
                // Llamada directa sin ENS
                const allowanceResult = await state.tokenContract.allowance(state.account, PUNK_QUEST_ADDRESS);
                const allowance = ethers.BigNumber.from(allowanceResult);
                
                return allowance.gte(totalCost);
            } catch (error) {
                console.error('Error al verificar allowance:', error);
                return false;
            }
        }
        
        async function approveTokens(itemId, quantity) {
            try {
                showLoading('Aprobando tokens...');
                
                // Si no tenemos detalles del ítem, usamos un valor por defecto convertido a wei
                let totalCost;
                const itemDetails = await getItemDetails(itemId);
                
                if (itemDetails && itemDetails.price) {
                    totalCost = itemDetails.price.mul(ethers.BigNumber.from(quantity));
                } else {
                    // Convertir el precio de string a wei como fallback
                    const defaultPrice = ethers.utils.parseUnits(
                        weaponsData.find(w => w.id === itemId)?.price || "100", 
                        state.tokenDecimals
                    );
                    totalCost = defaultPrice.mul(ethers.BigNumber.from(quantity));
                    showMessage("Usando precio predeterminado del JSON para la aprobación", false);
                }
                
                // Necesitamos tener un Signer para transacciones de escritura
                if (!state.signer) {
                    const provider = new ethers.providers.Web3Provider(window.ethereum);
                    state.signer = provider.getSigner();
                    state.tokenContract = state.tokenContract.connect(state.signer);
                }
                
                const tx = await state.tokenContract.approve(PUNK_QUEST_ADDRESS, totalCost);
                await tx.wait();
                
                hideLoading();
                showMessage('Tokens aprobados correctamente');
                return true;
            } catch (error) {
                hideLoading();
                showMessage(`Error al aprobar tokens: ${error.message}`, true);
                console.error('Error al aprobar tokens:', error);
                return false;
            }
        }
        
        async function buyItem(itemId, quantity) {
            try {
                showLoading('Comprando ítem...');
                
                // Convertir valores a BigNumber para evitar errores
                const itemIdBN = ethers.BigNumber.from(itemId);
                const quantityBN = ethers.BigNumber.from(quantity);
                
                // Necesitamos tener un Signer para transacciones de escritura
                if (!state.signer) {
                    const provider = new ethers.providers.Web3Provider(window.ethereum);
                    state.signer = provider.getSigner();
                    state.punkQuestContract = state.punkQuestContract.connect(state.signer);
                }
                
                // Intentar comprar ítem
                const tx = await state.punkQuestContract.buyItem(itemIdBN, quantityBN);
                await tx.wait();
                
                // Actualizar UI
                updateTokenBalance();
                renderWeapons(); // Re-renderizar para actualizar inventario
                
                hideLoading();
                showMessage(`¡Compra exitosa! Has adquirido ${quantity} unidad(es) del arma.`);
                return true;
            } catch (error) {
                hideLoading();
                showMessage(`Error al comprar ítem: ${error.message}`, true);
                console.error('Error al comprar ítem:', error);
                return false;
            }
        }
        
        async function renderWeapons() {
            weaponsContainer.innerHTML = '';
            
            // Si no hay wallet conectada, mostrar sólo info básica
            if (!state.account) {
                for (const weapon of weaponsData) {
                    renderBasicWeaponCard(weapon);
                }
                return;
            }
            
            // Con wallet conectada, intentar obtener datos adicionales
            for (const weapon of weaponsData) {
                // Crear contenedor de tarjeta
                const weaponCard = document.createElement('div');
                weaponCard.className = 'weapon-card';
                
                // Obtener datos del ítem desde el contrato
                let itemDetails = null;
                let inventoryCount = ethers.BigNumber.from(0);
                let hasAllowance = false;
                
                if (state.punkQuestContract && state.account) {
                    try {
                        itemDetails = await getItemDetails(weapon.id);
                    } catch (error) {
                        console.warn(`No se pudieron obtener detalles del ítem ${weapon.id} del contrato`);
                    }
                    
                    try {
                        inventoryCount = await getInventoryCount(weapon.id);
                    } catch (error) {
                        console.warn(`No se pudo obtener cantidad en inventario para el ítem ${weapon.id}`);
                    }
                }
                
                // Precio por defecto si no se puede obtener del contrato
                const priceText = itemDetails && itemDetails.price 
                    ? formatPrice(itemDetails.price) 
                    : `${weapon.price} ${state.tokenSymbol}`;
                
                // Verificar si ya tiene allowance suficiente
                if (itemDetails && itemDetails.price) {
                    try {
                        hasAllowance = await checkAllowance(itemDetails.price, 1);
                    } catch (error) {
                        console.warn(`No se pudo verificar allowance para el ítem ${weapon.id}`);
                    }
                }
                
                // Construir contenido de tarjeta
                weaponCard.innerHTML = `
                    <img src="${weapon.image}" alt="${weapon.name}" class="weapon-image">
                    <h2>${weapon.name}</h2>
                    <p class="weapon-description">${weapon.description}</p>
                    
                    <div class="weapon-stats">
                        <p>Precio: ${priceText}</p>
                        <p>Bonus: ${weapon.bonus}</p>
                        <p>Durabilidad: ${weapon.durability}</p>
                    </div>
                `;
                
                // Mostrar cantidad en inventario si tiene
                if (inventoryCount && inventoryCount.gt && inventoryCount.gt(0)) {
                    const ownedBadge = document.createElement('div');
                    ownedBadge.className = 'owned-badge';
                    ownedBadge.textContent = `En inventario: ${inventoryCount.toString()}`;
                    weaponCard.appendChild(ownedBadge);
                }
                
                // Selector de cantidad
                const quantitySelector = document.createElement('div');
                quantitySelector.className = 'quantity-selector';
                quantitySelector.innerHTML = `
                    <label for="quantity-${weapon.id}">Cantidad:</label>
                    <input 
                        type="number" 
                        id="quantity-${weapon.id}" 
                        min="1" 
                        value="1"
                        ${state.isLoading ? 'disabled' : ''}
                    >
                `;
                weaponCard.appendChild(quantitySelector);
                
                // Botón aprobar/comprar
                const actionButton = document.createElement('button');
                
                if (!hasAllowance) {
                    actionButton.textContent = `Aprobar ${state.tokenSymbol}`;
                    actionButton.className = 'approve-button';
                    actionButton.onclick = async () => {
                        const quantity = parseInt(document.getElementById(`quantity-${weapon.id}`).value) || 1;
                        await approveTokens(weapon.id, quantity);
                        renderWeapons(); // Actualizar UI después de aprobar
                    };
                } else {
                    actionButton.textContent = 'Comprar';
                    actionButton.className = 'buy-button';
                    actionButton.onclick = async () => {
                        const quantity = parseInt(document.getElementById(`quantity-${weapon.id}`).value) || 1;
                        await buyItem(weapon.id, quantity);
                    };
                }
                
                if (state.isLoading) {
                    actionButton.disabled = true;
                }
                
                weaponCard.appendChild(actionButton);
                
                // Añadir tarjeta al contenedor
                weaponsContainer.appendChild(weaponCard);
            }
        }
        
        function renderBasicWeaponCard(weapon) {
            const weaponCard = document.createElement('div');
            weaponCard.className = 'weapon-card';
            
            weaponCard.innerHTML = `
                <img src="${weapon.image}" alt="${weapon.name}" class="weapon-image">
                <h2>${weapon.name}</h2>
                <p class="weapon-description">${weapon.description}</p>
                
                <div class="weapon-stats">
                    <p>Precio: ${weapon.price} ${state.tokenSymbol}</p>
                    <p>Bonus: ${weapon.bonus}</p>
                    <p>Durabilidad: ${weapon.durability}</p>
                </div>
            `;
            
            weaponsContainer.appendChild(weaponCard);
        }
        
        // Event Listeners
        connectButton.addEventListener('click', connectWallet);
        
        // Iniciar aplicación
        function init() {
            renderWeapons();
        }
        
        // Iniciar cuando el DOM esté listo
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
<!-- Update: Thu May 9 14:29:45 CDT 2024 -->