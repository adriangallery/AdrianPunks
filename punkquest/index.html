<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>PunkQuest Retro - Stake & Claim Rewards</title>
  <!-- Bootstrap 5 CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet" />
  <link rel="stylesheet" href="/market/styles.css">
  <style>
    /* Original PunkQuest visual styles */
    :root {
      --bg-color: #f8f9fa;
      --primary-text: #2c3e50;
      --accent-red: #ff6b6b;
      --accent-blue: #4dabf7;
      --card-bg: #ffffff;
      --card-border: #e9ecef;
      --screen-bg: #ffffff;
      --scanline-color: rgba(0,0,0,0.03);
      --pixel-shadow: -1px -1px 0 var(--accent-red), 1px 1px 0 var(--accent-blue);
    }
    body {
      background-color: var(--bg-color);
      color: var(--primary-text);
      font-family: 'Space Grotesk', sans-serif;
      margin: 0;
      padding: 20px;
      line-height: 1.6;
      background-image: repeating-linear-gradient(0deg, var(--scanline-color), var(--scanline-color) 1px, transparent 1px, transparent 4px);
    }
    .container {
      max-width: 1200px;
      margin: auto;
      padding: 20px;
      background: var(--screen-bg);
      border: 1px solid var(--card-border);
      box-shadow: 0 0 0 1px var(--accent-red), 0 0 0 2px var(--accent-blue), 0 4px 6px rgba(0,0,0,0.1);
      border-radius: 8px;
    }
    header {
      text-align: center;
      padding: 2rem;
      background: linear-gradient(180deg, var(--card-bg) 0%, var(--screen-bg) 100%);
      border-bottom: 1px solid var(--card-border);
      margin-bottom: 2rem;
      position: relative;
    }
    header h1 {
      font-size: 2.5rem;
      margin: 0;
      color: var(--primary-text);
      font-weight: 600;
      letter-spacing: 1px;
    }
    header p {
      margin-top: 1rem;
      font-size: 1rem;
      color: var(--primary-text);
      opacity: 0.8;
    }
    .card {
      background: var(--card-bg);
      border: 1px solid var(--card-border);
      border-radius: 8px;
      padding: 1.5rem;
      margin-bottom: 1.5rem;
      box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    }
    .section-title {
      font-size: 1.4rem;
      margin-bottom: 1.5rem;
      color: var(--primary-text);
      font-weight: 600;
      border-bottom: 2px solid var(--card-border);
      padding-bottom: 0.5rem;
    }
    .token-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 1.5rem;
      padding: 1rem;
    }
    .token-card {
      background: var(--card-bg);
      border: 1px solid var(--card-border);
      border-radius: 8px;
      padding: 0.8rem;
      cursor: pointer;
      transition: all 0.2s ease;
      min-height: 200px;
    }
    .token-card:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 8px rgba(0,0,0,0.1);
    }
    .token-card img {
      width: 100%;
      height: auto;
      object-fit: contain;
      border-radius: 4px;
    }
    .selected-token {
      border-color: var(--accent-blue);
      box-shadow: 0 0 0 2px var(--accent-blue);
    }
    .btn {
      font-family: 'Press Start 2P', monospace;
      font-size: 0.8rem;
      padding: 0.8rem 1.2rem;
      background: var(--card-bg);
      border: 2px solid var(--primary-text);
      color: var(--primary-text);
      text-transform: uppercase;
      cursor: pointer;
      transition: all 0.2s ease;
      margin: 0.5rem;
      box-shadow: 3px 3px 0 var(--primary-text);
    }
    .btn:hover {
      transform: translate(-2px, -2px);
      box-shadow: 5px 5px 0 var(--primary-text);
      border-color: var(--accent-blue);
    }
    .btn:active {
      transform: translate(2px, 2px);
      box-shadow: none;
      border-color: var(--accent-red);
    }
    .terminal {
      background: var(--card-bg);
      color: var(--primary-text);
      padding: 1rem;
      font-family: 'Space Mono', monos-serif;
      font-size: 0.9rem;
      border: 1px solid var(--card-border);
      border-radius: 8px;
      margin: 1rem 0;
      box-shadow: inset 0 1px 3px rgba(0,0,0,0.1);
    }
    #total-rewards {
      font-size: 2.5rem;
      color: var(--primary-text);
      text-align: center;
      margin: 1rem 0;
      padding: 1rem;
      font-weight: 600;
    }
    .wallet-address {
      font-family: 'Space Mono', monos-serif;
      font-size: 0.9rem;
      color: var(--primary-text);
      opacity: 0.8;
    }
    @keyframes rewardsUpdate {
      0% { transform: scale(1); }
      50% { transform: scale(1.05); }
      100% { transform: scale(1); }
    }
    .rewards-update {
      animation: rewardsUpdate 0.5s ease;
    }
    /* end original PunkQuest CSS */

    /* Market-specific tweaks */
    #tokenBalance {
      margin-top: 10px;
    }
    @media (max-width: 768px) {
      #tokenBalance {
        margin-top: 70px;
      }
      .card-title {
        font-size: 1rem;
        line-height: 1.2;
        margin-bottom: 0.25rem;
      }
      .nft-card .card-body {
        padding: 0.5rem;
      }
      .nft-card .card-text {
        font-size: 0.85rem;
      }
      .action-btn {
        font-size: 0.9rem;
        padding: 0.4rem 0.6rem;
      }
      .action-btn.dropdown-toggle::after {
        margin-left: 0.3rem;
      }
    }
    .modal-dialog {
      max-width: 500px;
    }
    .modal-body img {
      max-width: 300px;
      margin: 0 auto;
      display: block;
    }
    .modal-backdrop {
      opacity: 0.5;
    }
    body.modal-open {
      overflow: auto !important;
      padding-right: 0 !important;
    }
    .offer-form {
      transition: all 0.3s ease;
      opacity: 1;
      transform: translateY(0);
    }
    .offer-form.hiding {
      opacity: 0;
      transform: translateY(-10px);
    }
    .modal-body {
      max-height: 80vh;
      overflow-y: auto;
      scroll-behavior: smooth;
    }
    .trait-info {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .badge {
      font-size: 0.9em;
      padding: 8px 12px;
    }
    .trait-categories {
      max-height: 400px;
      overflow-y: auto;
      padding-right: 10px;
    }
    .trait-category {
      margin-bottom: 1rem;
    }
    .trait-category-title {
      font-size: 0.9rem;
      font-weight: 600;
      color: #333;
    }
    .trait-values {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
      gap: 0.5rem;
    }
    .trait-value-item button {
      font-size: 0.8rem;
      padding: 0.25rem 0.5rem;
    }
    #activeFilters {
      margin-bottom: 1rem;
    }
    #activeFilters .badge {
      font-size: 0.8rem;
      padding: 0.35rem 0.65rem;
    }
    #traitFilterMenu {
      max-height: 80vh;
      overflow-y: auto;
    }
    .token-stats-container {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      gap: 1rem;
      padding: 1rem;
    }

    .token-stats-item {
      background: var(--card-bg);
      border: 1px solid var(--card-border);
      border-radius: 8px;
      padding: 1rem;
      margin-bottom: 1rem;
    }

    .token-stats-item h3 {
      color: var(--primary-text);
      font-size: 1.2rem;
      margin-bottom: 1rem;
      border-bottom: 2px solid var(--card-border);
      padding-bottom: 0.5rem;
    }

    .token-stats-item p {
      margin: 0.5rem 0;
      font-size: 0.9rem;
      color: var(--primary-text);
    }

    .token-stats-item p:last-child {
      margin-bottom: 0;
    }

    @media (max-width: 768px) {
      .token-stats-container {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>PunkQuest</h1>
      <p>Your journey begins here</p>
    </header>

    <section id="wallet-connection" class="mb-4">
      <button id="connect-wallet" class="btn">Connect Wallet</button>
      <div id="wallet-info" class="mt-2"></div>
    </section>

    <section id="total-rewards-section" class="mb-4">
      <div class="card">
        <h2 class="section-title">Total Pending Rewards</h2>
        <div id="total-rewards" class="big-number">0 A$</div>
      </div>
    </section>

    <section id="tokens-section" class="mb-4">
      <div class="card">
        <h2 class="section-title">My Tokens</h2>
        <div id="tokens-grid" class="row row-cols-2 row-cols-sm-3 row-cols-md-4 g-3 token-grid"></div>
      </div>
    </section>

    <section id="token-stats" class="mb-4">
      <div class="card">
        <h2 class="section-title">Token Statistics</h2>
        <div id="individual-token-stats" class="terminal">Select one or more tokens to view detailed statistics.</div>
      </div>
    </section>

    <section id="stake-actions" class="mb-4">
      <div class="card">
        <h2 class="section-title">Actions</h2>
        <button id="stake-token" class="btn mb-3">Stake Token(s)</button>
        <button id="unstake-token" class="btn mb-3">Unstake Token(s)</button>
        <button id="claim-token" class="btn mb-3">Claim Rewards</button>
        <button id="refresh-info" class="btn mb-3">Refresh Stats</button>
        <div id="action-output" class="terminal"></div>
        <div id="fee-info" class="terminal"></div>
      </div>
    </section>

    <div id="general-output" class="terminal"></div>
  </div>

  <!-- Bootstrap 5 JS and Ethers.js Library -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
  <script>
    let provider, signer;
    let tokenContract, stakingContract, nftContract;
    let selectedTokenIds = [];
    let allMyTokenIds = [];
    let rewardsUpdateInterval;

    const AD_TOKEN_ADDRESS = "0x7E99075Ce287F1cF8cBCAaa6A1C7894e404fD7Ea";
    const AD_PUNKS_ADDRESS = "0x79BE8AcdD339C7b92918fcC3fd3875b5Aaad7566";
    const STAKING_ADDRESS = "0xaf22843e195b792a3f874562ab7cee751066665e";
    const TOKEN_ADDRESS = "0x7E99075Ce287F1cF8cBCAaa6A1C7894e404fD7Ea";

    // ABIs
    const erc20ABI = [
      {
        "constant": true,
        "inputs": [],
        "name": "name",
        "outputs": [{"name": "", "type": "string"}],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
      },
      {
        "constant": true,
        "inputs": [],
        "name": "symbol",
        "outputs": [{"name": "", "type": "string"}],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
      },
      {
        "constant": true,
        "inputs": [],
        "name": "decimals",
        "outputs": [{"name": "", "type": "uint8"}],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
      },
      {
        "constant": true,
        "inputs": [{"name": "_owner", "type": "address"}],
        "name": "balanceOf",
        "outputs": [{"name": "balance", "type": "uint256"}],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
      },
      {
        "constant": false,
        "inputs": [
          {"name": "_to", "type": "address"},
          {"name": "_value", "type": "uint256"}
        ],
        "name": "transfer",
        "outputs": [{"name": "", "type": "bool"}],
        "payable": false,
        "stateMutability": "nonpayable",
        "type": "function"
      },
      {
        "constant": false,
        "inputs": [
          {"name": "_spender", "type": "address"},
          {"name": "_value", "type": "uint256"}
        ],
        "name": "approve",
        "outputs": [{"name": "", "type": "bool"}],
        "payable": false,
        "stateMutability": "nonpayable",
        "type": "function"
      },
      {
        "constant": true,
        "inputs": [
          {"name": "_owner", "type": "address"},
          {"name": "_spender", "type": "address"}
        ],
        "name": "allowance",
        "outputs": [{"name": "", "type": "uint256"}],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
      }
    ];

    const stakingABI = [
      "function batchStake(uint256[]) returns ()",
      "function batchUnstake(uint256[]) returns ()",
      "function batchClaimRewards(uint256[]) returns (uint256)",
      "function getTokenDetailedInfo(uint256) view returns (uint256,uint256,uint256,uint256,uint256,int256,uint256)",
      "function getTokenStats(uint256) view returns (uint256,uint256)",
      "function getTokenArmoryDetails(uint256) view returns (uint256,uint256,uint256[],uint256)",
      "function getWalletStats(address,uint256[]) view returns (uint256[],uint256,uint256)",
      "function stakes(uint256) view returns (uint256,uint256)",
      "function baseRewardRate() view returns (uint256)",
      "function activationFee() view returns (uint256)",
      "function claimFee() view returns (uint256)",
      "function exitFee() view returns (uint256)",
      "function repairFee() view returns (uint256)",
      "function extraSlotCost() view returns (uint256)",
      "function fastLevelUpgradeFee() view returns (uint256)",
      "function fastLevelUpgradeBonusIncrement() view returns (uint256)",
      "function maxSlots() view returns (uint256)",
      "function socialBoostActiveUntil() view returns (uint256)",
      "function socialBoostBonus() view returns (uint256)",
      "function socialBoostDuration() view returns (uint256)",
      "function socialMinTokens() view returns (uint256)",
      "function isSocialBoostActive() view returns (bool)",
      "function totalStaked() view returns (uint256)",
      "function totalItemsEquipped() view returns (uint256)",
      "function totalItemsPurchased() view returns (uint256)",
      "function pendingPassiveReward(uint256) view returns (uint256)",
      "function pendingGameReward(uint256) view returns (uint256)",
      "function pendingTotalReward(uint256) view returns (uint256)"
    ];
    const nftABI = [
      "function balanceOf(address) view returns (uint256)",
      "function tokenOfOwnerByIndex(address,uint256) view returns (uint256)",
      "function ownerOf(uint256) view returns (address)"
    ];

    // Helpers to format amounts
    function formatAmount(amount) {
      const value = parseFloat(ethers.utils.formatUnits(amount, 18));
      return value.toLocaleString('en-US', { minimumFractionDigits: 1, maximumFractionDigits: 1 }) + " $ADRIAN";
    }

    // Display fee info
    async function displayFeeInfo() {
      if (!stakingContract) return;
      try {
        const activationFee = await stakingContract.activationFee();
        const exitFee = await stakingContract.exitFee();
        document.getElementById('fee-info').textContent = `Stake Cost: ${formatAmount(activationFee)} | Unstake Cost: ${formatAmount(exitFee)}`;
      } catch (e) {
        document.getElementById('fee-info').textContent = "Error fetching fee info: " + e.message;
      }
    }

    // Load tokens with images from JSON
    async function loadTokens(ownerAddress) {
      try {
        const tokensGrid = document.getElementById("tokens-grid");
        tokensGrid.innerHTML = "";

        // Obtener el balance total de NFTs
        const balance = await nftContract.balanceOf(ownerAddress);
        const totalTokens = balance.toNumber();

        if (totalTokens === 0) {
          tokensGrid.innerHTML = "<p>No tokens found in your wallet.</p>";
          return;
        }

        // Cargar cada token
        for (let i = 0; i < totalTokens; i++) {
          try {
            const tokenId = await nftContract.tokenOfOwnerByIndex(ownerAddress, i);
            const isStaked = await stakingContract.stakes(tokenId).then(res => res[0].gt(0));
            
            // Determinar la extensión del archivo basado en el token ID
            const extension = tokenId.lt(1000) ? '.gif' : '.png';
            
            const tokenCard = document.createElement("div");
            tokenCard.className = "col";
            tokenCard.innerHTML = `
              <div class="card h-100 token-card ${isStaked ? 'staked' : ''}" data-token-id="${tokenId}">
                <img src="https://ipfs.io/ipfs/bafybeibfywb3emvjod5owcus7nyn4fqosqrbvuq2cyxczhbmavfxuautsy/${tokenId}${extension}" 
                     class="card-img-top" alt="Token ${tokenId}">
                <div class="card-body">
                  <h5 class="card-title">Token #${tokenId}</h5>
                  <p class="card-text">Status: ${isStaked ? 'Staked' : 'Not Staked'}</p>
                </div>
              </div>
            `;
            tokensGrid.appendChild(tokenCard);

            // Agregar event listener para selección
            const card = tokenCard.querySelector('.token-card');
            card.addEventListener('click', () => {
              selectedTokenIds = [tokenId];
              document.querySelectorAll('.token-card').forEach(c => c.classList.remove('selected-token'));
              card.classList.add('selected-token');
              displayTokenStats();
            });
          } catch (tokenError) {
            console.error(`Error loading token ${i}:`, tokenError);
            continue;
          }
        }
      } catch (error) {
        console.error("Error loading tokens:", error);
        document.getElementById("tokens-grid").innerHTML = 
          `<p class="text-danger">Error loading tokens: ${error.message}</p>`;
      }
    }

    // Display aggregate rewards
    async function displayAggregateRewards() {
      if (!stakingContract || !signer || allMyTokenIds.length === 0) return;
      try {
        const walletAddress = await signer.getAddress();
        const [, pendingPassive, pendingGame] = await stakingContract.getWalletStats(
          walletAddress,
          allMyTokenIds
        );
        const total = pendingPassive.add(pendingGame);

        const rewardsElement = document.getElementById('total-rewards');
        rewardsElement.textContent = formatAmount(total);
        rewardsElement.classList.add('rewards-update');
        setTimeout(() => rewardsElement.classList.remove('rewards-update'), 500);
      } catch (err) {
        console.error("Error fetching wallet stats:", err);
        document.getElementById('total-rewards').textContent = "Error loading rewards";
      }
    }

    // Display token statistics
    async function displayTokenStats() {
      const out = document.getElementById('individual-token-stats');

      if (selectedTokenIds.length === 0) {
        out.textContent = 'Select one or more tokens to view detailed statistics.';
        return;
      }

      try {
        let html = '<div class="token-stats-container">';
        selectedTokenIds.sort((a, b) => Number(a) - Number(b));

        // Obtener todos los stakes de una vez
        const stakesPromises = selectedTokenIds.map(tokenId => 
          stakingContract.stakes(tokenId).catch(() => [ethers.BigNumber.from(0), ethers.BigNumber.from(0)])
        );
        const stakes = await Promise.all(stakesPromises);

        // Obtener todos los pending rewards de una vez
        const rewardsPromises = selectedTokenIds.map(tokenId => 
          stakingContract.pendingPassiveReward(tokenId).catch(() => ethers.BigNumber.from(0))
        );
        const pendingRewards = await Promise.all(rewardsPromises);

        for (let i = 0; i < selectedTokenIds.length; i++) {
          const tokenId = selectedTokenIds[i];
          const [stakeStart, lastClaim] = stakes[i];
          const pendingReward = pendingRewards[i];
          const isStaked = stakeStart.gt(0);
          const stakingHrs = isStaked
            ? Math.floor((Date.now()/1000 - stakeStart.toNumber()) / 3600)
            : 0;

          html += `
            <div class="token-stats-item">
              <h3>Token #${tokenId}</h3>
              <p>Status: ${isStaked ? 'Staked' : 'Not Staked'}</p>
              ${isStaked ? `
                <p>Staking Duration: ${stakingHrs} hours</p>
                <p>Last Claim: ${new Date(lastClaim.toNumber()*1000).toLocaleString()}</p>
                <p>Pending Rewards: ${pendingReward.toNumber()} $ADRIAN</p>
              ` : ''}
            </div>`;
        }

        out.innerHTML = html + '</div>';
      } catch (err) {
        console.error("Error fetching token stats:", err);
        out.innerHTML = `<div class="token-stats-item">
                           <h3>Error</h3>
                           <p style="color:var(--accent-red);">Error loading stats. Please try again later.</p>
                         </div>`;
      }
    }

    // Stake tokens in batch
    async function stakeTokens() {
      if (selectedTokenIds.length === 0) return alert('Please select tokens to stake.');
      try {
        const walletAddress = await signer.getAddress();
        const activationFee = await stakingContract.activationFee();
        const totalFee = activationFee.mul(selectedTokenIds.length);
        const allowance = await tokenContract.allowance(walletAddress, STAKING_ADDRESS);
        if (allowance.lt(totalFee)) {
          document.getElementById('general-output').textContent = 'Approving spending...';
          const tx = await tokenContract.approve(STAKING_ADDRESS, totalFee);
          await tx.wait();
        }
        const txStake = await stakingContract.batchStake(selectedTokenIds);
        await txStake.wait();
        document.getElementById('general-output').textContent = 'Staked: ' + selectedTokenIds.join(', ');
        loadTokens(walletAddress);
        displayAggregateRewards();
      } catch (e) {
        document.getElementById('general-output').textContent = 'Error staking: ' + e.message;
      }
    }

    async function connectWallet() {
      try {
        if (!window.ethereum) {
          document.getElementById("wallet-info").innerText = "Please install MetaMask.";
          return;
        }
        // Configurar el provider de MetaMask
        const web3Provider = new ethers.providers.Web3Provider(window.ethereum);
        // Configurar el provider de Base para consultas usando Infura
        const etherscanProvider = new ethers.providers.JsonRpcProvider("https://base-mainnet.infura.io/v3/cc0c8013b1e044dcba79d4f7ec3b2ba1", {
          name: "base",
          chainId: 8453
        });
        // Usar el provider de MetaMask para transacciones
        provider = web3Provider;
        await provider.send("eth_requestAccounts", []);
        signer = provider.getSigner();
        const walletAddress = await signer.getAddress();
        const shortAddress = walletAddress.substring(0,6) + "..." + walletAddress.substring(walletAddress.length - 4);
        document.getElementById("wallet-info").innerHTML = `<p class="wallet-address">Connected: ${shortAddress}</p>`;
        // Usar el provider de Base para consultas de contrato
        stakingContract = new ethers.Contract(STAKING_ADDRESS, stakingABI, etherscanProvider);
        tokenContract = new ethers.Contract(TOKEN_ADDRESS, erc20ABI, etherscanProvider);
        nftContract = new ethers.Contract(AD_PUNKS_ADDRESS, nftABI, etherscanProvider);
        document.getElementById("connect-wallet").disabled = true;
        document.getElementById("stake-actions").style.display = "block";
        document.getElementById("tokens-section").style.display = "block";
        document.getElementById("total-rewards-section").style.display = "block";
        await loadTokens(walletAddress);
        displayAggregateRewards();
      } catch (error) {
        console.error("Error connecting wallet:", error);
        document.getElementById("wallet-info").innerText = "Error connecting wallet: " + error.message;
      }
    }

    // Event Listeners
    document.getElementById('connect-wallet').addEventListener('click', connectWallet);
    document.getElementById('stake-token').addEventListener('click', stakeTokens);
    document.getElementById('unstake-token').addEventListener('click', async () => {
      if (selectedTokenIds.length === 0) {
        alert('Please select token(s) first'); return;
      }

      const general_output = document.getElementById('general-output');
      try {
        const wallet = await signer.getAddress();
        const exitFee  = await stakingContract.exitFee();
        const totalFee = exitFee.mul(selectedTokenIds.length);
        const allowance = await tokenContract.allowance(wallet, STAKING_ADDRESS);

        if (allowance.lt(totalFee)) {
          general_output.textContent = 'Approving exit fee…';
          // Aprobamos una cantidad mayor para evitar problemas de gas
          const txA = await tokenContract.approve(STAKING_ADDRESS, totalFee.mul(2));
          await txA.wait();
        }

        general_output.textContent = 'Unstaking…';
        const tx = await stakingContract.batchUnstake(selectedTokenIds, {
          gasLimit: 300000 // Añadimos un límite de gas explícito
        });
        await tx.wait();

        general_output.textContent = 'Unstaked: ' + selectedTokenIds.join(', ');
        selectedTokenIds = [];                 // limpiamos selección
        loadTokens(wallet);                          // refresca grilla
        displayAggregateRewards();             // refresca recompensas globales
      } catch (err) {
        general_output.textContent = 'Error unstaking: ' + err.message;
        console.error(err);
      }
    });
    document.getElementById('claim-token').addEventListener('click', () => {
      // Implement batchClaimRewards if desired
    });
    document.getElementById('refresh-info').addEventListener('click', async () => {
      try {
        const address = await signer.getAddress();
        await loadTokens(address);
      } catch (error) {
        console.error("Error refreshing tokens:", error);
        document.getElementById("tokens-grid").innerHTML = 
          `<p class="text-danger">Error refreshing tokens: ${error.message}</p>`;
      }
    });
  </script>
</body>
</html>
