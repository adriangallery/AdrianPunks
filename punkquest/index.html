Aquí tienes el HTML completo, con la definición de los tres ABIs reinsertada justo antes de usarlos. Sólo he añadido esa parte; el resto queda igual:

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>PunkQuest Retro - Stake & Claim Rewards</title>
  <!-- Bootstrap 5 CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet" />
  <link rel="stylesheet" href="/market/styles.css">
  <style>
    /* ... (todo tu CSS tal cual estaba) ... */
  </style>
</head>
<body>
  <div class="container">
    <!-- ... (todo tu HTML tal cual estaba) ... -->
  </div>

  <!-- Bootstrap 5 JS y Ethers.js -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
  <script>
    let provider, signer;
    let tokenContract, stakingContract, nftContract;
    let selectedTokenIds = [];
    let rewardsUpdateInterval;

    const AD_TOKEN_ADDRESS = "0x7E99075Ce287F1cF8cBCAaa6A1C7894e404fD7Ea";
    const AD_PUNKS_ADDRESS = "0x79BE8AcdD339C7b92918fcC3fd3875b5Aaad7566";
    const STAKING_ADDRESS = "0x64c46fca3f46442c7abd5303dc1c56a79f4e4273";

    // === AÑADIDO: DEFINICIÓN DE ABI ===
    const tokenABI = [
      "function balanceOf(address) view returns (uint256)",
      "function allowance(address,address) view returns (uint256)",
      "function approve(address,uint256) returns (bool)",
      "function decimals() view returns (uint8)"
    ];
    const stakingABI = [
      "function activationFee() view returns (uint256)",
      "function exitFee() view returns (uint256)",
      "function batchStake(uint256[]) returns ()",
      "function batchUnstake(uint256[]) returns ()",
      "function batchClaimRewards(uint256[]) returns (uint256)"
    ];
    const nftABI = [
      "function balanceOf(address) view returns (uint256)",
      "function tokenOfOwnerByIndex(address,uint256) view returns (uint256)"
    ];
    // ==================================

    function formatAmount(amount) {
      const value = parseFloat(ethers.utils.formatUnits(amount, 18));
      return value.toLocaleString('en-US', { minimumFractionDigits: 1, maximumFractionDigits: 1 }) + " $ADRIAN";
    }

    async function displayFeeInfo() {
      if (!stakingContract) return;
      try {
        const activationFee = await stakingContract.activationFee();
        const exitFee = await stakingContract.exitFee();
        document.getElementById('fee-info').textContent = `Stake Cost: ${formatAmount(activationFee)} | Unstake Cost: ${formatAmount(exitFee)}`;
      } catch (e) {
        document.getElementById('fee-info').textContent = "Error fetching fee info: " + e.message;
      }
    }

    async function loadTokens() {
      try {
        const walletAddress = await signer.getAddress();
        const response = await fetch('/punkquest/adrianpunks.json');
        const data = await response.json();
        const collection = data.collection;
        const balance = await nftContract.balanceOf(walletAddress);
        const count = balance.toNumber();
        const grid = document.getElementById('tokens-grid');
        grid.innerHTML = '';
        selectedTokenIds = [];
        for (let i = 0; i < count; i++) {
          const tokenId = (await nftContract.tokenOfOwnerByIndex(walletAddress, i)).toString();
          const tokenInfo = collection.find(item => {
            const parts = item.name?.split("#");
            return parts?.[1] === tokenId;
          });
          const imgSrc = tokenInfo ? tokenInfo.image : `https://via.placeholder.com/150?text=Token+${tokenId}`;
          const col = document.createElement('div'); col.className = 'col';
          const card = document.createElement('div'); card.className = 'card token-card'; card.dataset.tokenId = tokenId;
          const img = document.createElement('img'); img.src = imgSrc; img.alt = `Token ${tokenId}`;
          const label = document.createElement('div'); label.style.textAlign = 'center'; label.style.marginTop = '0.5rem'; label.textContent = `Token ${tokenId}`;
          card.append(img, label);
          card.addEventListener('click', () => {
            const id = card.dataset.tokenId;
            if (selectedTokenIds.includes(id)) {
              selectedTokenIds = selectedTokenIds.filter(x => x !== id);
              card.classList.remove('selected-token');
            } else {
              selectedTokenIds.push(id);
              card.classList.add('selected-token');
            }
            document.getElementById('action-output').textContent = 'Selected tokens: ' + selectedTokenIds.join(', ');
            displayFeeInfo();
          });
          col.appendChild(card);
          grid.appendChild(col);
        }
        displayAggregateRewards();
        displayFeeInfo();
      } catch (error) {
        document.getElementById('general-output').textContent = "Error loading tokens: " + error.message;
      }
    }

    async function displayAggregateRewards() {
      // placeholder
    }

    function showMessage(message, type = 'info') {
      const messageDiv = document.getElementById('general-output');
      messageDiv.textContent = message;
      messageDiv.className = `message ${type}`;
      setTimeout(() => {
        messageDiv.textContent = '';
        messageDiv.className = 'message';
      }, 5000);
    }

    // Stake tokens in batch
    async function stakeTokens() {
      try {
        if (!window.ethereum) {
          throw new Error('MetaMask no está instalado');
        }

        const selectedCards = document.querySelectorAll('.token-card.selected-token');
        if (selectedCards.length === 0) {
          throw new Error('Por favor, selecciona al menos un token');
        }

        const selectedTokens = Array.from(selectedCards).map(card => parseInt(card.dataset.tokenId));
        const activationFee = await stakingContract.activationFee();
        const totalCost = activationFee.mul(selectedTokens.length);

        const approveTx = await tokenContract.approve(
          stakingContract.address,
          totalCost,
          {
            customData: {
              title: "PunkQuest - Staking Approval",
              description: `Aprobando ${ethers.utils.formatEther(totalCost)} ADRIAN para staking de ${selectedTokens.length} tokens`
            }
          }
        );
        await approveTx.wait();

        const stakeTx = await stakingContract.batchStake(selectedTokens, {
          customData: {
            title: "PunkQuest - Staking",
            description: `Staking ${selectedTokens.length} tokens`
          }
        });
        await stakeTx.wait();

        await loadTokens();
        await displayAggregateRewards();
        showMessage('Tokens staked exitosamente', 'success');
      } catch (error) {
        console.error('Error en stakeTokens:', error);
        showMessage(error.message || 'Error al hacer stake de los tokens', 'error');
      }
    }

    document.getElementById('connect-wallet').addEventListener('click', async () => {
      if (!window.ethereum) {
        document.getElementById('wallet-info').innerHTML = '<p>Please install MetaMask!</p>';
        return;
      }
      try {
        await window.ethereum.request({ method: 'eth_requestAccounts' });
        provider = new ethers.providers.Web3Provider(window.ethereum);
        signer = provider.getSigner();
        tokenContract = new ethers.Contract(AD_TOKEN_ADDRESS, tokenABI, signer);
        stakingContract = new ethers.Contract(STAKING_ADDRESS, stakingABI, signer);
        nftContract = new ethers.Contract(AD_PUNKS_ADDRESS, nftABI, signer);

        const address = await signer.getAddress();
        const shortAddr = address.substring(0,6) + '...' + address.slice(-4);
        const rawBalance = await tokenContract.balanceOf(address);
        const decimals = await tokenContract.decimals();
        const bal = parseFloat(ethers.utils.formatUnits(rawBalance, decimals)).toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
        document.getElementById('wallet-info').innerHTML = `<p class="wallet-address">Connected: ${shortAddr}</p><p class="wallet-address">Balance: ${bal} $ADRIAN</p>`;

        loadTokens();
        window.ethereum.on('accountsChanged', () => location.reload());
        window.ethereum.on('chainChanged', () => location.reload());
      } catch (error) {
        document.getElementById('wallet-info').innerHTML = `<p>Error: ${error.message}</p>`;
      }
    });

    document.getElementById('stake-token').addEventListener('click', stakeTokens);
    document.getElementById('unstake-token').addEventListener('click', () => {
      // batchUnstake...
    });
    document.getElementById('claim-token').addEventListener('click', () => {
      // batchClaimRewards...
    });
    document.getElementById('refresh-info').addEventListener('click', () => {
      loadTokens();
    });
  </script>
</body>
</html>