<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>PunkQuest - Season one</title>
  <!-- Bootstrap 5 CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet" />
  <link rel="stylesheet" href="/market/styles.css">
  <!-- Ethers.js -->
  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
  <style>
    :root {
      --bg-color: #f0f0f0;
      --primary-text: #333333;
      --accent-purple: #8a2be2;
      --accent-purple-hover: #7a1dd2;
      --accent-blue: #4dabf7;
      --card-bg: #ffffff;
      --card-border: #e9ecef;
      --card-selected-border: #8a2be2;
      --screen-bg: #ffffff;
      --navbar-height: 60px;
      --error-bg: #f8d7da;
      --error-border: #f5c6cb;
      --error-text: #721c24;
      --success-bg: #d4edda;
      --success-border: #c3e6cb;
      --success-text: #155724;
    }
    
    body {
      background-color: var(--bg-color);
      color: var(--primary-text);
      font-family: 'Share Tech Mono', monospace;
      margin: 0;
      padding: 20px;
      line-height: 1.6;
      padding-top: calc(var(--navbar-height) + 20px);
    }
    
    .container {
      max-width: 1200px;
      margin: auto;
      padding: 20px;
      background: var(--screen-bg);
      border-radius: 8px;
      box-shadow: 0 4px 10px rgba(0,0,0,0.1);
    }
    
    header {
      text-align: center;
      padding: 2rem;
      margin-bottom: 2rem;
      position: relative;
    }
    
    header h1 {
      font-size: 2.5rem;
      margin: 0;
      color: var(--primary-text);
      font-weight: 600;
      letter-spacing: 1px;
    }
    
    header p {
      margin-top: 1rem;
      font-size: 1rem;
      color: var(--primary-text);
      opacity: 0.8;
    }
    
    .card {
      background: var(--card-bg);
      border: 1px solid var(--card-border);
      border-radius: 8px;
      padding: 1rem;
      margin-bottom: 1.5rem;
      box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    }
    
    .section-title {
      font-size: 1.4rem;
      margin-bottom: 1.5rem;
      color: var(--primary-text);
      font-weight: 600;
      border-bottom: 2px solid var(--card-border);
      padding-bottom: 0.5rem;
    }
    
    .token-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 1rem;
      padding: 0;
      margin: 0;
    }
    
    @media (max-width: 768px) {
      .token-grid {
        grid-template-columns: repeat(2, 1fr);
      }
    }
    
    @media (max-width: 480px) {
      .token-grid {
        grid-template-columns: 1fr;
      }
    }
    
    .token-card {
      background: var(--card-bg);
      border: 1px solid var(--card-border);
      border-radius: 8px;
      padding: 0.8rem;
      cursor: pointer;
      transition: all 0.2s ease;
      position: relative;
    }
    
    .token-card:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 8px rgba(0,0,0,0.1);
    }
    
    .token-card img {
      width: 100%;
      height: auto;
      object-fit: contain;
      border-radius: 4px;
      aspect-ratio: 1/1;
      background-color: #f0f0f0;
    }
    
    .token-info {
      padding: 0.5rem 0;
    }
    
    .token-title {
      font-size: 1.1rem;
      font-weight: bold;
      margin-bottom: 0.5rem;
    }
    
    .token-status {
      display: inline-block;
      padding: 0.25rem 0.5rem;
      border-radius: 9999px;
      font-size: 0.75rem;
      font-weight: 600;
      margin-bottom: 0.5rem;
    }
    
    .status-mirrored {
      background-color: #d1fae5;
      color: #065f46;
    }
    
    .status-not-mirrored {
      background-color: #fef3c7;
      color: #92400e;
    }
    
    .token-version {
      font-size: 0.9rem;
      color: #6b7280;
    }
    
    .selected-token {
      border: 2px solid var(--card-selected-border);
      box-shadow: 0 0 0 2px var(--card-selected-border);
    }
    
    .btn-connect {
      background-color: var(--accent-purple);
      color: white;
      border: none;
      padding: 0.75rem 1.5rem;
      font-size: 1rem;
      border-radius: 0.5rem;
      cursor: pointer;
      transition: background-color 0.3s ease;
    }
    
    .btn-connect:hover {
      background-color: var(--accent-purple-hover);
    }
    
    .btn-action {
      background-color: var(--accent-purple);
      color: white;
      border: none;
      padding: 0.75rem 1.5rem;
      font-size: 1rem;
      border-radius: 0.5rem;
      cursor: pointer;
      transition: all 0.3s ease;
      display: inline-block;
      text-align: center;
      margin-right: 0.5rem;
      margin-bottom: 0.5rem;
    }
    
    .btn-action:hover {
      background-color: var(--accent-purple-hover);
      transform: translateY(-2px);
    }
    
    .btn-secondary {
      background-color: #6c757d;
    }
    
    .btn-secondary:hover {
      background-color: #5a6268;
    }
    
    .account-display {
      display: inline-block;
      background-color: #f0f0f0;
      padding: 0.5rem 1rem;
      border-radius: 9999px;
      font-family: monospace;
      font-size: 0.9rem;
    }
    
    .alert {
      padding: 1rem;
      border-radius: 0.375rem;
      margin-bottom: 1rem;
    }
    
    .alert-danger {
      background-color: var(--error-bg);
      border: 1px solid var(--error-border);
      color: var(--error-text);
    }
    
    .alert-success {
      background-color: var(--success-bg);
      border: 1px solid var(--success-border);
      color: var(--success-text);
    }
    
    .version-selector {
      width: 100%;
      padding: 0.5rem;
      border-radius: 0.375rem;
      border: 1px solid var(--card-border);
      margin-bottom: 1rem;
    }
    
    .token-badge {
      display: inline-block;
      background-color: #e0e7ff;
      color: #4338ca;
      padding: 0.25rem 0.5rem;
      border-radius: 9999px;
      font-size: 0.75rem;
      margin-right: 0.25rem;
      margin-bottom: 0.25rem;
    }
    
    .footer {
      text-align: center;
      margin-top: 2rem;
      padding-top: 1rem;
      border-top: 1px solid var(--card-border);
      color: #9ca3af;
      font-size: 0.875rem;
    }

    .token-image-container {
      width: 100%;
      aspect-ratio: 1/1;
      overflow: hidden;
      border-radius: 4px;
      background-color: #f0f0f0;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .token-image {
      width: 100%;
      height: 100%;
      object-fit: contain;
      display: block;
    }
  </style>
</head>
<body>
  <!-- Include the menu -->
  <div id="menu-container"></div>
  <script>
    // Load the menu
    fetch('/market/components/menu.html')
      .then(response => response.text())
      .then(html => {
        document.getElementById('menu-container').innerHTML = html;
        // Ensure menu has correct style
        const menu = document.querySelector('.navbar');
        if (menu) {
          menu.classList.add('navbar-dark', 'bg-dark');
        }
        // Initialize Bootstrap's JavaScript for the menu
        const menuScript = document.createElement('script');
        menuScript.src = 'https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js';
        menuScript.onload = () => {
          // Asegurarse de que el menú esté cerrado al cargar
          const navbarCollapse = document.querySelector('.navbar-collapse');
          if (navbarCollapse) {
            navbarCollapse.classList.remove('show');
            // Forzar el cierre del menú
            const bsCollapse = new bootstrap.Collapse(navbarCollapse, {
              toggle: false
            });
            bsCollapse.hide();
          }
        };
        document.head.appendChild(menuScript);
      })
      .catch(error => console.error('Error loading menu:', error));
  </script>

  <div class="container">
    <!-- Header -->
    <header>
      <h1>PunkQuest - Season one</h1>
      <p>Manage your AdrianPunks and their versions</p>
    </header>
    
    <!-- Connect Wallet Section -->
    <div id="connect-section" class="text-center mb-4">
      <button id="connectWalletBtn" class="btn-connect">Connect Wallet</button>
    </div>
    
    <!-- Account Info Section (hidden by default) -->
    <div id="account-section" class="text-center mb-4" style="display: none;">
      <p>Connected Wallet:</p>
      <div id="accountDisplay" class="account-display"></div>
    </div>
    
    <!-- Alert Messages -->
    <div id="errorAlert" class="alert alert-danger" style="display: none;"></div>
    <div id="successAlert" class="alert alert-success" style="display: none;"></div>
    
    <!-- Token Management Section (hidden by default) -->
    <div id="token-management" class="card" style="display: none;">
      <div class="d-flex justify-content-between align-items-center mb-3">
        <h2 class="section-title mb-0">Your AdrianPunks</h2>
        <button id="selectAllBtn" class="btn-secondary btn-action">Select All</button>
      </div>
      
      <div id="loading-tokens" class="text-center py-5">
        <div class="spinner-border text-primary" role="status">
          <span class="visually-hidden">Loading...</span>
        </div>
        <p class="mt-2">Loading your tokens...</p>
      </div>
      
      <div id="no-tokens-message" class="text-center py-5" style="display: none;">
        <p>You don't own any AdrianPunks yet</p>
      </div>
      
      <!-- Token Grid -->
      <div id="token-grid" class="token-grid mb-4"></div>
      
      <!-- Action Button -->
      <button id="syncBtn" class="btn-action w-100 mb-3" disabled>Sync Ownership (0 selected)</button>
    </div>
    
    <!-- Version Management Section (hidden by default) -->
    <div id="version-management" class="card" style="display: none;">
      <h2 class="section-title">Update Versions</h2>
      
      <div id="no-selection-message" class="text-center mb-3">
        <p>Select tokens above to change their versions</p>
      </div>
      
      <div id="selection-info" style="display: none;">
        <p>Selected Tokens: <span id="selectedCount">0</span></p>
        <div id="selectedTokensList" class="mb-3"></div>
      </div>
      
      <div class="mb-3">
        <label for="versionSelector" class="form-label">Select Version</label>
        <select id="versionSelector" class="version-selector"></select>
      </div>
      
      <button id="updateVersionBtn" class="btn-action w-100" disabled>Update Version</button>
    </div>
    
    <!-- Footer -->
    <div class="footer">
      <p id="contractAddressInfo"></p>
      <p>© 2025 AdrianPunks</p>
    </div>
  </div>

  <script>
    // Configuración de Infura y provider base
    const INFURA_URL = "https://base-mainnet.infura.io/v3/cc0c8013b1e044dcba79d4f7ec3b2ba1";
    const NETWORK_CONF = { name: "base", chainId: 8453 };
    const baseProvider = new ethers.providers.JsonRpcProvider(INFURA_URL, NETWORK_CONF);

    // Variables globales
    let provider;
    let signer;
    let tokenContract, stakingContract, nftContract;
    let selectedTokenIds = [];
    let allMyTokenIds = [];
    let rewardsUpdateInterval;
    let tokenDecimals = 0; // Variable global para los decimales

    const AD_TOKEN_ADDRESS = "0x7E99075Ce287F1cF8cBCAaa6A1C7894e404fD7Ea";
    const AD_PUNKS_ADDRESS = "0x79BE8AcdD339C7b92918fcC3fd3875b5Aaad7566";
    const STAKING_ADDRESS = "0xaf22843e195b792a3f874562ab7cee751066665e";
    const TOKEN_ADDRESS = "0x7E99075Ce287F1cF8cBCAaa6A1C7894e404fD7Ea";

    // ABIs
    const erc20ABI = [
      {
        "constant": true,
        "inputs": [],
        "name": "name",
        "outputs": [{"name": "", "type": "string"}],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
      },
      {
        "constant": true,
        "inputs": [],
        "name": "symbol",
        "outputs": [{"name": "", "type": "string"}],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
      },
      {
        "constant": true,
        "inputs": [],
        "name": "decimals",
        "outputs": [{"name": "", "type": "uint8"}],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
      },
      {
        "constant": true,
        "inputs": [{"name": "_owner", "type": "address"}],
        "name": "balanceOf",
        "outputs": [{"name": "balance", "type": "uint256"}],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
      },
      {
        "constant": false,
        "inputs": [
          {"name": "_to", "type": "address"},
          {"name": "_value", "type": "uint256"}
        ],
        "name": "transfer",
        "outputs": [{"name": "", "type": "bool"}],
        "payable": false,
        "stateMutability": "nonpayable",
        "type": "function"
      },
      {
        "constant": false,
        "inputs": [
          {"name": "_spender", "type": "address"},
          {"name": "_value", "type": "uint256"}
        ],
        "name": "approve",
        "outputs": [{"name": "", "type": "bool"}],
        "payable": false,
        "stateMutability": "nonpayable",
        "type": "function"
      },
      {
        "constant": true,
        "inputs": [
          {"name": "_owner", "type": "address"},
          {"name": "_spender", "type": "address"}
        ],
        "name": "allowance",
        "outputs": [{"name": "", "type": "uint256"}],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
      }
    ];

    const stakingABI = [
      "function batchStake(uint256[]) returns ()",
      "function batchUnstake(uint256[]) returns ()",
      "function batchClaimRewards(uint256[]) returns (uint256)",
      "function getTokenDetailedInfo(uint256) view returns (uint256,uint256,uint256,uint256,uint256,int256,uint256)",
      "function getTokenStats(uint256) view returns (uint256,uint256)",
      "function getTokenArmoryDetails(uint256) view returns (uint256,uint256,uint256[],uint256)",
      "function getWalletStats(address,uint256[]) view returns (uint256[],uint256,uint256)",
      "function stakes(uint256) view returns (uint256,uint256)",
      "function baseRewardRate() view returns (uint256)",
      "function activationFee() view returns (uint256)",
      "function claimFee() view returns (uint256)",
      "function exitFee() view returns (uint256)",
      "function repairFee() view returns (uint256)",
      "function extraSlotCost() view returns (uint256)",
      "function fastLevelUpgradeFee() view returns (uint256)",
      "function fastLevelUpgradeBonusIncrement() view returns (uint256)",
      "function maxSlots() view returns (uint256)",
      "function socialBoostActiveUntil() view returns (uint256)",
      "function socialBoostBonus() view returns (uint256)",
      "function socialBoostDuration() view returns (uint256)",
      "function socialMinTokens() view returns (uint256)",
      "function isSocialBoostActive() view returns (bool)",
      "function totalStaked() view returns (uint256)",
      "function totalItemsEquipped() view returns (uint256)",
      "function totalItemsPurchased() view returns (uint256)",
      "function pendingPassiveReward(uint256) view returns (uint256)",
      "function pendingGameReward(uint256) view returns (uint256)",
      "function pendingTotalReward(uint256) view returns (uint256)"
    ];
    const nftABI = [
      "function balanceOf(address) view returns (uint256)",
      "function tokenOfOwnerByIndex(address,uint256) view returns (uint256)",
      "function ownerOf(uint256) view returns (address)"
    ];

    // Helpers to format amounts
    function formatAmount(amount) {
      return amount.toString() + " $ADRIAN";
    }

    // Display fee info
    async function displayFeeInfo() {
      if (!stakingContract) return;
      try {
        const activationFee = await stakingContract.activationFee();
        const exitFee = await stakingContract.exitFee();
        document.getElementById('fee-info').textContent = `Stake Cost: ${formatAmount(activationFee)} | Unstake Cost: ${formatAmount(exitFee)}`;
      } catch (e) {
        document.getElementById('fee-info').textContent = "Error fetching fee info: " + e.message;
      }
    }

    // Load tokens with images from JSON
    async function loadTokens(ownerAddress) {
      try {
        const tokensGrid = document.getElementById("tokens-grid");
        tokensGrid.innerHTML = "";
        allMyTokenIds = []; // Reiniciar la lista de IDs

        // Configurar Multicall
        const multicall = new ethers.Contract(
          "0xcA11bde05977b3631167028862bE2a173976CA11", // Multicall3 address
          [
            "function aggregate3(tuple(address target, bool allowFailure, bytes callData)[] calls) public view returns (tuple(bool success, bytes returnData)[] returnData)"
          ],
          baseProvider
        );

        // Obtener el balance total de NFTs
        const balance = await nftContract.balanceOf(ownerAddress);
        const totalTokens = balance.toNumber();

        if (totalTokens === 0) {
          tokensGrid.innerHTML = "<p>No tokens found in your wallet.</p>";
          return;
        }

        // Preparar llamadas para obtener todos los tokenIds
        const calls = [];
        for (let i = 0; i < totalTokens; i++) {
          calls.push({
            target: AD_PUNKS_ADDRESS,
            allowFailure: true,
            callData: nftContract.interface.encodeFunctionData('tokenOfOwnerByIndex', [ownerAddress, i])
          });
        }

        // Ejecutar todas las llamadas en una sola transacción
        const results = await multicall.aggregate3(calls);
        const tokenIds = results
          .filter(result => result.success)
          .map(result => {
            const decoded = nftContract.interface.decodeFunctionResult('tokenOfOwnerByIndex', result.returnData);
            return decoded[0];
          });

        // Cargar el JSON con la información de los tokens
        const response = await fetch('/punkquest/adrianpunks.json');
        const data = await response.json();
        const jsonCollection = data.collection;

        // Preparar llamadas para verificar stakes
        const stakeCalls = tokenIds.map(tokenId => ({
          target: STAKING_ADDRESS,
          allowFailure: true,
          callData: stakingContract.interface.encodeFunctionData('stakes', [tokenId])
        }));

        // Ejecutar todas las llamadas de stakes en una sola transacción
        const stakeResults = await multicall.aggregate3(stakeCalls);
        const stakes = stakeResults
          .filter(result => result.success)
          .map(result => {
            const decoded = stakingContract.interface.decodeFunctionResult('stakes', result.returnData);
            return decoded;
          });

        // Cargar cada token
        for (let i = 0; i < tokenIds.length; i++) {
          try {
            const tokenId = tokenIds[i];
            const stakeResult = stakes[i];
            const isStaked = stakeResult && stakeResult[0] ? stakeResult[0].gt(0) : false;
            
            // Buscar la información del token en el JSON
            const tokenInfo = jsonCollection.find(item => item.id === tokenId.toString());
            let imgUrl;
            if (tokenInfo?.image) {
              imgUrl = tokenInfo.image;
            } else {
              const baseUrl = tokenId.lt(501) 
                ? 'https://ipfs.io/ipfs/bafybeibfywb3emvjod5owcus7nyn4fqosqrbvuq2cyxczhbmavfxuautsy/'
                : 'https://ipfs.io/ipfs/bafybeie4fatiqdy4mreadt6hmqysrtev6xe37esml2llsupb6ub4qilnta/';
              // Verificar si el token es uno de los que usa .gif
              const gifTokens = [1, 13, 69, 221];
              const extension = gifTokens.includes(tokenId.toNumber()) ? '.gif' : '.png';
              imgUrl = `${baseUrl}${tokenId}${extension}`;
            }
            
            const tokenCard = document.createElement("div");
            tokenCard.className = "col";
            tokenCard.innerHTML = `
              <div class="card h-100 token-card ${isStaked ? 'staked' : ''}" data-token-id="${tokenId}">
                <img src="${imgUrl}" alt="Token ${tokenId}">
                <div class="card-body">
                  <h5 class="card-title">Token #${tokenId}</h5>
                  <p class="card-text">Status: ${isStaked ? 'Staked' : 'Not Staked'}</p>
                </div>
              </div>
            `;
            tokensGrid.appendChild(tokenCard);
            allMyTokenIds.push(tokenId); // Agregar el ID a la lista global

            // Agregar event listener para selección múltiple
            const card = tokenCard.querySelector('.token-card');
            card.addEventListener('click', () => {
              handleTokenClick(tokenId, card);
            });
          } catch (tokenError) {
            console.error(`Error loading token ${i}:`, tokenError);
            continue;
          }
        }
      } catch (error) {
        console.error("Error loading tokens:", error);
        document.getElementById("tokens-grid").innerHTML = 
          `<p class="text-danger">Error loading tokens: ${error.message}</p>`;
      }
    }

    // Display aggregate rewards
    async function displayAggregateRewards() {
      if (!stakingContract || !signer) {
        document.getElementById('total-rewards').textContent = "0 $ADRIAN";
        return;
      }
      
      try {
        const walletAddress = await signer.getAddress();
        if (!allMyTokenIds || allMyTokenIds.length === 0) {
          document.getElementById('total-rewards').textContent = "0 $ADRIAN";
          return;
        }

        // Usar Multicall para obtener los rewards de todos los tokens
        const multicall = new ethers.Contract(
          "0xcA11bde05977b3631167028862bE2a173976CA11",
          [
            "function aggregate3(tuple(address target, bool allowFailure, bytes callData)[] calls) public view returns (tuple(bool success, bytes returnData)[] returnData)"
          ],
          baseProvider
        );

        // Preparar llamadas para obtener los rewards de cada token
        const calls = allMyTokenIds.map(tokenId => ({
          target: STAKING_ADDRESS,
          allowFailure: true,
          callData: stakingContract.interface.encodeFunctionData('pendingTotalReward', [tokenId])
        }));

        // Ejecutar todas las llamadas en una sola transacción
        const results = await multicall.aggregate3(calls);
        const rewards = results
          .filter(result => result.success)
          .map(result => {
            const decoded = stakingContract.interface.decodeFunctionResult('pendingTotalReward', result.returnData);
            return decoded[0];
          });

        // Sumar todos los rewards
        const total = rewards.reduce((acc, reward) => acc.add(reward), ethers.BigNumber.from(0));

        const rewardsElement = document.getElementById('total-rewards');
        rewardsElement.textContent = formatAmount(total);
        rewardsElement.classList.add('rewards-update');
        setTimeout(() => rewardsElement.classList.remove('rewards-update'), 500);
      } catch (err) {
        console.error("Error fetching wallet stats:", err);
        document.getElementById('total-rewards').textContent = "Error loading rewards";
      }
    }

    // Display token statistics
    async function displayTokenStats() {
      const out = document.getElementById('individual-token-stats');

      if (selectedTokenIds.length === 0) {
        out.textContent = 'Select one or more tokens to view detailed statistics.';
        return;
      }

      try {
        let html = '<div class="token-stats-container">';
        selectedTokenIds.sort((a, b) => Number(a) - Number(b));

        // Obtener todos los stakes de una vez
        const stakesPromises = selectedTokenIds.map(tokenId => 
          stakingContract.stakes(tokenId).catch(() => [ethers.BigNumber.from(0), ethers.BigNumber.from(0)])
        );
        const stakes = await Promise.all(stakesPromises);

        // Obtener todos los pending rewards de una vez
        const rewardsPromises = selectedTokenIds.map(tokenId => 
          stakingContract.pendingPassiveReward(tokenId).catch(() => ethers.BigNumber.from(0))
        );
        const pendingRewards = await Promise.all(rewardsPromises);

        for (let i = 0; i < selectedTokenIds.length; i++) {
          const tokenId = selectedTokenIds[i];
          const [stakeStart, lastClaim] = stakes[i];
          const pendingReward = pendingRewards[i];
          const isStaked = stakeStart.gt(0);
          const stakingHrs = isStaked
            ? Math.floor((Date.now()/1000 - stakeStart.toNumber()) / 3600)
            : 0;

          html += `
            <div class="token-stats-item">
              <h3>Token #${tokenId}</h3>
              <p>Status: ${isStaked ? 'Staked' : 'Not Staked'}</p>
              ${isStaked ? `
                <p>Staking Duration: ${stakingHrs} hours</p>
                <p>Last Claim: ${new Date(lastClaim.toNumber()*1000).toLocaleString()}</p>
                <p>Pending Rewards: ${pendingReward.toNumber()} $ADRIAN</p>
              ` : ''}
            </div>`;
        }

        out.innerHTML = html + '</div>';
      } catch (err) {
        console.error("Error fetching token stats:", err);
        out.innerHTML = `<div class="token-stats-item">
                           <h3>Error</h3>
                           <p style="color:var(--accent-red);">Error loading stats. Please try again later.</p>
                         </div>`;
      }
    }

    // Stake tokens in batch
    document.getElementById('stake-token').addEventListener('click', async () => {
      if (selectedTokenIds.length === 0) return alert('Please select tokens to stake.');
      try {
        const walletAddress = await signer.getAddress();
        const activationFee = await stakingContract.activationFee();
        const totalFee = activationFee.mul(selectedTokenIds.length);
        const allowance = await tokenContract.allowance(walletAddress, STAKING_ADDRESS);
        if (allowance.lt(totalFee)) {
          document.getElementById('general-output').textContent = 'Approving spending...';
          const tx = await tokenContract.connect(signer).approve(STAKING_ADDRESS, totalFee);
          await tx.wait();
        }

        // Stake usando el provider de Infura
        const stakingContractWithInfura = new ethers.Contract(
          STAKING_ADDRESS,
          stakingABI,
          new ethers.providers.JsonRpcProvider("https://base-mainnet.infura.io/v3/cc0c8013b1e044dcba79d4f7ec3b2ba1", {
            name: "base",
            chainId: 8453
          })
        ).connect(signer);

        const txStake = await stakingContractWithInfura.batchStake(selectedTokenIds);
        await txStake.wait();
        document.getElementById('general-output').textContent = 'Staked: ' + selectedTokenIds.join(', ');
        loadTokens(walletAddress);
        displayAggregateRewards();
          } catch (e) {
        let errorMessage = 'Error staking: ';
        if (e.code === 'CALL_EXCEPTION' || e.code === 'UNPREDICTABLE_GAS_LIMIT') {
          // Verificar si los tokens ya están staked
          const stakesPromises = selectedTokenIds.map(tokenId => 
            stakingContract.stakes(tokenId).then(res => res[0].gt(0))
          );
          const stakes = await Promise.all(stakesPromises);
          if (stakes.some(isStaked => isStaked) || e.message.includes('staked')) {
            errorMessage = 'Oops! Some of these tokens are already staked! 🎮';
          } else if (e.message.includes('429')) {
            errorMessage = 'Too many requests! Let\'s take a short break and try again in a moment! ⏳';
          } else {
            errorMessage = 'Something went wrong! Please try again later! 🎮';
          }
        } else {
          errorMessage = 'Error staking: ' + e.message;
        }
        document.getElementById('general-output').textContent = errorMessage;
      }
    });

    async function connectWallet() {
      try {
        if (!window.ethereum) {
          document.getElementById("wallet-info").innerText = "Please install MetaMask.";
          return;
        }
        // Configurar el provider de MetaMask
        const web3Provider = new ethers.providers.Web3Provider(window.ethereum);
        // Configurar el provider de Base para consultas usando Infura
        const etherscanProvider = new ethers.providers.JsonRpcProvider("https://base-mainnet.infura.io/v3/cc0c8013b1e044dcba79d4f7ec3b2ba1", {
          name: "base",
          chainId: 8453
        });
        // Usar el provider de MetaMask para transacciones
        provider = web3Provider;
        await provider.send("eth_requestAccounts", []);
        signer = provider.getSigner();
        const walletAddress = await signer.getAddress();
        const shortAddress = walletAddress.substring(0,6) + "..." + walletAddress.substring(walletAddress.length - 4);
        document.getElementById("wallet-info").innerHTML = `<p class="wallet-address">Connected: ${shortAddress}</p>`;
        // Inicializar contratos de solo lectura con Infura
        nftContract     = new ethers.Contract(AD_PUNKS_ADDRESS, nftABI,     baseProvider);
        tokenContract   = new ethers.Contract(AD_TOKEN_ADDRESS, erc20ABI,   baseProvider);
        stakingContract = new ethers.Contract(STAKING_ADDRESS,  stakingABI, baseProvider);

        // Conectar stakingContract con el signer para transacciones
        stakingContract = stakingContract.connect(signer); // ETH write via MetaMask

        // Obtener decimales del token una sola vez
        tokenDecimals = await tokenContract.decimals();

        // Conectar los contratos con el signer para transacciones
        tokenContract = tokenContract.connect(signer);

        document.getElementById("connect-wallet").disabled = true;
        document.getElementById("stake-actions").style.display = "block";
        document.getElementById("tokens-section").style.display = "block";
        document.getElementById("total-rewards-section").style.display = "block";
        
        // Cargar tokens y actualizar rewards
        await loadTokens(walletAddress);
        await displayAggregateRewards();
        
        // Configurar actualización periódica de rewards
        if (rewardsUpdateInterval) {
          clearInterval(rewardsUpdateInterval);
        }
        rewardsUpdateInterval = setInterval(displayAggregateRewards, 30000); // Actualizar cada 30 segundos
      } catch (error) {
        console.error("Error connecting wallet:", error);
        document.getElementById("wallet-info").innerText = "Error connecting wallet: " + error.message;
      }
    }

    // Event Listeners
    document.getElementById('connect-wallet').addEventListener('click', connectWallet);
    document.getElementById('unstake-token').addEventListener('click', async () => {
      if (selectedTokenIds.length === 0) {
        alert('Please select token(s) first');
        return;
      }

      const out = document.getElementById('general-output');
      try {
        const wallet = await signer.getAddress();

        // Calcular los fees necesarios
        const [exitFee, claimFee] = await Promise.all([
          stakingContract.exitFee(),
          stakingContract.claimFee()
        ]);

        // Calcular el total de fees por token (2*exitFee + claimFee)
        const perToken = exitFee.mul(2).add(claimFee);
        const totalFee = perToken.mul(selectedTokenIds.length);

        // Comprobar / aprobar allowance
        const allowance = await tokenContract.allowance(wallet, STAKING_ADDRESS);
        if (allowance.lt(totalFee)) {
          out.textContent = 'Approving fees…';
          const txA = await tokenContract
                       .connect(signer)
                       .approve(STAKING_ADDRESS, totalFee);
          await txA.wait();
          
          // Verificar que la aprobación se haya completado
          const newAllowance = await tokenContract.allowance(wallet, STAKING_ADDRESS);
          if (newAllowance.lt(totalFee)) {
            throw new Error('Approval failed or insufficient allowance');
          }
        }

        // Des-stake usando el provider de Infura
        out.textContent = 'Unstaking…';
        const stakingContractWithInfura = new ethers.Contract(
          STAKING_ADDRESS,
          stakingABI,
          new ethers.providers.JsonRpcProvider("https://base-mainnet.infura.io/v3/cc0c8013b1e044dcba79d4f7ec3b2ba1", {
            name: "base",
            chainId: 8453
          })
        ).connect(signer);
        
        const tx = await stakingContractWithInfura.batchUnstake(selectedTokenIds);
        await tx.wait();

        out.textContent = 'Unstaked: ' + selectedTokenIds.join(', ');
        selectedTokenIds = [];
        loadTokens(wallet);
        displayAggregateRewards();
      } catch (err) {
        let errorMessage = 'Error unstaking: ';
        if (err.code === 'CALL_EXCEPTION' || err.code === 'UNPREDICTABLE_GAS_LIMIT') {
          if (err.message.includes('not staked')) {
            errorMessage = "Oops! Some of these tokens aren't staked! 🎮";
          } else if (err.message.includes('allowance') || err.message.includes('Approval failed')) {
            errorMessage = "Oops! We need to approve the fees first! Please try again! 🎮";
          } else if (err.message.includes('429')) {
            errorMessage = "Too many requests! Let's take a short break and try again in a moment! ⏳";
          } else {
            errorMessage = "Something went wrong! Please try again later! 🎮";
        }
      } else {
          errorMessage += err.message;
        }
        out.textContent = errorMessage;
        console.error(err);
      }
    });
    document.getElementById('claim-token').addEventListener('click', async () => {
      if (selectedTokenIds.length === 0) {
        alert('Please select token(s) first');
        return;
      }

      const general_output = document.getElementById('general-output');
      try {
        const wallet = await signer.getAddress();
        const claimFee = await stakingContract.claimFee();
        const totalFee = claimFee.mul(selectedTokenIds.length);
        const allowance = await tokenContract.allowance(wallet, STAKING_ADDRESS);

        if (allowance.lt(totalFee)) {
          general_output.textContent = 'Approving claim fee…';
          const txA = await tokenContract.connect(signer).approve(STAKING_ADDRESS, totalFee.mul(2));
          await txA.wait();
        }

        general_output.textContent = 'Claiming rewards…';
        const tx = await stakingContract.connect(signer).batchClaimRewards(selectedTokenIds);
        await tx.wait();

        general_output.textContent = 'Rewards claimed for tokens: ' + selectedTokenIds.join(', ');
        displayAggregateRewards();
      } catch (err) {
        general_output.textContent = 'Error claiming rewards: ' + err.message;
        console.error(err);
      }
    });
    document.getElementById('refresh-info').addEventListener('click', async () => {
      try {
        const address = await signer.getAddress();
        await loadTokens(address);
        displayAggregateRewards();
      } catch (error) {
        console.error("Error refreshing tokens:", error);
        document.getElementById("tokens-grid").innerHTML = 
          `<p class="text-danger">Error refreshing tokens: ${error.message}</p>`;
      }
    });

    // Handle token click
    async function handleTokenClick(tokenId, card) {
      try {
        // Toggle selection
        if (card.classList.contains('selected')) {
          card.classList.remove('selected');
          selectedTokenIds = selectedTokenIds.filter(id => !id.eq(tokenId));
          // Eliminar la información cuando se deselecciona
          const statsDiv = card.querySelector('.token-stats');
          if (statsDiv) {
            statsDiv.remove();
          }
        } else {
          card.classList.add('selected');
          selectedTokenIds.push(tokenId);

          // Obtener la información del token
          const tokenStats = await stakingContract.getTokenDetailedInfo(tokenId);
          const stakeStart = tokenStats[0].toNumber();
          const lastClaim = tokenStats[1].toNumber();
          const fastLevelBonus = tokenStats[2].toNumber();
          const itemsBonus = tokenStats[3].toNumber();
          const specialBoost = tokenStats[4].toNumber();
          const fixedAdjustment = tokenStats[5].toNumber();
          const pendingReward = Number(tokenStats[6]);

          const levelInfo = getTokenLevelInfo(stakeStart, lastClaim);
          
          const statsHtml = `
            <div class="token-stats">
              <div class="level-info">
                <h4>${levelInfo.label}</h4>
                <p>Experience: ${levelInfo.experience}</p>
                <p>${levelInfo.progress}</p>
                ${levelInfo.note ? `<p>${levelInfo.note}</p>` : ''}
              </div>
              <div class="bonuses">
                <p>Fast Level Bonus: ${fastLevelBonus}%</p>
                <p>Items Bonus: ${itemsBonus}%</p>
                <p>Special Boost: ${specialBoost}%</p>
                <p>Fixed Adjustment: ${fixedAdjustment}%</p>
              </div>
              <div class="rewards">
                <p>Total Rewards: ${pendingReward} $ADRIAN</p>
              </div>
            </div>
          `;
          
          // Añadir la información al final de la tarjeta
          const statsDiv = document.createElement('div');
          statsDiv.innerHTML = statsHtml;
          card.appendChild(statsDiv);
        }
      } catch (error) {
        console.error("Error handling token click:", error);
      }
    }
  </script>
</body>
</html>
