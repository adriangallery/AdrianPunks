<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Adrian Punks - Allowlist & Mint</title>
  <link rel="icon" href="/adrian1.ico" type="image/x-icon">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
  <style>
    body {
      background-color: #f7f7f7;
      margin: 0;
      padding: 0;
      font-family: 'VT323', monospace;
      padding-top: 60px; /* Espacio para el menú fijo */
    }
    .navbar {
      position: fixed;
      top: 0;
      width: 100%;
      z-index: 100;
      background-color: #fff;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .token-symbol {
      font-weight: bold;
      color: #333;
    }
    .navbar-nav .nav-link {
      color: #333;
      font-size: 1.1rem;
      padding: 0.5rem 1rem;
    }
    .navbar-nav .nav-link:hover {
      color: #007bff;
    }
    h1 {
      font-size: 3rem;
      margin-bottom: 1rem;
    }
    .container {
      max-width: 700px;
      margin: 20px auto;
      background: #fff;
      padding: 20px;
      border-radius: 10px;
      text-align: center;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }
    .container img {
      max-width: 100%;
      height: auto;
      border-radius: 10px;
      margin-bottom: 15px;
    }
    #status {
      margin-top: 15px;
      font-size: 14px;
      color: #333;
      word-wrap: break-word;
    }
    table {
      width: 100%;
      margin-top: 15px;
      font-size: 0.9rem;
    }
    th, td {
      padding: 8px 5px;
      text-align: center;
    }
    #connectWalletButton {
      margin: 20px 0;
      padding: 10px 20px;
      font-size: 1.1rem;
    }
    #mintButton, #maxMintButton {
      padding: 8px 15px;
      font-size: 1rem;
    }
    #totalCounter, #mintedCounter {
      font-size: 4rem;
      margin: 20px 0;
      display: none;
      line-height: 1.2;
    }
    .mint-form-container {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
      margin: 20px 0;
      padding: 0 10px;
    }
    .mint-form-container .quantity-input {
      width: 100px;
      margin: 0;
      text-align: center;
      padding: 8px;
      font-size: 1rem;
    }
    .mint-form-container .btn {
      white-space: nowrap;
      min-width: 90px;
    }
    #whitelistInfo {
      overflow-x: auto;
      margin: 20px 0;
      padding: 0 5px;
    }
    
    @media (max-width: 768px) {
      body {
        background-color: #fff;
      }
      .container {
        margin: 0;
        padding: 15px 10px;
        box-shadow: none;
      }
      h1 {
        font-size: 2.5rem;
        margin: 10px 0;
      }
      #status {
        font-size: 0.9rem;
        margin: 10px 0;
      }
      table {
        font-size: 0.8rem;
      }
      th, td {
        padding: 6px 4px;
      }
      #totalCounter, #mintedCounter {
        font-size: 2.5rem;
        margin: 15px 0;
      }
      .mint-form-container {
        flex-direction: column;
        gap: 8px;
        margin: 15px 0;
      }
      .mint-form-container .quantity-input {
        width: 80%;
        max-width: 200px;
      }
      .mint-form-container .btn {
        width: 80%;
        max-width: 200px;
        margin: 0 auto;
      }
      #connectWalletButton {
        width: 80%;
        max-width: 250px;
        margin: 15px auto;
        font-size: 1rem;
        padding: 8px 15px;
      }
      #whitelistInfo {
        margin: 15px -10px;
        padding: 0;
      }
      #whitelistInfo table {
        min-width: 500px;
      }
    }

    @media (max-width: 480px) {
      h1 {
        font-size: 2rem;
      }
      #totalCounter, #mintedCounter {
        font-size: 2rem;
      }
      table {
        font-size: 0.75rem;
      }
      .container img {
        margin-bottom: 10px;
      }
    }
  </style>
</head>
<body>
  <!-- Menú de navegación -->
  <nav class="navbar navbar-expand-lg">
    <div class="container-fluid">
      <div class="d-flex align-items-center">
        <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>
        <span class="navbar-text token-symbol ms-2">$ADRIAN</span>
      </div>
      
      <!-- Botón Connect visible solo en mobile -->
      <div class="d-flex d-lg-none align-items-center">
        <button id="connectWalletButtonMobile" class="btn btn-primary">Connect</button>
      </div>

      <div class="collapse navbar-collapse" id="navbarNav">
        <ul class="navbar-nav me-auto">
          <li class="nav-item">
            <a class="nav-link active" href="index.html">Home</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="market/market.html">Market</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="stake/stake.html">Stake</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="claim/claim.html">Claim</a>
          </li>
        </ul>
      </div>

      <!-- Botón Connect visible solo en desktop -->
      <div class="d-none d-lg-flex align-items-center ms-auto desktop-wallet-section">
        <button id="connectWalletButton" class="btn btn-primary">Connect Wallet</button>
      </div>
    </div>
  </nav>

  <div class="container">
    <h1>Adrian Punks <span style="color: red;">&#9632;</span><span style="color: blue;">&#9632;</span></h1>
    <img src="https://ipfs.io/ipfs/bafybeibfywb3emvjod5owcus7nyn4fqosqrbvuq2cyxczhbmavfxuautsy/1.gif" alt="Adrian Punks">
    <button id="connectWalletButton" class="btn btn-primary">Connect Wallet (switch to BASE)</button>
    
    <!-- Contador de mints totales -->
    <div id="mintedCounter">0 of 1000 minted</div>
    
    <!-- Formulario de mint (se muestra al conectar la wallet) -->
    <form id="mintForm" style="display: none;">
      <div class="mint-form-container">
        <input type="number" class="form-control quantity-input" id="mintQuantity" value="1" min="1">
        <button type="button" id="mintButton" class="btn btn-primary">Mint</button>
        <button type="button" id="maxMintButton" class="btn btn-secondary">Max Mint</button>
      </div>
    </form>
    
    <!-- Contador grande de allowlist (total remaining sin el public mint) -->
    <div id="totalCounter"></div>
    
    <!-- Información del allowlist -->
    <div id="whitelistInfo"></div>
    <!-- Debug de timestamps -->
    <div id="timestampDebug"></div>
    
    <div id="status"></div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
  <script>
    // Direcciones de contratos
    const adrianPunksAddress = "0x79be8acdd339c7b92918fcc3fd3875b5aaad7566";
    const adrianTokenAddress = "0x7E99075Ce287F1cF8cBCAaa6A1C7894e404fD7Ea";
    // ABI original con nombres de parámetros para que funcione allowlist info y mint
    const adrianPunksABI = [
      "function getAggregatedWhitelistInfo(address user) view returns (uint256 totalAllowed, uint256 mintedByUser, uint256 totalRemaining, uint256[] memory prices, uint256[] memory saleStarts)",
      "function salePhases(uint256) view returns (uint256 saleStart, uint256 price, uint256 allowed)",
      "function getWhitelistInfo(uint256 tier, address user) view returns (bool isWhitelisted, uint256 allowed, uint256 minted, uint256 remaining, uint256 price)",
      "function mint(uint256[] calldata tiers, uint256[] calldata amounts) external",
      "function totalMinted() view returns (uint256)",
      "function currentTokenId() view returns (uint256)"
    ];
    const erc20ABI = [
      "function approve(address spender, uint256 amount) external returns (bool)",
      "function allowance(address owner, address spender) view returns (uint256)"
    ];
    
    let provider;
    let signer;
    let userAccount;
    let adrianPunksContract;
    let adrianTokenContract;
    
    async function updateMintedCounter() {
      try {
        if (!adrianPunksContract) return;
        const totalMinted = await adrianPunksContract.totalMinted();
        document.getElementById("mintedCounter").innerText = `${totalMinted.toString()} of 1000 minted`;
      } catch (error) {
        console.error("Error updating minted counter:", error);
      }
    }
    
    // Actualizar el contador cada 30 segundos
    setInterval(updateMintedCounter, 30000);
    
    // Funciones del menú
    function isMobile() {
      return /Mobi|Android/i.test(navigator.userAgent);
    }

    function ensureEthers(callback) {
      if (typeof ethers !== 'undefined') {
        callback();
      } else {
        var script = document.createElement('script');
        script.src = 'https://cdnjs.cloudflare.com/ajax/libs/ethers/5.7.2/ethers.umd.min.js';
        script.onload = callback;
        script.onerror = function () {
          console.error('Failed to load ethers.js');
          alert('Error: Failed to load ethers.js. Please reload the page.');
        };
        document.head.appendChild(script);
      }
    }

    function handleAccountsChanged(accounts) {
      if (accounts.length === 0) {
        disconnectWallet();
      } else {
        const shortAddress = `${accounts[0].slice(0, 6)}...${accounts[0].slice(-4)}`;
        document.getElementById('connectWalletButton').innerHTML = `Connected: ${shortAddress}`;
        document.getElementById('connectWalletButtonMobile').innerHTML = shortAddress;
      }
    }

    function disconnectWallet() {
      provider = null;
      signer = null;
      userAccount = null;
      adrianPunksContract = null;
      adrianTokenContract = null;
      
      document.getElementById('connectWalletButton').innerHTML = "Connect Wallet";
      document.getElementById('connectWalletButtonMobile').innerHTML = "Connect";
      document.getElementById("mintForm").style.display = "none";
      document.getElementById("mintedCounter").style.display = "none";
      document.getElementById("totalCounter").style.display = "none";
      document.getElementById("status").innerText = "";
      
      if (window.ethereum) {
        window.ethereum.removeListener('accountsChanged', handleAccountsChanged);
      }
    }

    // Modificar la función connectWallet existente para manejar ambos botones
    async function connectWallet() {
      ensureEthers(async () => {
        try {
          if (!window.ethereum) {
            document.getElementById("status").innerText = "Please install MetaMask.";
            return;
          }

          provider = new ethers.providers.Web3Provider(window.ethereum);
          await provider.send("eth_requestAccounts", []);
          signer = provider.getSigner();
          userAccount = await signer.getAddress();
          
          // Actualizar botones con la dirección truncada
          const shortAddress = `${userAccount.slice(0, 6)}...${userAccount.slice(-4)}`;
          document.getElementById('connectWalletButton').innerHTML = `Connected: ${shortAddress}`;
          document.getElementById('connectWalletButtonMobile').innerHTML = shortAddress;
          
          document.getElementById("status").innerText = "Wallet connected: " + userAccount;
          adrianPunksContract = new ethers.Contract(adrianPunksAddress, adrianPunksABI, signer);
          adrianTokenContract = new ethers.Contract(adrianTokenAddress, erc20ABI, signer);
          
          document.getElementById("mintForm").style.display = "block";
          document.getElementById("mintedCounter").style.display = "block";
          document.getElementById("totalCounter").style.display = "block";
          
          await updateMintedCounter();
          loadWhitelistInfo();
          
          // Escuchar cambios de cuenta
          window.ethereum.on('accountsChanged', handleAccountsChanged);
          
        } catch (error) {
          console.error("Error connecting wallet:", error);
          document.getElementById("status").innerText = "Error connecting wallet: " + error.message;
        }
      });
    }

    // Verificar conexión al cargar la página
    window.addEventListener('load', () => {
      ensureEthers(async () => {
        if (window.ethereum) {
          provider = new ethers.providers.Web3Provider(window.ethereum);
          try {
            const accounts = await provider.listAccounts();
            if (accounts.length > 0) {
              await connectWallet();
            }
          } catch (error) {
            console.error("Error checking wallet connection:", error);
          }
        }
      });
    });
    
    function getTierName(i) {
      if(i === 0) return "OWNER";
      if(i === 1) return "GENESIS";
      if(i === 2) return "COLLABS";
      if(i === 3 || i === 4 || i === 5) return "LOTTERY";
      if(i === 6) return "ARTIST";
      if(i === 7) return "PUBLIC";
    }
    
    async function loadWhitelistInfo() {
      try {
        // Variables para agrupar totales
        let totalAllowedSum = ethers.BigNumber.from("0");
        let totalMintedSum = ethers.BigNumber.from("0");
        let totalRemainingSum = ethers.BigNumber.from("0");
        let publicMintAllowed = ethers.BigNumber.from("0");
        let html = `<h3>Your Allowlist Info (Stackable)</h3>`;
        html += `<table class="table table-bordered">
                  <thead>
                    <tr>
                      <th>Tier</th>
                      <th>Sale Start</th>
                      <th>Price (ADRIAN)</th>
                      <th>Allowed</th>
                      <th>Tier Type</th>
                    </tr>
                  </thead>
                  <tbody>`;
        let debugInfo = "";
        const currentTimestamp = Math.floor(Date.now() / 1000);
        debugInfo += `<p>Current Timestamp: ${currentTimestamp}</p>`;
        
        for (let i = 0; i < 8; i++) {
          const phase = await adrianPunksContract.salePhases(i);
          const saleStartTimestamp = phase.saleStart.toNumber();
          const saleStartDate = new Date(saleStartTimestamp * 1000).toLocaleString();
          const priceFormatted = ethers.utils.formatUnits(phase.price, 18);
          
          const walletInfo = await adrianPunksContract.getWhitelistInfo(i, userAccount);
          let allowedForWallet = walletInfo.isWhitelisted ? walletInfo.allowed : ethers.BigNumber.from("0");
          let mintedForWallet = walletInfo.isWhitelisted ? walletInfo.minted : ethers.BigNumber.from("0");
          let remainingForWallet = walletInfo.isWhitelisted ? walletInfo.remaining : ethers.BigNumber.from("0");
          
          if (walletInfo.isWhitelisted) {
            totalAllowedSum = totalAllowedSum.add(walletInfo.allowed);
            totalMintedSum = totalMintedSum.add(walletInfo.minted);
            totalRemainingSum = totalRemainingSum.add(walletInfo.remaining);
            if(i === 7) {
              publicMintAllowed = walletInfo.allowed;
            }
          }
          
          const tierType = (i < 7) ? "Allowlist" : "Public Mint";
          html += `<tr>
                    <td>${getTierName(i)}</td>
                    <td>${saleStartDate}</td>
                    <td>${priceFormatted}</td>
                    <td>${allowedForWallet.toString()}</td>
                    <td>${tierType}</td>
                  </tr>`;
          debugInfo += `<p>Tier ${i} (${getTierName(i)}): saleStart = ${saleStartTimestamp} (current: ${currentTimestamp})</p>`;
        }
        html += `</tbody></table>`;
        let totalsHtml = `<p>Total Allowed: ${totalAllowedSum.toString()} | Already Minted: ${totalMintedSum.toString()} | Remaining: ${totalRemainingSum.toString()}</p>`;
        document.getElementById("whitelistInfo").innerHTML = totalsHtml + html;
        document.getElementById("timestampDebug").innerHTML = debugInfo;
        const displayRemaining = totalRemainingSum.sub(publicMintAllowed);
        document.getElementById("totalCounter").innerText = displayRemaining.toString();
      } catch (error) {
        console.error("Error loading allowlist info:", error);
        document.getElementById("whitelistInfo").innerText = "Error loading allowlist info.";
      }
    }
    
    async function mintTokens() {
      const statusDiv = document.getElementById("status");
      const desiredQuantity = parseInt(document.getElementById("mintQuantity").value);
      if (desiredQuantity <= 0) {
        statusDiv.innerText = "Please enter a valid mint quantity.";
        return;
      }
      try {
        let tiers = [];
        let amounts = [];
        let remainingToMint = desiredQuantity;
        
        // Iterar por los 8 tiers
        for (let i = 0; i < 8 && remainingToMint > 0; i++) {
          const info = await adrianPunksContract.getWhitelistInfo(i, userAccount);
          let available = 0;
          if (i < 7) {
            if (info.isWhitelisted) {
              available = parseInt(info.remaining.toString());
            }
          } else {
            available = parseInt(info.remaining.toString());
          }
          if (available > 0) {
            const mintThisTier = Math.min(remainingToMint, available);
            tiers.push(i);
            amounts.push(mintThisTier);
            remainingToMint -= mintThisTier;
          }
        }
        if (remainingToMint > 0) {
          statusDiv.innerText = "Mint quantity exceeds allowed amount in your allowlist.";
          return;
        }
        
        let totalCost = ethers.BigNumber.from("0");
        for (let j = 0; j < tiers.length; j++) {
          const phase = await adrianPunksContract.salePhases(tiers[j]);
          totalCost = totalCost.add(phase.price.mul(amounts[j]));
        }
        
        statusDiv.innerText = "Checking token allowance...";
        const allowance = await adrianTokenContract.allowance(userAccount, adrianPunksAddress);
        if (allowance.lt(totalCost)) {
          statusDiv.innerText = "Approving tokens for minting...";
          const approveTx = await adrianTokenContract.approve(adrianPunksAddress, totalCost);
          await approveTx.wait();
        }
        
        statusDiv.innerText = "Sending mint transaction...";
        const mintTx = await adrianPunksContract.mint(tiers, amounts);
        statusDiv.innerText = "Transaction sent. Waiting for confirmation...";
        await mintTx.wait();
        statusDiv.innerText = "Mint successful!";
        loadWhitelistInfo();
        updateMintedCounter();
      } catch (error) {
        console.error("Error during mint:", error);
        statusDiv.innerText = "Error: " + (error.data?.message || error.message);
      }
    }
    
    async function maxMintTokens() {
      const statusDiv = document.getElementById("status");
      try {
        let tiers = [];
        let amounts = [];
        const currentTimestamp = Math.floor(Date.now() / 1000);
        for (let i = 0; i < 8; i++) {
          const phase = await adrianPunksContract.salePhases(i);
          const saleStartTimestamp = phase.saleStart.toNumber();
          if (currentTimestamp >= saleStartTimestamp) {
            const info = await adrianPunksContract.getWhitelistInfo(i, userAccount);
            let available = 0;
            if (i < 7) {
              if (info.isWhitelisted) {
                available = parseInt(info.remaining.toString());
              }
            } else {
              available = parseInt(info.remaining.toString());
            }
            if (available > 0) {
              tiers.push(i);
              amounts.push(available);
            }
          }
        }
        if (tiers.length === 0) {
          statusDiv.innerText = "No available mints at this time (sale not open or no allowlist available).";
          return;
        }
        
        let totalCost = ethers.BigNumber.from("0");
        for (let j = 0; j < tiers.length; j++) {
          const phase = await adrianPunksContract.salePhases(tiers[j]);
          totalCost = totalCost.add(phase.price.mul(amounts[j]));
        }
        
        statusDiv.innerText = "Checking token allowance for max mint...";
        const allowance = await adrianTokenContract.allowance(userAccount, adrianPunksAddress);
        if (allowance.lt(totalCost)) {
          statusDiv.innerText = "Approving tokens for max minting...";
          const approveTx = await adrianTokenContract.approve(adrianPunksAddress, totalCost);
          await approveTx.wait();
        }
        
        statusDiv.innerText = "Sending max mint transaction...";
        const mintTx = await adrianPunksContract.mint(tiers, amounts);
        statusDiv.innerText = "Transaction sent. Waiting for confirmation...";
        await mintTx.wait();
        statusDiv.innerText = "Max Mint successful!";
        loadWhitelistInfo();
        updateMintedCounter();
      } catch (error) {
        console.error("Error during max mint:", error);
        statusDiv.innerText = "Error: " + (error.data?.message || error.message);
      }
    }
    
    document.getElementById("connectWalletButton").addEventListener("click", connectWallet);
    document.getElementById("mintButton").addEventListener("click", mintTokens);
    document.getElementById("maxMintButton").addEventListener("click", maxMintTokens);
  </script>
</body>
</html>