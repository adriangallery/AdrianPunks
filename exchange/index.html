<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>AdrianPunks Exchange</title>
  <!-- Bootstrap 5 CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet" />
  <!-- Add Space Grotesk font -->
  <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <style>
    /* PunkQuest inspired visual styles */
    :root {
      --bg-color: #f8f9fa;
      --primary-text: #2c3e50;
      --accent-red: #ff6b6b;
      --accent-blue: #4dabf7;
      --card-bg: #ffffff;
      --card-border: #e9ecef;
      --screen-bg: #ffffff;
      --scanline-color: rgba(0,0,0,0.03);
      --pixel-shadow: -1px -1px 0 var(--accent-red), 1px 1px 0 var(--accent-blue);
      --menu-bg: #1c1c1c;
      --menu-hover: #2d2d2d;
      --menu-border: #333333;
      --wallet-btn: #ff6b2b;
      --wallet-btn-hover: #ff8142;
      --navbar-height: 60px;
      --success-color: #28a745;
      --warning-color: #ffc107;
      --error-color: #dc3545;
    }
    body {
      background-color: var(--bg-color);
      color: var(--primary-text);
      font-family: 'Space Grotesk', sans-serif;
      margin: 0;
      padding: 20px;
      line-height: 1.6;
      background-image: repeating-linear-gradient(0deg, var(--scanline-color), var(--scanline-color) 1px, transparent 1px, transparent 4px);
      padding-top: calc(var(--navbar-height) + 20px);
    }
    .container {
      max-width: 1200px;
      margin: auto;
      padding: 0;
      background: var(--screen-bg);
      border: 1px solid var(--card-border);
      box-shadow: 0 0 0 1px var(--accent-red), 0 0 0 2px var(--accent-blue), 0 4px 6px rgba(0,0,0,0.1);
      border-radius: 8px;
    }
    header {
      text-align: center;
      padding: 2rem;
      background: linear-gradient(180deg, var(--card-bg) 0%, var(--screen-bg) 100%);
      border-bottom: 1px solid var(--card-border);
      margin-bottom: 2rem;
      position: relative;
    }
    header h1 {
      font-size: 2.5rem;
      margin: 0;
      color: var(--primary-text);
      font-weight: 600;
      letter-spacing: 1px;
    }
    header p {
      margin-top: 1rem;
      font-size: 1rem;
      color: var(--primary-text);
      opacity: 0.8;
    }
    .card {
      background: var(--card-bg);
      border: 1px solid var(--card-border);
      border-radius: 8px;
      padding: 1rem;
      margin-bottom: 1.5rem;
      box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    }
    .section-title {
      font-size: 1.4rem;
      margin-bottom: 1.5rem;
      color: var(--primary-text);
      font-weight: 600;
      border-bottom: 2px solid var(--card-border);
      padding-bottom: 0.5rem;
    }
    .token-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
      gap: 1rem;
      padding: 0;
      margin: 0;
    }
    .token-card {
      background: var(--card-bg);
      border: 1px solid var(--card-border);
      border-radius: 8px;
      padding: 0.3rem;
      cursor: pointer;
      transition: all 0.2s ease;
      min-height: 200px;
      display: flex;
      flex-direction: column;
    }
    .token-card:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 8px rgba(0,0,0,0.1);
    }
    .token-card.selected {
      border: 2px solid var(--accent-blue);
      box-shadow: 0 0 8px rgba(77, 171, 247, 0.5);
    }
    .token-card img {
      width: 100%;
      height: auto;
      object-fit: contain;
      border-radius: 4px;
      flex-grow: 1;
    }
    .token-card .card-body {
      padding: 0.5rem;
    }
    .btn {
      font-family: 'Space Grotesk', sans-serif;
      font-size: 0.8rem;
      padding: 0.8rem 1.2rem;
      background: var(--card-bg);
      border: 2px solid var(--primary-text);
      color: var(--primary-text);
      text-transform: uppercase;
      cursor: pointer;
      transition: all 0.2s ease;
      margin: 0.5rem;
      box-shadow: 3px 3px 0 var(--primary-text);
    }
    .btn:hover {
      transform: translate(-2px, -2px);
      box-shadow: 5px 5px 0 var(--primary-text);
      border-color: var(--accent-blue);
    }
    .btn:active {
      transform: translate(2px, 2px);
      box-shadow: none;
      border-color: var(--accent-red);
    }
    .terminal {
      background: var(--card-bg);
      color: var(--primary-text);
      padding: 1rem;
      font-family: 'Space Mono', monospace;
      font-size: 0.9rem;
      border: 1px solid var(--card-border);
      border-radius: 8px;
      margin: 1rem 0;
      box-shadow: inset 0 1px 3px rgba(0,0,0,0.1);
      max-height: 200px;
      overflow-y: auto;
    }
    .wallet-address {
      font-family: 'Space Grotesk', sans-serif;
      font-size: 1rem;
      color: #000000;
      opacity: 0.8;
      margin: 0;
      padding: 0.5rem 0;
    }
    /* Navbar Styles */
    .navbar {
      position: fixed;
      width: 100%;
      z-index: 1000;
      top: 0;
      left: 0;
      margin: 0;
      padding: 0;
      background-color: var(--menu-bg) !important;
      border-bottom: 1px solid var(--menu-border);
      height: var(--navbar-height);
    }
    .navbar .container-fluid {
      padding: 0 15px;
      height: 100%;
      display: flex;
      align-items: center;
    }
    .navbar-collapse {
      flex-grow: 0;
    }
    .desktop-wallet-section {
      margin-left: 20px;
      position: absolute;
      right: 15px;
      top: 50%;
      transform: translateY(-50%);
    }
    .navbar-toggler {
      margin: 0;
      border: 1px solid var(--menu-border) !important;
      padding: 6px 10px;
    }
    .navbar-toggler-icon {
      filter: invert(100%) !important;
    }
    .nav-link {
      font-family: 'Space Grotesk', sans-serif;
      padding: 15px 20px !important;
      color: #fff !important;
      text-transform: uppercase;
      letter-spacing: 1px;
      transition: all 0.3s ease !important;
    }
    .nav-link:hover {
      background-color: var(--menu-hover);
      text-shadow: 0 0 5px rgba(255,255,255,0.5);
    }
    #connectWalletButton {
      background-color: var(--wallet-btn);
      color: #fff;
      border: none;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 1px;
      transition: all 0.3s ease;
      white-space: nowrap;
      display: flex;
      align-items: center;
      padding: 8px 16px;
      height: 36px;
    }
    #connectWalletButton:hover {
      background-color: var(--wallet-btn-hover);
      transform: translateY(-2px);
      box-shadow: 0 0 10px rgba(255,107,43,0.3);
    }
    
    /* Tabs */
    .tab-content {
      padding: 20px;
    }
    .nav-tabs .nav-link {
      color: var(--primary-text) !important;
      border: 1px solid transparent;
      margin-right: 5px;
      padding: 10px 15px !important;
      border-radius: 8px 8px 0 0;
      background: rgba(233, 236, 239, 0.5);
    }
    .nav-tabs .nav-link.active {
      background: var(--card-bg);
      border-bottom-color: var(--card-bg);
      font-weight: bold;
    }
    
    /* Modal styles */
    .modal-content {
      background: var(--card-bg);
      border: 1px solid var(--card-border);
      border-radius: 8px;
    }
    .modal-header {
      border-bottom: 1px solid var(--card-border);
    }
    .modal-footer {
      border-top: 1px solid var(--card-border);
    }
    
    /* Offer cards */
    .offer-card {
      background: var(--card-bg);
      border: 1px solid var(--card-border);
      border-radius: 8px;
      padding: 1rem;
      margin-bottom: 1rem;
      transition: all 0.2s ease;
    }
    .offer-card:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 8px rgba(0,0,0,0.1);
    }
    .offer-tokens {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      margin: 1rem 0;
    }
    .offer-token {
      width: 60px;
      height: 60px;
      border-radius: 4px;
      border: 1px solid var(--card-border);
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(233, 236, 239, 0.5);
      font-weight: bold;
      position: relative;
    }
    .offer-token img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      border-radius: 4px;
    }
    .offer-info {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-top: 1rem;
      font-size: 0.9rem;
    }
    .badge {
      padding: 0.35rem 0.65rem;
      font-size: 0.75rem;
    }

    /* Form styles */
    .form-label {
      font-weight: 600;
      color: var(--primary-text);
    }
    .form-control {
      border: 1px solid var(--card-border);
      border-radius: 4px;
      padding: 0.5rem;
    }
    .form-control:focus {
      border-color: var(--accent-blue);
      box-shadow: 0 0 0 0.2rem rgba(77, 171, 247, 0.25);
    }
    
    /* Loading spinner */
    .spinner {
      width: 40px;
      height: 40px;
      border: 4px solid rgba(0, 0, 0, 0.1);
      border-radius: 50%;
      border-top-color: var(--accent-blue);
      animation: spin 1s ease-in-out infinite;
      margin: 0 auto;
    }
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    
    /* Status messages */
    .status {
      padding: 1rem;
      border-radius: 8px;
      margin: 1rem 0;
      font-weight: 500;
    }
    .status.success {
      background-color: rgba(40, 167, 69, 0.1);
      border: 1px solid rgba(40, 167, 69, 0.2);
      color: var(--success-color);
    }
    .status.warning {
      background-color: rgba(255, 193, 7, 0.1);
      border: 1px solid rgba(255, 193, 7, 0.2);
      color: var(--warning-color);
    }
    .status.error {
      background-color: rgba(220, 53, 69, 0.1);
      border: 1px solid rgba(220, 53, 69, 0.2);
      color: var(--error-color);
    }
    .status.info {
      background-color: rgba(77, 171, 247, 0.1);
      border: 1px solid rgba(77, 171, 247, 0.2);
      color: var(--accent-blue);
    }
    
    /* Exchange arrows */
    .exchange-arrow {
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 2rem;
      color: var(--primary-text);
      padding: 1rem 0;
    }
    
    /* Token selection area */
    .selection-area {
      border: 2px dashed var(--card-border);
      border-radius: 8px;
      padding: 1rem;
      margin: 1rem 0;
      min-height: 100px;
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      align-content: flex-start;
    }
    .empty-selection {
      width: 100%;
      text-align: center;
      color: #6c757d;
      padding: 1rem;
    }
    
    /* Responsive adjustments */
    @media (max-width: 768px) {
      .token-grid {
        grid-template-columns: repeat(2, 1fr);
      }
      .offer-info {
        flex-direction: column;
        align-items: flex-start;
        gap: 0.5rem;
      }
      .exchange-arrow {
        transform: rotate(90deg);
        padding: 0;
      }
    }

    /* Token preview small */
    .token-preview-sm {
      width: 50px;
      height: 50px;
      border-radius: 4px;
      border: 1px solid var(--card-border);
      position: relative;
    }
    .token-preview-sm img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      border-radius: 4px;
    }
    .token-preview-sm .remove-token {
      position: absolute;
      top: -8px;
      right: -8px;
      width: 20px;
      height: 20px;
      background: var(--error-color);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-size: 12px;
      cursor: pointer;
      border: 1px solid white;
    }
    
    /* Exchange ratio styles */
    .ratio-info {
      display: flex;
      align-items: center;
      margin-top: 1rem;
      font-size: 0.9rem;
      background-color: rgba(77, 171, 247, 0.1);
      padding: 0.5rem 1rem;
      border-radius: 8px;
    }
    .ratio-box {
      display: inline-block;
      background: var(--accent-blue);
      color: white;
      padding: 0.25rem 0.5rem;
      border-radius: 4px;
      margin: 0 0.5rem;
      font-weight: bold;
    }
    .ratio-options {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      margin-top: 1rem;
    }
    .ratio-option {
      background: rgba(77, 171, 247, 0.1);
      border: 1px solid var(--accent-blue);
      border-radius: 4px;
      padding: 0.5rem 1rem;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    .ratio-option:hover, .ratio-option.selected {
      background: var(--accent-blue);
      color: white;
    }
    
    /* Fun brand style */
    .brand-logo {
      font-family: 'Space Grotesk', sans-serif;
      font-weight: 700;
      letter-spacing: 2px;
      text-transform: uppercase;
      background-image: linear-gradient(90deg, var(--accent-red), var(--accent-blue));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
      font-size: 1.5rem;
    }
  </style>
</head>
<body>
  <!-- Navbar -->
  <nav class="navbar navbar-expand-lg">
    <div class="container-fluid">
      <a class="navbar-brand" href="#">
        <span class="brand-logo">$ADRIAN</span>
      </a>
      <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
        <span class="navbar-toggler-icon"></span>
      </button>
      <div class="collapse navbar-collapse" id="navbarNav">
        <ul class="navbar-nav">
          <li class="nav-item">
            <a class="nav-link active" href="#">Exchange</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="/punkquest/">PunkQuest</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="/armory/">Armory</a>
          </li>
        </ul>
      </div>
      <div class="desktop-wallet-section">
        <button id="connectWalletButton" class="btn">Connect Wallet</button>
      </div>
    </div>
  </nav>
  <div class="container">
    <header>
      <h1>AdrianPunks Exchange</h1>
      <p>Trade your AdrianPunks NFTs with other collectors</p>
    </header>
    
    <section id="wallet-section" class="mb-4">
      <div class="card">
        <h2 class="section-title">Wallet</h2>
        <div id="wallet-info">
          <p>Please connect your wallet to use the exchange.</p>
        </div>
        <div id="token-balance" class="mt-3" style="display: none;">
          <p>ADRIAN Token Balance: <span id="adrian-balance">0</span></p>
          <p class="text-info">Exchange Fee: <span id="exchange-fee">1000</span> ADRIAN tokens per exchange</p>
        </div>
      </div>
    </section>

    <section id="main-content" style="display: none;">
      <!-- Navigation tabs -->
      <ul class="nav nav-tabs" id="exchangeTabs" role="tablist">
        <li class="nav-item" role="presentation">
          <button class="nav-link active" id="my-tokens-tab" data-bs-toggle="tab" data-bs-target="#my-tokens" type="button" role="tab">My Tokens</button>
        </li>
        <li class="nav-item" role="presentation">
          <button class="nav-link" id="create-offer-tab" data-bs-toggle="tab" data-bs-target="#create-offer" type="button" role="tab">Create Offer</button>
        </li>
        <li class="nav-item" role="presentation">
          <button class="nav-link" id="all-offers-tab" data-bs-toggle="tab" data-bs-target="#all-offers" type="button" role="tab">All Offers</button>
        </li>
        <li class="nav-item" role="presentation">
          <button class="nav-link" id="my-offers-tab" data-bs-toggle="tab" data-bs-target="#my-offers" type="button" role="tab">My Offers</button>
        </li>
        <li class="nav-item" role="presentation">
          <button class="nav-link" id="for-me-tab" data-bs-toggle="tab" data-bs-target="#for-me" type="button" role="tab">For Me</button>
        </li>
      </ul>
      
      <!-- Tab content -->
      <div class="tab-content" id="exchangeTabsContent">
        <!-- My Tokens Tab -->
        <div class="tab-pane fade show active" id="my-tokens" role="tabpanel">
          <div class="card">
            <h2 class="section-title">My AdrianPunks</h2>
            <div id="tokens-grid" class="token-grid">
              <div class="spinner"></div>
            </div>
          </div>
        </div>
        
        <!-- Create Offer Tab -->
        <div class="tab-pane fade" id="create-offer" role="tabpanel">
          <div class="card">
            <h2 class="section-title">Create Exchange Offer</h2>
            
            <div class="row mb-4">
              <div class="col-md-5">
                <h5>I Want to Offer:</h5>
                <div id="offered-tokens-area" class="selection-area">
                  <div class="empty-selection">Select tokens from your collection</div>
                </div>
              </div>
              
              <div class="col-md-2">
                <div class="exchange-arrow">
                  <i class="bi bi-arrow-right"></i> ↔ <i class="bi bi-arrow-left"></i>
                </div>
              </div>
              
              <div class="col-md-5">
                <h5>In Exchange For:</h5>
                <div class="form-group mb-3">
                  <label for="wanted-token-id" class="form-label">Enter Token IDs:</label>
                  <div class="input-group">
                    <input type="number" class="form-control" id="wanted-token-id" min="1" placeholder="Enter token ID">
                    <button class="btn" id="add-wanted-token">Add</button>
                  </div>
                  <small class="form-text text-muted">Add token IDs you want to receive</small>
                </div>
                <div id="wanted-tokens-area" class="selection-area">
                  <div class="empty-selection">Add token IDs you want to receive</div>
                </div>
              </div>
            </div>
            
            <div class="ratio-info">
              <span>Exchange Ratio:</span>
              <div class="ratio-box" id="offer-ratio">0:0</div>
              <span>Your tokens : Their tokens</span>
            </div>
            
            <div class="form-group mb-3">
              <label for="offer-duration" class="form-label">Offer Duration:</label>
              <select id="offer-duration" class="form-select">
                <option value="3600">1 Hour</option>
                <option value="86400" selected>1 Day</option>
                <option value="604800">1 Week</option>
                <option value="2592000">30 Days</option>
              </select>
            </div>
            
            <div id="create-offer-status" class="mt-3"></div>
            
            <div class="text-center mt-4">
              <button id="submit-offer" class="btn">Create Offer</button>
            </div>
          </div>
        </div>
        
        <!-- All Offers Tab -->
        <div class="tab-pane fade" id="all-offers" role="tabpanel">
          <div class="card">
            <h2 class="section-title">All Active Offers</h2>
            <div id="all-offers-container">
              <div class="spinner"></div>
            </div>
          </div>
        </div>
        
        <!-- My Offers Tab -->
        <div class="tab-pane fade" id="my-offers" role="tabpanel">
          <div class="card">
            <h2 class="section-title">My Active Offers</h2>
            <div id="my-offers-container">
              <div class="spinner"></div>
            </div>
          </div>
        </div>
        
        <!-- Offers For Me Tab -->
        <div class="tab-pane fade" id="for-me" role="tabpanel">
          <div class="card">
            <h2 class="section-title">Offers For My Tokens</h2>
            <div id="for-me-container">
              <div class="spinner"></div>
            </div>
          </div>
        </div>
      </div>
    </section>
    
    <div id="general-output" class="terminal"></div>
  </div>
  <!-- Modal for Viewing Offer Details -->
  <div class="modal fade" id="offerDetailsModal" tabindex="-1">
    <div class="modal-dialog modal-lg">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title">Offer Details</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body">
          <div id="offer-details-content"></div>
        </div>
        <div class="modal-footer">
          <button type="button" class="btn" data-bs-dismiss="modal">Close</button>
          <button type="button" class="btn" id="accept-offer-btn" style="display: none;">Accept Offer</button>
          <button type="button" class="btn" id="cancel-offer-btn" style="display: none;">Cancel Offer</button>
        </div>
      </div>
    </div>
  </div>
  
  <!-- Modal for Accepting Offer -->
  <div class="modal fade" id="acceptOfferModal" tabindex="-1">
    <div class="modal-dialog modal-lg">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title">Accept Offer</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body">
          <div id="accept-offer-content">
            <p>Select which tokens you want to exchange:</p>
            
            <div class="row mb-4">
              <div class="col-md-5">
                <h5>You will receive:</h5>
                <div id="receive-tokens-area" class="selection-area"></div>
              </div>
              
              <div class="col-md-2">
                <div class="exchange-arrow">
                  <i class="bi bi-arrow-left"></i> ↔ <i class="bi bi-arrow-right"></i>
                </div>
              </div>
              
              <div class="col-md-5">
                <h5>You will give:</h5>
                <div id="give-tokens-area" class="selection-area"></div>
              </div>
            </div>
            
            <div class="ratio-info">
              <span>Exchange Ratio:</span>
              <div class="ratio-box" id="accept-ratio">0:0</div>
              <span>Receive : Give</span>
            </div>
            
            <div class="ratio-options" id="ratio-options-container">
              <!-- This will be populated dynamically -->
            </div>
            
            <div class="alert alert-info mt-3">
              <strong>Note:</strong> A fixed fee of <span id="exchange-fee-modal">1000</span> ADRIAN tokens will be charged for this exchange.
            </div>
            
            <div id="accept-offer-status" class="mt-3"></div>
          </div>
        </div>
        <div class="modal-footer">
          <button type="button" class="btn" data-bs-dismiss="modal">Cancel</button>
          <button type="button" class="btn" id="confirm-accept-btn">Confirm Exchange</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Bootstrap 5 JS and Ethers.js Library -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
  <script>
    // Contract addresses and configurations
const NETWORK_CONF = { name: "base", chainId: 8453 };
const INFURA_URL = "https://base-mainnet.infura.io/v3/cc0c8013b1e044dcba79d4f7ec3b2ba1";
const baseProvider = new ethers.providers.JsonRpcProvider(INFURA_URL, NETWORK_CONF);

const EXCHANGE_ADDRESS = "0xe04b8db56909345c21a8ccc813286659f20ce1b4"; // Updated contract address
const ADRIANPUNKS_ADDRESS = "0x79BE8AcdD339C7b92918fcC3fd3875b5Aaad7566";
const ADRIAN_TOKEN_ADDRESS = "0x7E99075Ce287F1cF8cBCAaa6A1C7894e404fD7Ea";

// Global variables
let provider;
let signer;
let userAddress;
let tokenDecimals = 18;
let userTokens = [];
let selectedOfferedTokens = [];
let selectedWantedTokens = [];
let currentOfferId = null;
let exchangeContract;
let nftContract;
let adrianTokenContract;
let exchangeContractRead;
let nftContractRead;
let adrianTokenContractRead;
let fixedFeeAmount = ethers.utils.parseUnits("1000", 18); // 1000 ADRIAN tokens

// ABIs
const EXCHANGE_ABI = [
  "function createOffer(uint256[] calldata offeredTokens, uint256[] calldata wantedTokens, uint256 duration) external",
  "function acceptOffer(uint256 offerId, uint256[] calldata chosenOfferedTokens, uint256[] calldata chosenWantedTokens) external",
  "function cancelOffer(uint256 offerId) external",
  "function getOfferDetails(uint256 offerId) external view returns (address creator, uint256[] memory offeredTokens, uint256[] memory wantedTokens, uint256 expirationTime, bool isActive)",
  "function getActiveOffersForToken(uint256 tokenId) external view returns (uint256[] memory)",
  "function getActiveOffersByUser(address user) external view returns (uint256[] memory)",
  "function getOffersForUser(address user) external view returns (uint256[] memory)",
  "function getActiveOfferCount() external view returns (uint256)",
  "function checkApprovals(address user, uint256[] calldata tokenIds) external view returns (bool[] memory)",
  "function fixedFeeAmount() external view returns (uint256)",
  "function emergencyState() external view returns (bool)"
];

const ERC721_ABI = [
  "function balanceOf(address) view returns (uint256)",
  "function tokenOfOwnerByIndex(address,uint256) view returns (uint256)",
  "function ownerOf(uint256) view returns (address)",
  "function getApproved(uint256) view returns (address)",
  "function isApprovedForAll(address,address) view returns (bool)",
  "function setApprovalForAll(address,bool) returns ()",
  "function approve(address to, uint256 tokenId) returns ()"
];

const ERC20_ABI = [
  "function balanceOf(address) view returns (uint256)",
  "function decimals() view returns (uint8)",
  "function symbol() view returns (string)",
  "function approve(address,uint256) returns (bool)",
  "function allowance(address,address) view returns (uint256)",
  "function transfer(address,uint256) returns (bool)"
];

// Helper functions
function formatTimestamp(timestamp) {
  const date = new Date(timestamp * 1000);
  return date.toLocaleString();
}

function shortenAddress(address) {
  return address.substring(0, 6) + "..." + address.substring(address.length - 4);
}

function showStatus(elementId, message, type) {
  const statusElement = document.getElementById(elementId);
  statusElement.className = "status " + type;
  statusElement.textContent = message;
  statusElement.style.display = "block";
}

function clearStatus(elementId) {
  const statusElement = document.getElementById(elementId);
  statusElement.textContent = "";
  statusElement.style.display = "none";
}

function logToOutput(message) {
  const output = document.getElementById("general-output");
  const timestamp = new Date().toLocaleTimeString();
  output.innerHTML += `<div>[${timestamp}] ${message}</div>`;
  // Auto-scroll to bottom
  output.scrollTop = output.scrollHeight;
}

// Instancia de Multicall 3 (misma que en PunkQuest)
const multicall = new ethers.Contract(
  "0xcA11bde05977b3631167028862bE2a173976CA11",
  [
    "function aggregate3(tuple(address target,bool allowFailure,bytes callData)[] calls) view returns (tuple(bool success,bytes returnData)[] returnData)"
  ],
  baseProvider
);

// Initialize the application
document.addEventListener('DOMContentLoaded', async () => {
  // Add event listeners
  document.getElementById('connectWalletButton').addEventListener('click', connectWallet);
  document.getElementById('add-wanted-token').addEventListener('click', addWantedToken);
  document.getElementById('submit-offer').addEventListener('click', createOffer);
  document.getElementById('accept-offer-btn').addEventListener('click', showAcceptOfferModal);
  document.getElementById('cancel-offer-btn').addEventListener('click', cancelOffer);
  document.getElementById('confirm-accept-btn').addEventListener('click', acceptOffer);
  
  // Initialize with read-only providers for public data
  initReadOnlyContracts();
  
  // Global function access
  window.removeOfferedToken = removeOfferedToken;
  window.removeWantedToken = removeWantedToken;
  window.viewOfferDetails = viewOfferDetails;
  window.toggleReceiveToken = toggleReceiveToken;
  window.toggleGiveToken = toggleGiveToken;
  window.selectRatioOption = selectRatioOption;
  
  // Update ratio display when tokens are selected/deselected
  setupRatioDisplay();
  
  // Check for announcements
  checkForAnnouncements();
  
  // Show server date and time
  const today = new Date();
  const dateString = today.toLocaleDateString('en-US', { 
    weekday: 'long', 
    year: 'numeric', 
    month: 'long', 
    day: 'numeric' 
  });
  
  logToOutput(`Initializing application. Server date: ${dateString}`);
});

// Initialize contracts with read-only provider
function initReadOnlyContracts() {
  try {
    exchangeContractRead = new ethers.Contract(EXCHANGE_ADDRESS, EXCHANGE_ABI, baseProvider);
    nftContractRead = new ethers.Contract(ADRIANPUNKS_ADDRESS, ERC721_ABI, baseProvider);
    adrianTokenContractRead = new ethers.Contract(ADRIAN_TOKEN_ADDRESS, ERC20_ABI, baseProvider);
    
    // Get the fixed fee from the contract
    exchangeContractRead.fixedFeeAmount().then(fee => {
      fixedFeeAmount = fee;
      const formattedFee = ethers.utils.formatUnits(fee, tokenDecimals);
      document.getElementById("exchange-fee").textContent = formattedFee;
      document.getElementById("exchange-fee-modal").textContent = formattedFee;
    }).catch(error => {
      console.error("Error getting fixed fee:", error);
    });
    
    // Check emergency state
    checkEmergencyState();
  } catch (error) {
    console.error("Error initializing read-only contracts:", error);
    logToOutput("Error initializing contracts. Please refresh the page and try again.");
  }
}

// Update ratio display in create offer tab
function setupRatioDisplay() {
  const updateRatio = () => {
    const offeredCount = selectedOfferedTokens.length;
    const wantedCount = selectedWantedTokens.length;
    document.getElementById('offer-ratio').textContent = `${offeredCount}:${wantedCount}`;
  };
  
  // Check for changes every second
  setInterval(updateRatio, 1000);
}

// Update ratio display in accept offer modal
function updateAcceptRatio() {
  if (!window.selectedReceiveTokens || !window.selectedGiveTokens) return;
  
  const receiveCount = window.selectedReceiveTokens.length;
  const giveCount = window.selectedGiveTokens.length;
  document.getElementById('accept-ratio').textContent = `${receiveCount}:${giveCount}`;
}

// Connect Wallet
async function connectWallet() {
  try {
    if (!window.ethereum) {
      document.getElementById("wallet-info").innerHTML = '<div class="status warning">Please install MetaMask or another Web3 compatible wallet.</div>';
      return;
    }
    
    // Setup provider and signer
    provider = new ethers.providers.Web3Provider(window.ethereum);
    await provider.send("eth_requestAccounts", []);
    signer = provider.getSigner();
    userAddress = await signer.getAddress();
    
    // Check if we're on the right network (Base Mainnet)
    const network = await provider.getNetwork();
    if (network.chainId !== NETWORK_CONF.chainId) {
      document.getElementById("wallet-info").innerHTML = `<div class="status warning">Please connect to Base network (ChainID: ${NETWORK_CONF.chainId})</div>`;
      
      // Try to switch to the correct network
      try {
        await window.ethereum.request({
          method: 'wallet_switchEthereumChain',
          params: [{ chainId: '0x2105' }], // chainId is in hex format
        });
        // After switching, reconnect
        setTimeout(connectWallet, 1000);
        return;
      } catch (switchError) {
        console.error("Error switching network:", switchError);
        return;
      }
    }
    
    // Connect to contracts with signer for write operations
    exchangeContract = new ethers.Contract(EXCHANGE_ADDRESS, EXCHANGE_ABI, signer);
    nftContract = new ethers.Contract(ADRIANPUNKS_ADDRESS, ERC721_ABI, signer);
    adrianTokenContract = new ethers.Contract(ADRIAN_TOKEN_ADDRESS, ERC20_ABI, signer);
    
    // Initialize read-only contracts with Infura provider
    exchangeContractRead = new ethers.Contract(EXCHANGE_ADDRESS, EXCHANGE_ABI, baseProvider);
    nftContractRead = new ethers.Contract(ADRIANPUNKS_ADDRESS, ERC721_ABI, baseProvider);
    adrianTokenContractRead = new ethers.Contract(ADRIAN_TOKEN_ADDRESS, ERC20_ABI, baseProvider);
    
    // Get token decimals
    tokenDecimals = await adrianTokenContractRead.decimals();
    
    // Get fixed fee
    try {
      fixedFeeAmount = await exchangeContractRead.fixedFeeAmount();
      const formattedFee = ethers.utils.formatUnits(fixedFeeAmount, tokenDecimals);
      document.getElementById("exchange-fee").textContent = formattedFee;
      document.getElementById("exchange-fee-modal").textContent = formattedFee;
    } catch (error) {
      console.error("Error getting fixed fee:", error);
    }
    
    // Update UI
    const shortAddress = shortenAddress(userAddress);
    document.getElementById("wallet-info").innerHTML = `<p class="wallet-address">Connected: ${shortAddress}</p>`;
    document.getElementById("main-content").style.display = "block";
    document.getElementById("token-balance").style.display = "block";
    
    // Load data
    await loadData();
    
    // Setup tab event listeners
    document.getElementById('all-offers-tab').addEventListener('click', loadAllOffers);
    document.getElementById('my-offers-tab').addEventListener('click', loadMyOffers);
    document.getElementById('for-me-tab').addEventListener('click', loadOffersForMe);
    
    // Disable connect button
    document.getElementById('connectWalletButton').disabled = true;
    document.getElementById('connectWalletButton').textContent = 'Wallet Connected';
    
    logToOutput(`Wallet connected: ${shortAddress}`);
    
    // Listen for account changes
    window.ethereum.on('accountsChanged', (accounts) => {
      logToOutput('Account change detected. Reconnecting...');
      // Reload the page to reset the state
      window.location.reload();
    });
    
    // Listen for network changes
    window.ethereum.on('chainChanged', () => {
      logToOutput('Network change detected. Reconnecting...');
      // Reload the page to reset the state
      window.location.reload();
    });
    
  } catch (error) {
    console.error("Error connecting wallet:", error);
    document.getElementById("wallet-info").innerHTML = `<div class="status error">Error connecting wallet: ${error.message}</div>`;
  }
}

// Load all data
async function loadData() {
  try {
    // Show loading state
    document.getElementById("tokens-grid").innerHTML = '<div class="spinner"></div>';
    document.getElementById("all-offers-container").innerHTML = '<div class="spinner"></div>';
    document.getElementById("my-offers-container").innerHTML = '<div class="spinner"></div>';
    document.getElementById("for-me-container").innerHTML = '<div class="spinner"></div>';
    
    await Promise.all([
      loadUserTokens(),
      loadTokenBalance(),
      loadAllOffers(),
      loadMyOffers(),
      loadOffersForMe()
    ]);
    
    logToOutput("Datos cargados correctamente");
  } catch (error) {
    console.error("Error cargando datos:", error);
    logToOutput(`Error cargando datos: ${error.message}`);
  }
}

// Load user's token balance
async function loadTokenBalance() {
  try {
    const balance = await adrianTokenContractRead.balanceOf(userAddress);
    const formattedBalance = ethers.utils.formatUnits(balance, tokenDecimals);
    document.getElementById("adrian-balance").textContent = formattedBalance;
  } catch (error) {
    console.error("Error loading token balance:", error);
  }
}

// Create NFT image URL
function getNFTImageURL(tokenId) {
  const idNum = typeof tokenId === "string" ? parseInt(tokenId) : tokenId.toNumber();
  const base  = idNum <= 500
      ? "https://ipfs.io/ipfs/bafybeibfywb3emvjod5owcus7nyn4fqosqrbvuq2cyxczhbmavfxuautsy/"
      : "https://ipfs.io/ipfs/bafybeie4fatiqdy4mreadt6hmqysrtev6xe37esml2llsupb6ub4qilnta/";
  const gif   = [1,13,69,221].includes(idNum) ? ".gif" : ".png";
  return `${base}${idNum}${gif}`;
}

// Function to check if a wallet has enough ADRIAN tokens for fees
async function checkFeeBalance() {
  try {
    if (!userAddress) return false;
    
    const balance = await adrianTokenContractRead.balanceOf(userAddress);
    return balance.gte(fixedFeeAmount);
  } catch (error) {
    console.error("Error checking fee balance:", error);
    return false;
  }
}

// Function to check if the exchange contract is in emergency state
async function checkEmergencyState() {
  try {
    // Check if the contract has an emergencyState function
    if (typeof exchangeContractRead.emergencyState === 'function') {
      const isEmergency = await exchangeContractRead.emergencyState();
      
      if (isEmergency) {
        // Show warning across the application
        const warning = document.createElement('div');
        warning.className = 'status warning';
        warning.style.position = 'sticky';
        warning.style.top = '70px';
        warning.style.zIndex = '999';
        warning.style.margin = '0 auto 20px auto';
        warning.style.maxWidth = '1200px';
        warning.textContent = 'The contract is in emergency state. Operations are temporarily suspended.';
        
        document.body.insertBefore(warning, document.querySelector('.container'));
        return true;
      }
    }
    
    return false;
  } catch (error) {
    console.error("Error checking emergency state:", error);
    return false;
  }
}

// Function to check for contract updates or announcements
function checkForAnnouncements() {
  // This could be extended to check a centralized endpoint or contract events for announcements
  const announcements = [
    { id: 1, date: '2025-04-01', text: 'Nuevo sistema de intercambio lanzado. ¡Ahora con comisiones reducidas!', expired: true },
    { id: 2, date: '2025-04-27', text: 'Bienvenido al Exchange de AdrianPunks. Intercambia tus NFTs con seguridad y facilidad.', expired: false }
  ];
  
  // Filter active announcements
  const activeAnnouncements = announcements.filter(a => !a.expired);
  
  if (activeAnnouncements.length > 0) {
    const container = document.createElement('div');
    container.className = 'status info';
    container.style.marginBottom = '20px';
    
    activeAnnouncements.forEach(announcement => {
      const p = document.createElement('p');
      p.textContent = announcement.text;
      container.appendChild(p);
    });
    
    // Add to the DOM after the header
    const header = document.querySelector('header');
    if (header && header.parentNode) {
      header.parentNode.insertBefore(container, header.nextSibling);
    }
  }
}
// Load user's NFTs
async function loadUserTokens() {
  try {
    const grid = document.getElementById("tokens-grid");
    grid.innerHTML = '<div class="spinner"></div>';

    // 1) nº total de NFTs
    const balance = await nftContractRead.balanceOf(userAddress);
    const total   = balance.toNumber();
    if (total === 0) {
      grid.innerHTML = "<p>No tienes AdrianPunks NFTs en tu wallet.</p>";
      return;
    }

    // 2) batch calls con Multicall3
    const calls = Array.from({ length: total }, (_, i) => ({
      target      : ADRIANPUNKS_ADDRESS,
      allowFailure: true,
      callData    : nftContractRead.interface.encodeFunctionData("tokenOfOwnerByIndex", [userAddress, i])
    }));

    const results  = await multicall.aggregate3(calls);
    const tokenIds = results
      .filter(r => r.success)
      .map(r => nftContractRead.interface.decodeFunctionResult("tokenOfOwnerByIndex", r.returnData)[0]);

    userTokens = tokenIds.map(id => id.toString());

    // 3) construir el HTML de tarjetas (sin cambios visuales)
    const html = tokenIds.map(tokenId => {
      const img = getNFTImageURL(tokenId);
      return `
        <div class="token-card" data-token-id="${tokenId}">
          <img src="${img}" alt="AdrianPunk #${tokenId}" 
               onerror="this.src='https://via.placeholder.com/200x200?text=AdrianPunk+%23${tokenId}'">
          <div class="card-body">
            <h5 class="card-title">AdrianPunk #${tokenId}</h5>
          </div>
        </div>`;
    }).join("");

    grid.innerHTML = html;

    // 4) activar selección de tokens para ofertas
    document.querySelectorAll(".token-card").forEach(card => {
      card.addEventListener("click", () => selectTokenForOffer(card));
    });

  } catch (err) {
    console.error("Error loading tokens:", err);
    document.getElementById("tokens-grid").innerHTML =
      `<div class="status error">Error cargando tokens: ${err.message}</div>`;
  }
}

// Select token for offer creation
function selectTokenForOffer(card) {
  const tokenId = card.getAttribute('data-token-id');
  
  // Check if we're on the create offer tab
  if (!document.getElementById('create-offer-tab').classList.contains('active')) {
    // Switch to create offer tab
    bootstrap.Tab.getOrCreateInstance(document.getElementById('create-offer-tab')).show();
  }
  
  // Check if token is already selected
  if (selectedOfferedTokens.includes(tokenId)) {
    return;
  }
  
  // Add token to selected offered tokens
  selectedOfferedTokens.push(tokenId);
  updateOfferedTokensUI();
  
  // Highlight the selected card
  card.classList.add('selected');
}

// Update the UI for offered tokens
function updateOfferedTokensUI() {
  const container = document.getElementById('offered-tokens-area');
  
  if (selectedOfferedTokens.length === 0) {
    container.innerHTML = '<div class="empty-selection">Selecciona tokens de tu colección</div>';
    return;
  }
  
  let html = '';
  selectedOfferedTokens.forEach(tokenId => {
    const imgUrl = getNFTImageURL(tokenId);
    
    html += `
      <div class="token-preview-sm" data-token-id="${tokenId}">
        <img src="${imgUrl}" alt="Token #${tokenId}" onerror="this.src='https://via.placeholder.com/50x50?text=${tokenId}'">
        <div class="remove-token" onclick="removeOfferedToken('${tokenId}')">×</div>
      </div>`;
  });
  
  container.innerHTML = html;
}

// Remove token from offered tokens
function removeOfferedToken(tokenId) {
  selectedOfferedTokens = selectedOfferedTokens.filter(id => id !== tokenId);
  updateOfferedTokensUI();
  
  // Remove highlight from the token card
  const card = document.querySelector(`.token-card[data-token-id="${tokenId}"]`);
  if (card) {
    card.classList.remove('selected');
  }
}

// Add wanted token ID
function addWantedToken() {
  const input = document.getElementById('wanted-token-id');
  const tokenId = input.value.trim();
  
  if (!tokenId || isNaN(tokenId) || Number(tokenId) <= 0) {
    showStatus('create-offer-status', 'Please enter a valid token ID', 'warning');
    return;
  }
  
  // Check if token is already in the list
  if (selectedWantedTokens.includes(tokenId)) {
    showStatus('create-offer-status', 'This token is already in your wishlist', 'warning');
    return;
  }
  
  // Add token to wanted tokens list
  selectedWantedTokens.push(tokenId);
  updateWantedTokensUI();
  
  // Clear input
  input.value = '';
  clearStatus('create-offer-status');
}

// Update the UI for wanted tokens
function updateWantedTokensUI() {
  const container = document.getElementById('wanted-tokens-area');
  
  if (selectedWantedTokens.length === 0) {
    container.innerHTML = '<div class="empty-selection">Add token IDs you want to receive</div>';
    return;
  }
  
  let html = '';
  selectedWantedTokens.forEach(tokenId => {
    const imgUrl = getNFTImageURL(tokenId);
    
    html += `
      <div class="token-preview-sm" data-token-id="${tokenId}">
        <img src="${imgUrl}" alt="Token #${tokenId}" onerror="this.src='https://via.placeholder.com/50x50?text=${tokenId}'">
        <div class="remove-token" onclick="removeWantedToken('${tokenId}')">×</div>
      </div>`;
  });
  
  container.innerHTML = html;
}

// Remove token from wanted tokens
function removeWantedToken(tokenId) {
  selectedWantedTokens = selectedWantedTokens.filter(id => id !== tokenId);
  updateWantedTokensUI();
}

// Create new offer
async function createOffer() {
  try {
    if (selectedOfferedTokens.length === 0) {
      showStatus('create-offer-status', 'Select at least one token to offer', 'warning');
      return;
    }
    
    if (selectedWantedTokens.length === 0) {
      showStatus('create-offer-status', 'Add at least one token you want to receive', 'warning');
      return;
    }
    
    const duration = document.getElementById('offer-duration').value;
    
    // Approve NFT tokens
    showStatus('create-offer-status', 'Verifying token approvals...', 'warning');
    
    // Check if all tokens are already approved
    const approvalStatuses = await exchangeContractRead.checkApprovals(
      userAddress, 
      selectedOfferedTokens.map(id => ethers.BigNumber.from(id))
    );
    
    const needsApproval = approvalStatuses.findIndex(status => !status) !== -1;
      
      if (needsApproval) {
        // Ask user if they want to approve all at once
        const useSetApprovalForAll = selectedOfferedTokens.length > 1 && 
        confirm("¿Quieres aprobar todos tus tokens para la plataforma de intercambio? (más eficiente en gas)");
        
        if (useSetApprovalForAll) {
        showStatus('create-offer-status', 'Aprobando todos los tokens...', 'warning');
          const approveTx = await nftContract.setApprovalForAll(EXCHANGE_ADDRESS, true);
          await approveTx.wait();
        logToOutput("Aprobación de todos los tokens completada");
        } else {
          // Approve each token individually
          for (let i = 0; i < selectedOfferedTokens.length; i++) {
            const tokenId = selectedOfferedTokens[i];
          if (!approvalStatuses[i]) {
            showStatus('create-offer-status', `Aprobando token #${tokenId}...`, 'warning');
              const approveTx = await nftContract.approve(EXCHANGE_ADDRESS, tokenId);
              await approveTx.wait();
            logToOutput(`Token #${tokenId} aprobado`);
          }
        }
      }
    }
    
    // Create offer
    showStatus('create-offer-status', 'Creating offer...', 'warning');
    
    const tx = await exchangeContract.createOffer(
      selectedOfferedTokens.map(id => ethers.BigNumber.from(id)),
      selectedWantedTokens.map(id => ethers.BigNumber.from(id)),
      duration
    );
    
    logToOutput(`Transaction sent: ${tx.hash}`);
    showStatus('create-offer-status', 'Confirming transaction...', 'warning');
    
    await tx.wait();
    showStatus('create-offer-status', 'Offer created successfully!', 'success');
    logToOutput("Offer created successfully");
    
    // Clear selections
    selectedOfferedTokens = [];
    selectedWantedTokens = [];
    updateOfferedTokensUI();
    updateWantedTokensUI();
    
    // Remove selection highlights
    document.querySelectorAll('.token-card.selected').forEach(card => {
      card.classList.remove('selected');
    });
    
    // Reload offers
    await Promise.all([
      loadAllOffers(),
      loadMyOffers()
    ]);
  } catch (error) {
    console.error("Error creating offer:", error);
    showStatus('create-offer-status', `Error creating offer: ${error.message}`, 'error');
    logToOutput(`Error creating offer: ${error.message}`);
  }
}

// Load all active offers
async function loadAllOffers() {
  try {
    const container = document.getElementById('all-offers-container');
    container.innerHTML = '<div class="spinner"></div>';
    
    const totalOffers = await exchangeContractRead.getActiveOfferCount();
    
    if (totalOffers.eq(0)) {
      container.innerHTML = "<p>No active offers available.</p>";
      return;
    }
    
    container.innerHTML = `
      <div class="status info">
        <p>Total number of active offers: ${totalOffers}</p>
        <p>To see specific offers, use the "My Offers" tab for your created offers or "For Me" for offers that match your tokens.</p>
      </div>`;
  } catch (error) {
    console.error("Error loading all offers:", error);
    document.getElementById('all-offers-container').innerHTML = `<div class="status error">Error loading offers: ${error.message}</div>`;
  }
}

// Load user's active offers
async function loadMyOffers() {
  try {
    if (!userAddress) return;
    
    const container = document.getElementById('my-offers-container');
    container.innerHTML = '<div class="spinner"></div>';
    
    const offerIds = await exchangeContractRead.getActiveOffersByUser(userAddress);
    
    if (offerIds.length === 0) {
      container.innerHTML = "<p>You have no active offers.</p>";
      return;
    }
    
    let offersHtml = '';
    for (let i = 0; i < offerIds.length; i++) {
        const offerId = offerIds[i];
      const offerDetails = await exchangeContractRead.getOfferDetails(offerId);
        
        const [creator, offeredTokens, wantedTokens, expirationTime, isActive] = offerDetails;
        
      // Skip inactive offers
      if (!isActive || expirationTime.mul(1000).lt(Date.now())) continue;
        
        const expiresAt = formatTimestamp(expirationTime);
        
        // Create offer card
        offersHtml += `
          <div class="offer-card">
            <h5>Offer #${offerId}</h5>
            <div class="row">
              <div class="col-md-5">
                <p><strong>Offering:</strong></p>
                <div class="offer-tokens">
                  ${offeredTokens.map(token => `
                    <div class="offer-token">
                      <img src="${getNFTImageURL(token)}" alt="Token #${token}" onerror="this.src='https://via.placeholder.com/60x60?text=${token}'">
                    </div>
                  `).join('')}
                </div>
              </div>
              <div class="col-md-2 text-center">
                <div class="exchange-arrow">↔</div>
              </div>
              <div class="col-md-5">
                <p><strong>For:</strong></p>
                <div class="offer-tokens">
                  ${wantedTokens.map(token => `
                    <div class="offer-token">
                      <img src="${getNFTImageURL(token)}" alt="Token #${token}" onerror="this.src='https://via.placeholder.com/60x60?text=${token}'">
                    </div>
                  `).join('')}
                </div>
              </div>
            </div>
            <div class="offer-info">
              <span>Expires: ${expiresAt}</span>
              <button class="btn" onclick="viewOfferDetails(${offerId}, true)">View Details</button>
            </div>
          </div>`;
    }
    
    container.innerHTML = offersHtml || "<p>You have no active offers.</p>";
  } catch (error) {
    console.error("Error loading my offers:", error);
    document.getElementById('my-offers-container').innerHTML = `<div class="status error">Error loading your offers: ${error.message}</div>`;
  }
}

// Load offers that the user can accept
async function loadOffersForMe() {
  try {
    if (!userAddress) return;
    
    const container = document.getElementById('for-me-container');
    container.innerHTML = '<div class="spinner"></div>';
    
    const offerIds = await exchangeContractRead.getOffersForUser(userAddress);
    
    if (offerIds.length === 0) {
      container.innerHTML = "<p>No offers available for your tokens.</p>";
      return;
    }
    
    let offersHtml = '';
    for (let i = 0; i < offerIds.length; i++) {
        const offerId = offerIds[i];
      const offerDetails = await exchangeContractRead.getOfferDetails(offerId);
        
        const [creator, offeredTokens, wantedTokens, expirationTime, isActive] = offerDetails;
        
      // Skip inactive offers
      if (!isActive || expirationTime.mul(1000).lt(Date.now())) continue;
        
        const expiresAt = formatTimestamp(expirationTime);
        const creatorShort = shortenAddress(creator);
        
        // Create offer card
        offersHtml += `
          <div class="offer-card">
            <h5>Offer #${offerId} <span class="badge bg-secondary">From: ${creatorShort}</span></h5>
            <div class="row">
              <div class="col-md-5">
                <p><strong>You'll Receive:</strong></p>
                <div class="offer-tokens">
                  ${offeredTokens.map(token => `
                    <div class="offer-token">
                      <img src="${getNFTImageURL(token)}" alt="Token #${token}" onerror="this.src='https://via.placeholder.com/60x60?text=${token}'">
                    </div>
                  `).join('')}
                </div>
              </div>
              <div class="col-md-2 text-center">
                <div class="exchange-arrow">↔</div>
              </div>
              <div class="col-md-5">
              <p><strong>For your:</strong></p>
                <div class="offer-tokens">
                  ${wantedTokens.map(token => `
                    <div class="offer-token">
                      <img src="${getNFTImageURL(token)}" alt="Token #${token}" onerror="this.src='https://via.placeholder.com/60x60?text=${token}'">
                    </div>
                  `).join('')}
                </div>
              </div>
            </div>
            <div class="offer-info">
              <span>Expires: ${expiresAt}</span>
              <button class="btn" onclick="viewOfferDetails(${offerId}, false)">View Details</button>
            </div>
          </div>`;
    }
    
    container.innerHTML = offersHtml || "<p>No offers available for your tokens.</p>";
  } catch (error) {
    console.error("Error loading offers for me:", error);
    document.getElementById('for-me-container').innerHTML = `<div class="status error">Error loading offers: ${error.message}</div>`;
  }
}

// View offer details
async function viewOfferDetails(offerId, isMyOffer) {
  try {
    currentOfferId = offerId;
    
    const detailsContainer = document.getElementById('offer-details-content');
    detailsContainer.innerHTML = '<div class="spinner"></div>';
    
    const offerDetails = await exchangeContractRead.getOfferDetails(offerId);
    const [creator, offeredTokens, wantedTokens, expirationTime, isActive] = offerDetails;
    
    if (!isActive) {
      detailsContainer.innerHTML = '<div class="status warning">This offer is no longer active.</div>';
      return;
    }
    
    const expiresAt = formatTimestamp(expirationTime);
    const creatorShort = shortenAddress(creator);
    
    // Generate tokens preview
    let offeredTokensHtml = '';
    for (let i = 0; i < offeredTokens.length; i++) {
      const tokenId = offeredTokens[i];
      const imgUrl = getNFTImageURL(tokenId);
      
      offeredTokensHtml += `
        <div class="token-preview-sm" data-token-id="${tokenId}">
          <img src="${imgUrl}" alt="Token #${tokenId}" onerror="this.src='https://via.placeholder.com/50x50?text=${tokenId}'">
        </div>`;
    }
    
    let wantedTokensHtml = '';
    for (let i = 0; i < wantedTokens.length; i++) {
      const tokenId = wantedTokens[i];
      const imgUrl = getNFTImageURL(tokenId);
      
      wantedTokensHtml += `
        <div class="token-preview-sm" data-token-id="${tokenId}">
          <img src="${imgUrl}" alt="Token #${tokenId}" onerror="this.src='https://via.placeholder.com/50x50?text=${tokenId}'">
        </div>`;
    }
    
    // Build details HTML
    detailsContainer.innerHTML = `
      <div class="mb-3">
        <h5>Offer #${offerId}</h5>
        <p>Created by: ${creatorShort}</p>
        <p>Expires: ${expiresAt}</p>
      </div>
      
      <div class="row">
        <div class="col-md-5">
          <h6>${isMyOffer ? 'You are Offering:' : 'You\'ll Receive:'}</h6>
          <div class="selection-area">
            ${offeredTokensHtml || '<div class="empty-selection">No tokens</div>'}
          </div>
        </div>
        
        <div class="col-md-2">
          <div class="exchange-arrow">↔</div>
        </div>
        
        <div class="col-md-5">
          <h6>${isMyOffer ? 'In Exchange For:' : 'In Exchange For Your:'}</h6>
          <div class="selection-area">
            ${wantedTokensHtml || '<div class="empty-selection">No tokens</div>'}
          </div>
        </div>
      </div>
      
      <div class="ratio-info mt-3">
        <span>Exchange Ratio:</span>
        <div class="ratio-box">${offeredTokens.length}:${wantedTokens.length}</div>
        <span>${isMyOffer ? 'Your tokens : Their tokens' : 'Tokens to receive : Tokens to give'}</span>
      </div>
      
      <div class="alert alert-info mt-3">
        <strong>Note:</strong> Fixed fee of <span>${ethers.utils.formatUnits(fixedFeeAmount, tokenDecimals)}</span> ADRIAN tokens per exchange.
      </div>`;
    
    // Show appropriate buttons
    document.getElementById('accept-offer-btn').style.display = isMyOffer ? 'none' : 'inline-block';
    document.getElementById('cancel-offer-btn').style.display = isMyOffer ? 'inline-block' : 'none';
    
    // Show modal
    const modal = new bootstrap.Modal(document.getElementById('offerDetailsModal'));
    modal.show();
  } catch (error) {
    console.error("Error viewing offer details:", error);
    document.getElementById('offer-details-content').innerHTML = `<div class="status error">Error loading offer details: ${error.message}</div>`;
  }
}

// Show accept offer modal
async function showAcceptOfferModal() {
  try {
    if (!currentOfferId) return;
    
    // Close details modal
    bootstrap.Modal.getInstance(document.getElementById('offerDetailsModal')).hide();
    
    // Get offer details
    const offerDetails = await exchangeContractRead.getOfferDetails(currentOfferId);
    const [creator, offeredTokens, wantedTokens, expirationTime, isActive] = offerDetails;
    
    if (!isActive) {
      document.getElementById('accept-offer-status').innerHTML = '<div class="status warning">Esta oferta ya no está activa.</div>';
      return;
    }
    
    // Show tokens to receive
    let receiveHtml = '';
    for (let i = 0; i < offeredTokens.length; i++) {
      const tokenId = offeredTokens[i];
      const imgUrl = getNFTImageURL(tokenId);
      
      receiveHtml += `
        <div class="token-preview-sm" data-token-id="${tokenId}">
          <img src="${imgUrl}" alt="Token #${tokenId}" onerror="this.src='https://via.placeholder.com/50x50?text=${tokenId}'">
          <input type="checkbox" style="position: absolute; top: 5px; right: 5px;" onchange="toggleReceiveToken('${tokenId}')" checked>
        </div>`;
    }
    
    document.getElementById('receive-tokens-area').innerHTML = receiveHtml || '<div class="empty-selection">Sin tokens para recibir</div>';
    
    // Show my eligible tokens
    let myEligibleTokens = [];
    let myTokensHtml = '';
    
    for (const wanted of wantedTokens) {
      try {
        const owner = await nftContractRead.ownerOf(wanted);
        if (owner.toLowerCase() === userAddress.toLowerCase()) {
          myEligibleTokens.push(wanted.toString());
          
          const imgUrl = getNFTImageURL(wanted);
          
          myTokensHtml += `
            <div class="token-preview-sm" data-token-id="${wanted}">
              <img src="${imgUrl}" alt="Token #${wanted}" onerror="this.src='https://via.placeholder.com/50x50?text=${wanted}'">
              <input type="checkbox" style="position: absolute; top: 5px; right: 5px;" onchange="toggleGiveToken('${wanted}')" checked>
            </div>`;
        }
      } catch (err) {
        console.error(`Error checking token ${wanted}:`, err);
      }
    }
    
    document.getElementById('give-tokens-area').innerHTML = myTokensHtml || '<div class="empty-selection">No tienes ninguno de los tokens solicitados</div>';
    
    if (myEligibleTokens.length === 0) {
      document.getElementById('accept-offer-status').innerHTML = '<div class="status warning">No posees ninguno de los tokens solicitados para esta oferta.</div>';
      return;
    }
    
    // Setup token selection options (based on ratio)
    setupRatioOptions(offeredTokens, myEligibleTokens);
    
    // Display fee
    document.getElementById('exchange-fee-modal').textContent = ethers.utils.formatUnits(fixedFeeAmount, tokenDecimals);
    
    // Store for later
    window.selectedReceiveTokens = [...offeredTokens.map(t => t.toString())];
    window.selectedGiveTokens = [...myEligibleTokens];
    
    // Update ratio display
    updateAcceptRatio();
    
    // Clear status
    document.getElementById('accept-offer-status').textContent = '';
    
    // Show modal
    const modal = new bootstrap.Modal(document.getElementById('acceptOfferModal'));
    modal.show();
  } catch (error) {
    console.error("Error preparing accept offer:", error);
    document.getElementById('accept-offer-status').innerHTML = `<div class="status error">Error: ${error.message}</div>`;
  }
}

// Setup ratio selection options
function setupRatioOptions(offeredTokens, myEligibleTokens) {
  const container = document.getElementById('ratio-options-container');
  container.innerHTML = '';
  
  // No ratio options needed if all tokens are required
  if (offeredTokens.length <= 1 || myEligibleTokens.length <= 1) {
    container.style.display = 'none';
    return;
  }
  
  container.style.display = 'flex';
  
  // Simple ratios
  let html = '<p class="w-100">Opciones de Ratio:</p>';
  
  // 1:1
  if (offeredTokens.length >= 1 && myEligibleTokens.length >= 1) {
    html += `<div class="ratio-option selected" onclick="selectRatioOption(1, 1)">1:1</div>`;
  }
  
  // 2:1
  if (offeredTokens.length >= 2 && myEligibleTokens.length >= 1) {
    html += `<div class="ratio-option" onclick="selectRatioOption(2, 1)">2:1</div>`;
  }
  
  // 1:2
  if (offeredTokens.length >= 1 && myEligibleTokens.length >= 2) {
    html += `<div class="ratio-option" onclick="selectRatioOption(1, 2)">1:2</div>`;
  }
  
  // All
  html += `<div class="ratio-option" onclick="selectRatioOption(${offeredTokens.length}, ${myEligibleTokens.length})">Todo (${offeredTokens.length}:${myEligibleTokens.length})</div>`;
  
  container.innerHTML = html;
}

// Select ratio option
function selectRatioOption(receiveCount, giveCount) {
  // Update UI
  document.querySelectorAll('.ratio-option').forEach(option => {
    option.classList.remove('selected');
  });
  event.currentTarget.classList.add('selected');
  
  // Get all tokens
  const receiveTokens = Array.from(document.querySelectorAll('#receive-tokens-area .token-preview-sm')).map(
    elem => elem.getAttribute('data-token-id')
  );
  
  const giveTokens = Array.from(document.querySelectorAll('#give-tokens-area .token-preview-sm')).map(
    elem => elem.getAttribute('data-token-id')
  );
  
  // Select tokens based on the ratio
  window.selectedReceiveTokens = receiveTokens.slice(0, receiveCount);
  window.selectedGiveTokens = giveTokens.slice(0, giveCount);
  
  // Update UI to reflect selection
  document.querySelectorAll('#receive-tokens-area input[type="checkbox"]').forEach((checkbox, index) => {
    const isSelected = index < receiveCount;
    checkbox.checked = isSelected;
  });
  
  document.querySelectorAll('#give-tokens-area input[type="checkbox"]').forEach((checkbox, index) => {
    const isSelected = index < giveCount;
    checkbox.checked = isSelected;
  });
  
  // Update ratio display
  updateAcceptRatio();
}

// Toggle token selection for receiving
function toggleReceiveToken(tokenId) {
  if (!window.selectedReceiveTokens) window.selectedReceiveTokens = [];
  
  if (window.selectedReceiveTokens.includes(tokenId)) {
    window.selectedReceiveTokens = window.selectedReceiveTokens.filter(id => id !== tokenId);
  } else {
    window.selectedReceiveTokens.push(tokenId);
  }
  
  updateAcceptRatio();
}

// Toggle token selection for giving
function toggleGiveToken(tokenId) {
  if (!window.selectedGiveTokens) window.selectedGiveTokens = [];
  
  if (window.selectedGiveTokens.includes(tokenId)) {
    window.selectedGiveTokens = window.selectedGiveTokens.filter(id => id !== tokenId);
  } else {
    window.selectedGiveTokens.push(tokenId);
  }
  
  updateAcceptRatio();
}

// Accept offer
async function acceptOffer() {
  try {
    if (!currentOfferId) {
      showStatus('accept-offer-status', 'No hay oferta seleccionada', 'error');
      return;
    }

    // Validate selections
    if (!window.selectedReceiveTokens || window.selectedReceiveTokens.length === 0) {
      showStatus('accept-offer-status', 'Selecciona al menos un token para recibir', 'warning');
      return;
    }
    
    if (!window.selectedGiveTokens || window.selectedGiveTokens.length === 0) {
      showStatus('accept-offer-status', 'Selecciona al menos un token para dar', 'warning');
      return;
    }
    
    // Get full offer details again for additional checks
    showStatus('accept-offer-status', 'Verificando detalles de la oferta...', 'warning');
    
    const offerDetails = await exchangeContractRead.getOfferDetails(currentOfferId);
    const [creator, offeredTokens, wantedTokens, expirationTime, isActive] = offerDetails;
    
    // Important validations
    if (!isActive) {
      showStatus('accept-offer-status', 'Esta oferta ya no está activa', 'error');
      return;
    }
    
    if (creator.toLowerCase() === userAddress.toLowerCase()) {
      showStatus('accept-offer-status', 'No puedes aceptar tu propia oferta', 'error');
      return;
    }
    
    if (expirationTime.mul(1000).lt(Date.now())) {
      showStatus('accept-offer-status', 'Esta oferta ha expirado', 'error');
      return;
    }
    
    // Verify ownership of tokens to give
    for (const tokenId of window.selectedGiveTokens) {
      try {
        const owner = await nftContractRead.ownerOf(tokenId);
        if (owner.toLowerCase() !== userAddress.toLowerCase()) {
          showStatus('accept-offer-status', `No posees el token #${tokenId}`, 'error');
        return;
      }
      } catch (err) {
        showStatus('accept-offer-status', `Error verificando la propiedad del token #${tokenId}`, 'error');
        return;
      }
    }
    
    // Verify ownership of tokens to receive
    for (const tokenId of window.selectedReceiveTokens) {
      try {
        const owner = await nftContractRead.ownerOf(tokenId);
        if (owner.toLowerCase() !== creator.toLowerCase()) {
          showStatus('accept-offer-status', `El token #${tokenId} ya no pertenece al creador de la oferta`, 'error');
        return;
      }
      } catch (err) {
        showStatus('accept-offer-status', `Error verificando la propiedad del token #${tokenId}`, 'error');
        return;
      }
    }
    
    // Validate selections against the offer
    for (const tokenId of window.selectedReceiveTokens) {
      let found = false;
      for (const offeredToken of offeredTokens) {
        if (offeredToken.toString() === tokenId) {
          found = true;
          break;
        }
      }
      if (!found) {
        showStatus('accept-offer-status', `El token #${tokenId} no es parte de los tokens ofrecidos`, 'error');
        return;
      }
    }
    
    for (const tokenId of window.selectedGiveTokens) {
      let found = false;
      for (const wantedToken of wantedTokens) {
        if (wantedToken.toString() === tokenId) {
          found = true;
          break;
        }
      }
      if (!found) {
        showStatus('accept-offer-status', `El token #${tokenId} no es parte de los tokens solicitados`, 'error');
        return;
      }
    }
    
    // Approve fee payment
    showStatus('accept-offer-status', 'Aprobando pago de comisión...', 'warning');
    
    try {
      // Check current allowance
      const currentAllowance = await adrianTokenContractRead.allowance(userAddress, EXCHANGE_ADDRESS);
      
      if (currentAllowance.lt(fixedFeeAmount)) {
        const approveTx = await adrianTokenContract.approve(EXCHANGE_ADDRESS, fixedFeeAmount);
        await approveTx.wait();
        logToOutput(`Aprobación de tokens ADRIAN completada`);
      } else {
        logToOutput(`Tokens ADRIAN ya aprobados`);
      }
    } catch (error) {
      showStatus('accept-offer-status', `Error al aprobar tokens ADRIAN: ${error.message}`, 'error');
      return;
    }
    
    // Approve NFT tokens
    showStatus('accept-offer-status', 'Aprobando tokens NFT...', 'warning');
    
    const useSetApprovalForAll = window.selectedGiveTokens.length > 1 && 
      confirm("¿Quieres aprobar todos tus tokens para la plataforma de intercambio? (más eficiente en gas)");
    
    if (useSetApprovalForAll) {
      try {
        const isApprovedForAll = await nftContract.isApprovedForAll(userAddress, EXCHANGE_ADDRESS);
        if (!isApprovedForAll) {
          const approveTx = await nftContract.setApprovalForAll(EXCHANGE_ADDRESS, true);
          await approveTx.wait();
          logToOutput(`Aprobación de todos los tokens completada`);
        }
      } catch (error) {
        console.error("Error setting approval for all:", error);
        showStatus('accept-offer-status', `Error aprobando tokens: ${error.message}`, 'error');
        return;
      }
    } else {
      // Approve tokens individually
      for (const tokenId of window.selectedGiveTokens) {
        try {
          const approved = await nftContractRead.getApproved(tokenId);
          if (approved.toLowerCase() !== EXCHANGE_ADDRESS.toLowerCase()) {
            showStatus('accept-offer-status', `Aprobando token #${tokenId}...`, 'warning');
            
            const approveTx = await nftContract.approve(EXCHANGE_ADDRESS, tokenId);
            await approveTx.wait();
            logToOutput(`Token #${tokenId} aprobado`);
          }
        } catch (error) {
          console.error(`Error approving token #${tokenId}:`, error);
          showStatus('accept-offer-status', `Error aprobando token #${tokenId}: ${error.message}`, 'error');
          return;
        }
      }
    }
    
    // Call acceptOffer function on the contract
    showStatus('accept-offer-status', 'Aceptando oferta...', 'warning');
    
    try {
      const gasEstimate = await exchangeContract.estimateGas.acceptOffer(
          currentOfferId, 
        window.selectedReceiveTokens, 
        window.selectedGiveTokens
      );
        
      // Add a 20% buffer to the gas estimate
      const gasLimit = gasEstimate.mul(120).div(100);
      
      const acceptTx = await exchangeContract.acceptOffer(
        currentOfferId,
        window.selectedReceiveTokens, 
        window.selectedGiveTokens,
        { gasLimit }
      );
      
      showStatus('accept-offer-status', 'Esperando confirmación de la transacción...', 'warning');
      
      const receipt = await acceptTx.wait();
      
      const exchangeEvent = receipt.events.find(e => e.event === 'ExchangeCompleted');
      
      if (exchangeEvent) {
        showStatus('accept-offer-status', '¡Oferta aceptada con éxito!', 'success');
        logToOutput(`Oferta aceptada con éxito. Hash de transacción: ${receipt.transactionHash}`);
        
        // Clear selections
        window.selectedReceiveTokens = [];
        window.selectedGiveTokens = [];
        
        // Refresh UI
        setTimeout(() => {
          fetchOffers();
          fetchUserTokens();
      }, 1000);
      } else {
        showStatus('accept-offer-status', 'Transacción completada, pero no se encontró el evento de intercambio', 'warning');
      }
    } catch (error) {
      console.error('Error accepting offer:', error);
      
      // Handle different error types
      if (error.code === 'ACTION_REJECTED') {
        showStatus('accept-offer-status', 'Transacción rechazada por el usuario', 'error');
      } else if (error.code === 'UNPREDICTABLE_GAS_LIMIT') {
        showStatus('accept-offer-status', 'Error al estimar gas. La oferta puede no ser válida.', 'error');
      } else if (error.message.includes('insufficient funds')) {
        showStatus('accept-offer-status', 'Fondos insuficientes para la transacción', 'error');
      } else if (error.message.includes('execution reverted')) {
        showStatus('accept-offer-status', 'La transacción falló. Verifica que la oferta siga siendo válida.', 'error');
      } else {
        showStatus('accept-offer-status', `Error al aceptar la oferta: ${error.message}`, 'error');
      }
    }
  } catch (error) {
    console.error('Error in acceptOffer function:', error);
    showStatus('accept-offer-status', `Error inesperado: ${error.message}`, 'error');
  }
}

// Cancel offer
async function cancelOffer() {
  try {
    if (!currentOfferId) return;
    
    const modal = bootstrap.Modal.getInstance(document.getElementById('offerDetailsModal'));
    
    // Add status message
    const statusDiv = document.createElement('div');
    statusDiv.className = 'status warning';
    statusDiv.textContent = 'Cancelando oferta...';
    document.getElementById('offer-details-content').appendChild(statusDiv);
    
    // Cancel the offer
    const tx = await exchangeContract.cancelOffer(currentOfferId);
    logToOutput(`Transacción enviada: ${tx.hash}`);
    
    await tx.wait();
    
    // Update status
    statusDiv.className = 'status success';
    statusDiv.textContent = '¡Oferta cancelada con éxito!';
    logToOutput("Oferta cancelada con éxito");
    
    // Reload offers after a delay
    setTimeout(async () => {
      await Promise.all([
        loadAllOffers(),
        loadMyOffers()
      ]);
      
      // Close modal after another delay
      setTimeout(() => {
        modal.hide();
      }, 1000);
    }, 1000);
  } catch (error) {
    console.error("Error al cancelar oferta:", error);
    const statusDiv = document.createElement('div');
    statusDiv.className = 'status error';
    statusDiv.textContent = `Error al cancelar oferta: ${error.message}`;
    document.getElementById('offer-details-content').appendChild(statusDiv);
  }
}

  </script>
</body>
</html>