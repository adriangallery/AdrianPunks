<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>AdrianPunks Toggler - Manage Versions</title>
  <!-- Bootstrap 5 CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet" />
  <link rel="stylesheet" href="/market/styles.css">
  <!-- Ethers.js -->
  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
  <style>
    :root {
      --bg-color: #f0f0f0;
      --primary-text: #333333;
      --accent-purple: #8a2be2;
      --accent-purple-hover: #7a1dd2;
      --accent-blue: #4dabf7;
      --card-bg: #ffffff;
      --card-border: #e9ecef;
      --card-selected-border: #8a2be2;
      --screen-bg: #ffffff;
      --navbar-height: 60px;
      --error-bg: #f8d7da;
      --error-border: #f5c6cb;
      --error-text: #721c24;
      --success-bg: #d4edda;
      --success-border: #c3e6cb;
      --success-text: #155724;
    }
    
    /* Dark mode variables */
    [data-theme="dark"] {
      --bg-color: #1a1a1a;
      --primary-text: #ffffff;
      --card-bg: #2d2d2d;
      --card-border: #404040;
      --screen-bg: #2d2d2d;
      --error-bg: #3f1e22;
      --error-border: #842029;
      --error-text: #ea868f;
      --success-bg: #051b11;
      --success-border: #0f5132;
      --success-text: #75b798;
    }
    
    body {
      background-color: var(--bg-color);
      color: var(--primary-text);
      font-family: 'Share Tech Mono', monospace;
      margin: 0;
      padding: 20px;
      line-height: 1.6;
      padding-top: calc(var(--navbar-height) + 20px);
      transition: background-color 0.3s ease, color 0.3s ease;
    }
    
    .container {
      max-width: 1200px;
      margin: auto;
      padding: 20px;
      background: var(--screen-bg);
      border-radius: 8px;
      box-shadow: 0 4px 10px rgba(0,0,0,0.1);
      transition: background-color 0.3s ease;
    }
    
    header {
      text-align: center;
      padding: 2rem;
      margin-bottom: 2rem;
      position: relative;
    }
    
    header h1 {
      font-size: 2.5rem;
      margin: 0;
      color: var(--primary-text);
      font-weight: 600;
      letter-spacing: 1px;
    }
    
    header p {
      margin-top: 1rem;
      font-size: 1rem;
      color: var(--primary-text);
      opacity: 0.8;
    }
    
    .card {
      background: var(--card-bg);
      border: 1px solid var(--card-border);
      border-radius: 8px;
      padding: 1rem;
      margin-bottom: 1.5rem;
      box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    }
    
    .section-title {
      font-size: 1.4rem;
      margin-bottom: 1.5rem;
      color: var(--primary-text);
      font-weight: 600;
      border-bottom: 2px solid var(--card-border);
      padding-bottom: 0.5rem;
    }
    
    .token-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 1rem;
      padding: 0;
      margin: 0;
    }
    
    @media (max-width: 768px) {
      .token-grid {
        grid-template-columns: repeat(2, 1fr);
      }
    }
    
    @media (max-width: 480px) {
      .token-grid {
        grid-template-columns: 1fr;
      }
    }
    
    .token-card {
      background: var(--card-bg);
      border: 1px solid var(--card-border);
      border-radius: 8px;
      padding: 0.8rem;
      cursor: pointer;
      transition: all 0.2s ease;
      position: relative;
    }
    
    .token-card:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 8px rgba(0,0,0,0.1);
    }
    
    .token-card img {
      width: 100%;
      height: auto;
      object-fit: contain;
      border-radius: 4px;
      aspect-ratio: 1/1;
      background-color: #f0f0f0;
    }
    
    .token-info {
      padding: 0.5rem 0;
    }
    
    .token-title {
      font-size: 1.1rem;
      font-weight: bold;
      margin-bottom: 0.5rem;
    }
    
    .token-status {
      display: inline-block;
      padding: 0.25rem 0.5rem;
      border-radius: 9999px;
      font-size: 0.75rem;
      font-weight: 600;
      margin-bottom: 0.5rem;
    }
    
    .status-mirrored {
      background-color: #d1fae5;
      color: #065f46;
    }
    
    .status-not-mirrored {
      background-color: #fef3c7;
      color: #92400e;
    }
    
    .token-version {
      font-size: 0.9rem;
      color: #6b7280;
    }
    
    .selected-token {
      border: 2px solid var(--card-selected-border);
      box-shadow: 0 0 0 2px var(--card-selected-border);
    }
    
    .btn-connect {
      background-color: var(--accent-purple);
      color: white;
      border: none;
      padding: 0.75rem 1.5rem;
      font-size: 1rem;
      border-radius: 0.5rem;
      cursor: pointer;
      transition: background-color 0.3s ease;
    }
    
    .btn-connect:hover {
      background-color: var(--accent-purple-hover);
    }
    
    .btn-action {
      background-color: var(--accent-purple);
      color: white;
      border: none;
      padding: 0.75rem 1.5rem;
      font-size: 1rem;
      border-radius: 0.5rem;
      cursor: pointer;
      transition: all 0.3s ease;
      display: inline-block;
      text-align: center;
      margin-right: 0.5rem;
      margin-bottom: 0.5rem;
    }
    
    .btn-action:hover {
      background-color: var(--accent-purple-hover);
      transform: translateY(-2px);
    }
    
    .btn-secondary {
      background-color: #6c757d;
    }
    
    .btn-secondary:hover {
      background-color: #5a6268;
    }
    
    .account-display {
      display: inline-block;
      background-color: #f0f0f0;
      padding: 0.5rem 1rem;
      border-radius: 9999px;
      font-family: monospace;
      font-size: 0.9rem;
    }
    
    .alert {
      padding: 1rem;
      border-radius: 0.375rem;
      margin-bottom: 1rem;
    }
    
    .alert-danger {
      background-color: var(--error-bg);
      border: 1px solid var(--error-border);
      color: var(--error-text);
    }
    
    .alert-success {
      background-color: var(--success-bg);
      border: 1px solid var(--success-border);
      color: var(--success-text);
    }
    
    .version-selector {
      width: 100%;
      padding: 0.5rem;
      border-radius: 0.375rem;
      border: 1px solid var(--card-border);
      margin-bottom: 1rem;
    }
    
    .token-badge {
      display: inline-block;
      background-color: #e0e7ff;
      color: #4338ca;
      padding: 0.25rem 0.5rem;
      border-radius: 9999px;
      font-size: 0.75rem;
      margin-right: 0.25rem;
      margin-bottom: 0.25rem;
    }
    
    .footer {
      text-align: center;
      margin-top: 2rem;
      padding-top: 1rem;
      border-top: 1px solid var(--card-border);
      color: #9ca3af;
      font-size: 0.875rem;
    }
    
    .token-image-container {
      width: 100%;
      aspect-ratio: 1/1;
      overflow: hidden;
      border-radius: 4px;
      background-color: #f0f0f0;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
    }
    
    .token-image {
      width: 100%;
      height: 100%;
      object-fit: contain;
      display: block;
    }

    .preview-button {
      position: absolute;
      bottom: 5px;
      right: 5px;
      background-color: rgba(138, 43, 226, 0.8);
      color: white;
      border: none;
      border-radius: 50%;
      width: 30px;
      height: 30px;
      font-size: 16px;
      line-height: 1;
      cursor: pointer;
      z-index: 10;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s ease;
    }

    .preview-button:hover {
      background-color: rgba(138, 43, 226, 1);
      transform: scale(1.1);
    }

    /* Estilos para la botonera */
    .info-section {
      margin-bottom: 1.5rem;
    }
    
    .main-actions {
      margin-bottom: 1.5rem;
    }
    
    .action-buttons {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
    }
    
    .action-btn {
      padding: 0.5rem 1rem;
      border-radius: 0.25rem;
      border: none;
      font-size: 0.875rem;
      cursor: pointer;
      color: white;
      transition: all 0.2s ease;
    }
    
    .action-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 6px rgba(0,0,0,0.1);
    }
    
    .action-btn.primary {
      background-color: #007bff;
    }
    
    .action-btn.secondary {
      background-color: #6c757d;
    }
    
    .action-btn.success {
      background-color: #28a745;
    }
    
    .action-btn.info {
      background-color: #17a2b8;
    }
    
    .action-btn.warning {
      background-color: #ffc107;
      color: #212529;
    }
    
    .action-btn.danger {
      background-color: #dc3545;
    }
    
    .action-btn.dark {
      background-color: #343a40;
    }
    
    .action-btn.outline {
      background-color: transparent;
      border: 1px solid #dee2e6;
      color: var(--primary-text);
    }
    
    .action-btn.outline:hover {
      background-color: #f8f9fa;
    }
    
    @media (max-width: 768px) {
      .action-buttons {
        flex-direction: column;
        width: 100%;
      }
      
      .action-btn {
        width: 100%;
        text-align: center;
      }
      
      .d-md-inline {
        display: none;
      }
    }
  </style>
</head>
<body>
  <!-- Include the menu -->
  <div id="menu-container"></div>
  <script>
    // Load the menu
    fetch('/market/components/menu.html')
      .then(response => response.text())
      .then(html => {
        document.getElementById('menu-container').innerHTML = html;
        // Ensure menu has correct style
        const menu = document.querySelector('.navbar');
        if (menu) {
          menu.classList.add('navbar-dark', 'bg-dark');
        }
        // Initialize Bootstrap's JavaScript for the menu
        const menuScript = document.createElement('script');
        menuScript.src = 'https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js';
        menuScript.onload = () => {
          // Asegurarse de que el menú esté cerrado al cargar
          const navbarCollapse = document.querySelector('.navbar-collapse');
          if (navbarCollapse) {
            navbarCollapse.classList.remove('show');
            // Forzar el cierre del menú
            const bsCollapse = new bootstrap.Collapse(navbarCollapse, {
              toggle: false
            });
            bsCollapse.hide();
          }
        };
        document.head.appendChild(menuScript);
      })
      .catch(error => console.error('Error loading menu:', error));
  </script>

  <div class="container">
    <!-- Header -->
    <header>
      <h1>AdrianPunks Toggler</h1>
      <p>Manage your AdrianPunks and their versions in PocketAdrians</p>
    </header>
    
    <!-- Balance y Floor Offer Info -->
    <div class="info-section mb-4">
      <h2 id="tokenBalance" class="mb-2">Balance: Loading...</h2>
      <div id="floorOfferSection" class="text-secondary">
        <span id="floorOfferText">Highest floor offer: -- $ADRIAN</span>
      </div>
    </div>

    <!-- Botonera Principal Unificada -->
    <div class="main-actions mb-4">
      <div class="action-buttons">
        <button class="action-btn warning" onclick="openFloorOfferPopup()">
          <span class="d-none d-md-inline">Make Floor</span> Offer
        </button>
        <button class="action-btn info" onclick="openMyOffersModal()">
          <span class="d-none d-md-inline">My</span> Offers
        </button>
        <button class="action-btn secondary" onclick="openMyListingsModal()">
          <span class="d-none d-md-inline">My</span> Listings
        </button>
        <button class="action-btn dark" onclick="openRecentActivityModal()">
          <span class="d-none d-md-inline">Recent</span> Activity
        </button>
        <button class="action-btn outline" onclick="window.location.href='/market/'">
          <span class="d-none d-md-inline">Go to</span> Market
        </button>
        <button class="action-btn outline" onclick="window.location.href='/toggler/'">
          <span class="d-none d-md-inline">Go to</span> Toggler
        </button>
        <button class="action-btn" id="themeButton" onclick="toggleTheme()">
          <span id="themeButtonText">DarkMode</span>
        </button>
        <!-- Nuevo botón de wallet para la botonera principal -->
        <button class="action-btn outline" id="mainConnectWalletButton">
          Connect Wallet
        </button>
      </div>
    </div>
    
    <!-- Connect Wallet Section -->
    <div id="connect-section" class="text-center mb-4">
      <button id="connectWalletBtn" class="btn-connect">Connect Wallet</button>
    </div>
    
    <!-- Account Info Section (hidden by default) -->
    <div id="account-section" class="text-center mb-4" style="display: none;">
      <p>Connected Wallet:</p>
      <div id="accountDisplay" class="account-display"></div>
    </div>
    
    <!-- Alert Messages -->
    <div id="errorAlert" class="alert alert-danger" style="display: none;"></div>
    <div id="successAlert" class="alert alert-success" style="display: none;"></div>
    
    <!-- Token Management Section (hidden by default) -->
    <div id="token-management" class="card" style="display: none;">
      <div class="d-flex justify-content-between align-items-center mb-3">
        <h2 class="section-title mb-0">Your AdrianPunks</h2>
        <button id="selectAllBtn" class="btn-secondary btn-action">Select All</button>
      </div>
      
      <div id="loading-tokens" class="text-center py-5">
        <div class="spinner-border text-primary" role="status">
          <span class="visually-hidden">Loading...</span>
        </div>
        <p class="mt-2">Loading your tokens...</p>
      </div>
      
      <div id="no-tokens-message" class="text-center py-5" style="display: none;">
        <p>You don't own any AdrianPunks yet</p>
      </div>
      
      <!-- Token Grid -->
      <div id="token-grid" class="token-grid mb-4"></div>
      
      <!-- Action Button -->
      <button id="syncBtn" class="btn-action w-100 mb-3" disabled>Sync Ownership (0 selected)</button>
    </div>
    
    <!-- Version Management Section (hidden by default) -->
    <div id="version-management" class="card" style="display: none;">
      <h2 class="section-title">Update Versions</h2>
      
      <div id="no-selection-message" class="text-center mb-3">
        <p>Select tokens above to change their versions</p>
      </div>
      
      <div id="selection-info" style="display: none;">
        <p>Selected Tokens: <span id="selectedCount">0</span></p>
        <div id="selectedTokensList" class="mb-3"></div>
      </div>
      
      <div class="mb-3">
        <label for="versionSelector" class="form-label">Select Version</label>
        <select id="versionSelector" class="version-selector"></select>
      </div>
      
      <button id="updateVersionBtn" class="btn-action w-100" disabled>Update Version</button>
    </div>
    
    <!-- Footer -->
    <div class="footer">
      <p id="contractAddressInfo"></p>
      <p>© 2025 AdrianPunks</p>
    </div>
  </div>

  <script>
// Contract ABIs - simplified for the essential functions we need
const ADRIAN_PUNKS_ABI = [
  "function ownerOf(uint256 id) external view returns (address)",
  "function currentTokenId() external view returns (uint256)",
  "function balanceOf(address owner) external view returns (uint256)",
  "function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256)"
];

const POCKET_ADRIANS_ABI = [
  "function mirrored(uint256 id) external view returns (bool)",
  "function tokenVersion(uint256 id) external view returns (uint256)",
  "function defaultVersion() external view returns (uint256)",
  "function versionCount() external view returns (uint256)",
  "function metadataVersions(uint256 versionId) external view returns (string memory, string memory, bool)",
  "function syncMultipleTokens(uint256[] calldata ids) external",
  "function setTokensVersion(uint256[] calldata tokenIds, uint256 versionId) external"
];

// Contract addresses
const ADRIAN_PUNKS_ADDRESS = "0x79BE8AcdD339C7b92918fcC3fd3875b5Aaad7566";
const POCKET_ADRIANS_ADDRESS = "0x6bA5A93878a0aC34B63Fd9994a874a9B0111d587";

// Base network configuration
const BASE_NETWORK = {
  chainId: "0x2105", // Base mainnet chainId in hex
  chainName: "Base",
  nativeCurrency: {
    name: "Ethereum",
    symbol: "ETH",
    decimals: 18,
  },
  rpcUrls: ["https://base-mainnet.infura.io/v3/cc0c8013b1e044dcba79d4f7ec3b2ba1"],
  blockExplorerUrls: ["https://basescan.org/"],
};

// Infura provider for read-only operations
const infuraProvider = new ethers.providers.JsonRpcProvider(
  "https://base-mainnet.infura.io/v3/cc0c8013b1e044dcba79d4f7ec3b2ba1",
  {
    name: "base",
    chainId: 8453
  }
);

    // DOM Elements
    const connectSection = document.getElementById('connect-section');
    const accountSection = document.getElementById('account-section');
    const accountDisplay = document.getElementById('accountDisplay');
    const errorAlert = document.getElementById('errorAlert');
    const successAlert = document.getElementById('successAlert');
    const tokenManagement = document.getElementById('token-management');
    const versionManagement = document.getElementById('version-management');
    const loadingTokens = document.getElementById('loading-tokens');
    const noTokensMessage = document.getElementById('no-tokens-message');
    const tokenGrid = document.getElementById('token-grid');
    const noSelectionMessage = document.getElementById('no-selection-message');
    const selectionInfo = document.getElementById('selection-info');
    const selectedCount = document.getElementById('selectedCount');
    const selectedTokensList = document.getElementById('selectedTokensList');
    const versionSelector = document.getElementById('versionSelector');
    const syncBtn = document.getElementById('syncBtn');
    const updateVersionBtn = document.getElementById('updateVersionBtn');
    const selectAllBtn = document.getElementById('selectAllBtn');
    const connectWalletBtn = document.getElementById('connectWalletBtn');
    const contractAddressInfo = document.getElementById('contractAddressInfo');

    // App State
    let account = '';
    let provider = null;
    let signer = null;
    let adrianPunksContract = null;
    let pocketAdriansContract = null;
    let ownedTokens = [];
    let selectedTokens = [];
    let isLoading = false;
    let versions = [];
    let selectedVersion = 1;

    // Set contract address info
    contractAddressInfo.innerHTML = `
      AdrianPunks: ${ADRIAN_PUNKS_ADDRESS.substring(0, 6)}...${ADRIAN_PUNKS_ADDRESS.substring(38)} | 
      PocketAdrians: ${POCKET_ADRIANS_ADDRESS.substring(0, 6)}...${POCKET_ADRIANS_ADDRESS.substring(38)}
    `;

    // Show error message
    function showError(message) {
      errorAlert.textContent = message;
      errorAlert.style.display = 'block';
      setTimeout(() => {
        errorAlert.style.display = 'none';
      }, 5000);
    }

    // Show success message
    function showSuccess(message) {
      successAlert.textContent = message;
      successAlert.style.display = 'block';
      setTimeout(() => {
        successAlert.style.display = 'none';
      }, 5000);
    }

    // Load tokens owned by the connected account
    async function loadOwnedTokens(account) {
      setLoading(true);
      tokenGrid.innerHTML = '';
      noTokensMessage.style.display = 'none';
      loadingTokens.style.display = 'block';

      try {
        // Actualizar el balance al cargar los tokens
        updateTokenBalance();
        
        // Configure Multicall
        const multicall = new ethers.Contract(
          "0xcA11bde05977b3631167028862bE2a173976CA11",
          [
            "function aggregate3(tuple(address target, bool allowFailure, bytes callData)[] calls) public view returns (tuple(bool success, bytes returnData)[] returnData)"
          ],
          infuraProvider
        );

        // Get total NFT balance
        const balance = await adrianPunksContract.balanceOf(account);
        const totalTokens = balance.toNumber();

        if (totalTokens === 0) {
          tokenGrid.style.display = 'none';
          noTokensMessage.style.display = 'block';
          showSuccess("No AdrianPunks found in your wallet");
          return;
        }

        // Prepare calls to get all tokenIds
        const calls = [];
        for (let i = 0; i < totalTokens; i++) {
          calls.push({
            target: ADRIAN_PUNKS_ADDRESS,
            allowFailure: true,
            callData: adrianPunksContract.interface.encodeFunctionData('tokenOfOwnerByIndex', [account, i])
          });
        }

        // Execute all calls in a single transaction
        const results = await multicall.aggregate3(calls);
        const tokenIds = results
          .filter(result => result.success)
          .map(result => {
            const decoded = adrianPunksContract.interface.decodeFunctionResult('tokenOfOwnerByIndex', result.returnData);
            return decoded[0];
          });

        // Prepare calls to get mirroring status and version
        const mirrorCalls = tokenIds.flatMap(tokenId => [
          {
            target: POCKET_ADRIANS_ADDRESS,
            allowFailure: true,
            callData: pocketAdriansContract.interface.encodeFunctionData('mirrored', [tokenId])
          },
          {
            target: POCKET_ADRIANS_ADDRESS,
            allowFailure: true,
            callData: pocketAdriansContract.interface.encodeFunctionData('tokenVersion', [tokenId])
          }
        ]);

        // Execute mirroring and version calls
        const mirrorResults = await multicall.aggregate3(mirrorCalls);
        
        // Process results
        ownedTokens = [];
        for (let i = 0; i < tokenIds.length; i++) {
          const tokenId = tokenIds[i];
          const isMirrored = mirrorResults[i * 2].success && 
            pocketAdriansContract.interface.decodeFunctionResult('mirrored', mirrorResults[i * 2].returnData)[0];
          
          let tokenVersion = 0;
          if (isMirrored) {
            tokenVersion = mirrorResults[i * 2 + 1].success ? 
              pocketAdriansContract.interface.decodeFunctionResult('tokenVersion', mirrorResults[i * 2 + 1].returnData)[0].toNumber() : 0;
            
            if (tokenVersion === 0) {
              const defaultVersion = await pocketAdriansContract.defaultVersion();
              tokenVersion = defaultVersion.toNumber();
            }
          }
          
          ownedTokens.push({
            id: tokenId.toNumber(),
            isMirrored,
            version: tokenVersion
          });
        }
        
        // Update UI
        renderTokens();
        showSuccess(`Found ${ownedTokens.length} AdrianPunks in your wallet`);
        
      } catch (error) {
        console.error("Error loading tokens:", error);
        showError("Failed to load your tokens. Please try again.");
        tokenGrid.style.display = 'none';
        noTokensMessage.style.display = 'block';
      } finally {
        loadingTokens.style.display = 'none';
        setLoading(false);
      }
    }

    // Connect wallet
    const originalConnectWallet = connectWallet;
    connectWallet = async function() {
      await originalConnectWallet.apply(this, arguments);
      
      // Después de conectar la wallet, actualiza el botón principal
      if (account) {
        const mainWalletButton = document.getElementById('mainConnectWalletButton');
        if (mainWalletButton) {
          mainWalletButton.textContent = `${account.substring(0, 6)}...${account.substring(38)}`;
          mainWalletButton.classList.add('active');
        }
        
        // Actualizar el balance
        updateTokenBalance();
      }
    };

    // Set loading state
    function setLoading(loading) {
      isLoading = loading;
      loadingTokens.style.display = loading ? 'block' : 'none';
      connectWalletBtn.disabled = loading;
      syncBtn.disabled = loading || selectedTokens.length === 0;
      updateVersionBtn.disabled = loading || selectedTokens.length === 0;
    }
  
  // Load available metadata versions
    async function loadVersions() {
    try {
      const versionCount = await pocketAdriansContract.versionCount();
      const versionCountNumber = versionCount.toNumber();
      
        versions = [];
      
      for (let i = 1; i <= versionCountNumber; i++) {
        const versionInfo = await pocketAdriansContract.metadataVersions(i);
        const [base1, base2, active] = versionInfo;
        
        if (active) {
            versions.push({
            id: i,
            base1,
            base2,
            active
          });
        }
      }
      
        // Populate version selector
        versionSelector.innerHTML = '';
        versions.forEach(version => {
          const option = document.createElement('option');
          option.value = version.id;
          option.textContent = `Version ${version.id}`;
          versionSelector.appendChild(option);
        });
      
    } catch (error) {
      console.error("Error loading versions:", error);
        showError("Error loading versions. Please try again.");
    }
    }

    // Render tokens in the grid
    function renderTokens() {
      tokenGrid.innerHTML = '';
      
      ownedTokens.forEach(token => {
        const isSelected = selectedTokens.includes(token.id);
        
        const tokenCard = document.createElement('div');
        tokenCard.className = `token-card ${isSelected ? 'selected-token' : ''}`;
        tokenCard.onclick = () => toggleSelectToken(token.id);
        
        // Determinar la ruta base según la versión
        let basePath;
        if (token.version === 1) {
          basePath = '/market/halfxadrianimages/';
        } else if (token.version === 2) {
          basePath = '/market/alpha/';
        } else if (token.version === 3) {
          basePath = '/market/omega/';
        } else {
          // Versión por defecto o desconocida
          basePath = '/market/halfxadrianimages/';
        }
        
        const placeholderUrl = '/market/halfxadrianimages/placeholder.jpg';
        
        // Crear el contenedor de la imagen
        const imageContainer = document.createElement('div');
        imageContainer.className = "token-image-container";
        
        // Función para cargar imágenes con diferentes formatos
        function loadImageWithFallbacks(tokenId, basePath) {
          // Casos especiales conocidos que son GIF
          const knownGifs = [1, 13, 69, 221, 369, 420, 555, 690, 777, 807, 1000];
          
          // Lista de posibles formatos a intentar, en orden de prioridad
          let formats = [];
          
          // Si es un ID conocido que suele ser GIF, priorizar ese formato
          if (knownGifs.includes(tokenId)) {
            formats = [
              // Primero intentamos con .gif
              { extension: 'gif', prefix: '' },
              // Luego otros formatos
              { extension: 'png', prefix: '' },
              { extension: 'jpg', prefix: '' },
              { extension: 'gif', prefix: 'adrianpunks#' },
              { extension: 'png', prefix: 'adrianpunks#' },
              { extension: 'jpg', prefix: 'adrianpunks#' },
              { extension: 'gif', prefix: 'AdrianPunks#' },
              { extension: 'png', prefix: 'AdrianPunks#' },
              { extension: 'jpg', prefix: 'AdrianPunks#' }
            ];
          } else {
            formats = [
              // Para el resto de tokens, probar en este orden
              { extension: 'jpg', prefix: '' },
              { extension: 'png', prefix: '' },
              { extension: 'gif', prefix: '' },
              { extension: 'jpg', prefix: 'adrianpunks#' },
              { extension: 'png', prefix: 'adrianpunks#' },
              { extension: 'gif', prefix: 'adrianpunks#' },
              { extension: 'jpg', prefix: 'AdrianPunks#' },
              { extension: 'png', prefix: 'AdrianPunks#' },
              { extension: 'gif', prefix: 'AdrianPunks#' }
            ];
          }
          
          // Si estamos en la versión 1 (halfxadrianimages), solo intentamos jpg
          if (basePath.includes('halfxadrianimages')) {
            return loadImage(`${basePath}${tokenId}.jpg`, placeholderUrl);
          }
          
          let currentIndex = 0;
          
          function tryNextFormat() {
            if (currentIndex >= formats.length) {
              // Si hemos agotado todos los formatos, usar placeholder
              console.log(`No se pudo cargar ninguna imagen para ID ${tokenId}`);
              const img = new Image();
              img.src = placeholderUrl;
              img.className = "token-image";
              img.alt = `Adrian #${tokenId}`;
              img.dataset.tokenId = tokenId;
              imageContainer.innerHTML = '';
              imageContainer.appendChild(img);
              return;
            }
            
            const format = formats[currentIndex];
            currentIndex++;
            
            const img = new Image();
            const imgSrc = `${basePath}${format.prefix}${tokenId}.${format.extension}`;
            console.log(`[DEBUG] Intentando cargar: ${imgSrc} (Token ID: ${tokenId}, Versión: ${token.version})`);
            img.src = imgSrc;
            img.className = "token-image";
            img.alt = `Adrian #${tokenId}`;
            img.dataset.tokenId = tokenId;
            img.dataset.version = token.version;
            img.onerror = function() {
              console.log(`[ERROR] Falló la carga: ${imgSrc}`);
              tryNextFormat();
            };
            img.onload = function() {
              console.log(`[SUCCESS] Imagen cargada correctamente: ${imgSrc}`);
              imageContainer.innerHTML = '';
              imageContainer.appendChild(img);
              
              // Añadir el botón de previsualización
              const previewButton = document.createElement('button');
              previewButton.className = 'preview-button';
              previewButton.innerHTML = '♺';
              previewButton.title = 'Previsualizar otras versiones';
              previewButton.setAttribute('data-token-id', tokenId);
              
              // Detener la propagación para evitar que se seleccione el token al hacer clic en el botón
              previewButton.addEventListener('click', function(event) {
                event.stopPropagation();
                previewNextVersion(tokenId, img);
              });
              
              imageContainer.appendChild(previewButton);
            };
            
            // Iniciar la carga
            if (currentIndex === 1) {
              imageContainer.appendChild(img);
            }
          }
          
          // Iniciar el intento de carga de formatos
          tryNextFormat();
        }
        
        // Función simplificada para cargar una sola imagen con fallback
        function loadImage(src, fallbackSrc) {
          const img = new Image();
          img.src = src;
          img.className = "token-image";
          img.alt = `Adrian #${token.id}`;
          img.dataset.tokenId = token.id;
          img.dataset.version = token.version;
          img.onerror = function() {
            this.src = fallbackSrc;
            console.log("Error loading image:", src, "using placeholder:", fallbackSrc);
          };
          
          imageContainer.appendChild(img);
          
          // Añadir el botón de previsualización
          img.onload = function() {
            const previewButton = document.createElement('button');
            previewButton.className = 'preview-button';
            previewButton.innerHTML = '♺';
            previewButton.title = 'Previsualizar otras versiones';
            previewButton.setAttribute('data-token-id', token.id);
            
            // Detener la propagación para evitar que se seleccione el token al hacer clic en el botón
            previewButton.addEventListener('click', function(event) {
              event.stopPropagation();
              previewNextVersion(token.id, img);
            });
            
            imageContainer.appendChild(previewButton);
          };
        }
        
        // Cargar la imagen con fallbacks
        loadImageWithFallbacks(token.id, basePath);
        
        tokenCard.innerHTML = `
          <div class="token-info">
            <div class="d-flex justify-content-between align-items-center">
              <div class="token-title">Adrian #${token.id}</div>
              <div class="token-status ${token.isMirrored ? 'status-mirrored' : 'status-not-mirrored'}">
                ${token.isMirrored ? 'Mirrored' : 'Not Mirrored'}
              </div>
            </div>
            ${token.isMirrored ? `<div class="token-version">Current Version: ${token.version}</div>` : ''}
          </div>
        `;
        
        // Añadir el contenedor de la imagen después del token-info
        tokenCard.appendChild(imageContainer);
        
        tokenGrid.appendChild(tokenCard);
      });
      
      // Show grid immediately after rendering
      tokenGrid.style.display = 'grid';
      noTokensMessage.style.display = 'none';
      
      updateSelectedUI();
    }

  // Toggle token selection
    function toggleSelectToken(tokenId) {
    // Convert tokenId to number for consistent comparison
    const tokenIdNumber = typeof tokenId === 'object' && tokenId.toNumber ? 
                        tokenId.toNumber() : 
                        Number(tokenId);
                        
    if (selectedTokens.includes(tokenIdNumber)) {
        selectedTokens = selectedTokens.filter(id => id !== tokenIdNumber);
    } else {
        selectedTokens.push(tokenIdNumber);
      }
      
      renderTokens();
      updateSelectedUI();
    }

    // Update UI to reflect selected tokens
    function updateSelectedUI() {
      const count = selectedTokens.length;
      const syncBtn = document.getElementById('syncBtn');
      const updateVersionBtn = document.getElementById('updateVersionBtn');
      const selectionInfo = document.getElementById('selection-info');
      const noSelectionMessage = document.getElementById('no-selection-message');
      const selectedCount = document.getElementById('selectedCount');
      const selectedTokensList = document.getElementById('selectedTokensList');
      
      // Update the sync button
      if (syncBtn) {
        syncBtn.textContent = `Sync Ownership (${count} selected)`;
        syncBtn.disabled = count === 0;
      }
      
      // Update the change version button
      if (updateVersionBtn) {
        updateVersionBtn.disabled = count === 0;
      }
      
      // Update the selection display
      if (selectionInfo && noSelectionMessage && selectedCount && selectedTokensList) {
        if (count > 0) {
          selectionInfo.style.display = 'block';
          noSelectionMessage.style.display = 'none';
          selectedCount.textContent = count;
          
          // Generate badges for selected tokens
          selectedTokensList.innerHTML = '';
          selectedTokens.forEach(tokenId => {
            const badge = document.createElement('span');
            badge.className = 'token-badge';
            badge.textContent = `#${tokenId}`;
            selectedTokensList.appendChild(badge);
          });
        } else {
          selectionInfo.style.display = 'none';
          noSelectionMessage.style.display = 'block';
        }
      }
    }

    // Select/deselect all tokens
    function selectAllTokens() {
    if (selectedTokens.length === ownedTokens.length) {
      // If all are selected, deselect all
        selectedTokens = [];
    } else {
      // Otherwise, select all
        selectedTokens = ownedTokens.map(token => token.id);
    }
      
      renderTokens();
      updateSelectedUI();
    }

  // Sync ownership for selected tokens
    async function syncSelectedTokens() {
      setLoading(true);
    
    try {
      if (selectedTokens.length === 0) {
        throw new Error("Please select at least one token to sync");
      }
      
      // Make sure we're using a contract connected to a signer
      const tx = await pocketAdriansContract.syncMultipleTokens(selectedTokens);
      await tx.wait();
      
        showSuccess(`Successfully synced ${selectedTokens.length} tokens!`);
      
      // Reload tokens to get updated status
        await loadOwnedTokens(account);
      
    } catch (error) {
      console.error("Error syncing tokens:", error);
        showError(error.message || "Failed to sync token ownership. Please try again.");
    } finally {
        setLoading(false);
    }
    }

  // Change version for selected tokens
    async function changeTokenVersions() {
      setLoading(true);
    
    try {
      if (selectedTokens.length === 0) {
        throw new Error("Please select at least one token to update");
      }
      
        const versionId = parseInt(versionSelector.value);
        
        // Make sure we're using a contract connected to a signer
        // Usar opciones explícitas para evitar problemas de estimación de gas en móviles
        const options = {
          gasLimit: 50000 + (selectedTokens.length * 5000), // Base muy reducida basada en tx exitosa (~40k)
          maxPriorityFeePerGas: ethers.utils.parseUnits("0.01", "gwei"), // Valor similar a la tx exitosa
          maxFeePerGas: ethers.utils.parseUnits("0.02", "gwei") // Ligeramente mayor que la tx exitosa
        };
        
        showSuccess("Preparando transacción...");
        
        // Usar las opciones explícitas de gas
        const tx = await pocketAdriansContract.setTokensVersion(selectedTokens, versionId, options);
        
        showSuccess("Transacción enviada. Esperando confirmación...");
        
        // Aumentar el timeout para móviles
        await tx.wait(1); // Esperar solo 1 confirmación para acelerar en móviles
      
        showSuccess(`Successfully updated ${selectedTokens.length} tokens to version ${versionId}!`);
      
      // Reload tokens to get updated versions
        await loadOwnedTokens(account);
      
    } catch (error) {
        console.error("Error changing versions:", error);
        if (error.message && error.message.includes("gas")) {
          showError("Error de gas: intenta seleccionar menos tokens a la vez o inténtalo de nuevo más tarde");
        } else {
          showError(error.message || "Failed to update token versions. Please try again.");
        }
    } finally {
        setLoading(false);
      }
    }

    // Función para previsualizar la siguiente versión
    async function previewNextVersion(tokenId, imgElement) {
      tokenId = Number(tokenId);
      if (!versions || versions.length === 0) {
        showError("No hay versiones disponibles para previsualizar");
        return;
      }
      
      const currentVersion = Number(imgElement.dataset.version) || 0;
      
      // Encontrar el índice de la versión actual en el array de versiones disponibles
      let currentIndex = versions.findIndex(v => v.id === currentVersion);
      
      // Si no se encuentra o es la última, volver a la primera
      if (currentIndex === -1 || currentIndex === versions.length - 1) {
        currentIndex = 0;
    } else {
        currentIndex++;
      }
      
      // Obtener la siguiente versión
      const nextVersion = versions[currentIndex].id;
      
      // Determinar la ruta base según la versión
      let basePath;
      if (nextVersion === 1) {
        basePath = '/market/halfxadrianimages/';
      } else if (nextVersion === 2) {
        basePath = '/market/alpha/';
      } else if (nextVersion === 3) {
        basePath = '/market/omega/';
      } else {
        basePath = '/market/halfxadrianimages/';
      }
      
      // Intentar cargar la nueva imagen
      const placeholderUrl = '/market/halfxadrianimages/placeholder.jpg';
      
      // Mostrar un indicador de carga
      const parentContainer = imgElement.parentElement;
      const loadingIndicator = document.createElement('div');
      loadingIndicator.style.position = 'absolute';
      loadingIndicator.style.top = '50%';
      loadingIndicator.style.left = '50%';
      loadingIndicator.style.transform = 'translate(-50%, -50%)';
      loadingIndicator.innerHTML = '<div class="spinner-border text-primary" role="status"><span class="visually-hidden">Cargando...</span></div>';
      parentContainer.appendChild(loadingIndicator);
      
      const knownGifs = [1, 13, 69, 221, 369, 420, 555, 690, 777, 807, 1000];
      let formats = [];
      
      if (knownGifs.includes(tokenId)) {
        formats = [
          { extension: 'gif', prefix: '' },
          { extension: 'png', prefix: '' },
          { extension: 'jpg', prefix: '' },
          { extension: 'gif', prefix: 'adrianpunks#' },
          { extension: 'png', prefix: 'adrianpunks#' },
          { extension: 'jpg', prefix: 'adrianpunks#' },
          { extension: 'gif', prefix: 'AdrianPunks#' },
          { extension: 'png', prefix: 'AdrianPunks#' },
          { extension: 'jpg', prefix: 'AdrianPunks#' }
        ];
      } else {
        formats = [
          { extension: 'jpg', prefix: '' },
          { extension: 'png', prefix: '' },
          { extension: 'gif', prefix: '' },
          { extension: 'jpg', prefix: 'adrianpunks#' },
          { extension: 'png', prefix: 'adrianpunks#' },
          { extension: 'gif', prefix: 'adrianpunks#' },
          { extension: 'jpg', prefix: 'AdrianPunks#' },
          { extension: 'png', prefix: 'AdrianPunks#' },
          { extension: 'gif', prefix: 'AdrianPunks#' }
        ];
      }
      
      // Si estamos en la versión 1 (halfxadrianimages), solo intentamos jpg
      if (basePath.includes('halfxadrianimages')) {
        const newImage = new Image();
        newImage.src = `${basePath}${tokenId}.jpg`;
        newImage.onload = function() {
          // Actualizar la imagen existente
          imgElement.src = newImage.src;
          imgElement.dataset.version = nextVersion;
          // Mostrar notificación
          showSuccess(`Previsualizando versión ${nextVersion}`);
          // Eliminar indicador de carga
          parentContainer.removeChild(loadingIndicator);
        };
        newImage.onerror = function() {
          showError(`No se pudo cargar la previsualización de la versión ${nextVersion}`);
          parentContainer.removeChild(loadingIndicator);
        };
        return;
      }
      
      // Función para intentar cargar formatos consecutivamente
      let currentFormatIndex = 0;
      
      function tryNextImageFormat() {
        if (currentFormatIndex >= formats.length) {
          // Si hemos agotado todos los formatos, mostrar error
          showError(`No se pudo cargar la previsualización de la versión ${nextVersion}`);
          parentContainer.removeChild(loadingIndicator);
          return;
        }
        
        const format = formats[currentFormatIndex];
        currentFormatIndex++;
        
        const newImage = new Image();
        const imgSrc = `${basePath}${format.prefix}${tokenId}.${format.extension}`;
        newImage.src = imgSrc;
        
        newImage.onload = function() {
          // Actualizar la imagen existente
          imgElement.src = newImage.src;
          imgElement.dataset.version = nextVersion;
          // Mostrar notificación
          showSuccess(`Previsualizando versión ${nextVersion}`);
          // Eliminar indicador de carga
          parentContainer.removeChild(loadingIndicator);
        };
        
        newImage.onerror = function() {
          tryNextImageFormat();
        };
      }
      
      // Iniciar el intento de carga
      tryNextImageFormat();
    }

    // Event Listeners
    document.addEventListener('DOMContentLoaded', function() {
      loadSavedTheme();
      setupMainConnectButton();
      
      // Connect wallet button
      const connectBtn = document.getElementById('connectWalletBtn');
      if (connectBtn) {
        connectBtn.addEventListener('click', connectWallet);
      }
      
      // Select all button
      const selectAllBtn = document.getElementById('selectAllBtn');
      if (selectAllBtn) {
        selectAllBtn.addEventListener('click', selectAllTokens);
      }
      
      // Sync button
      const syncBtn = document.getElementById('syncBtn');
      if (syncBtn) {
        syncBtn.addEventListener('click', syncSelectedTokens);
      }
      
      // Update Version button
      const updateVersionBtn = document.getElementById('updateVersionBtn');
      if (updateVersionBtn) {
        updateVersionBtn.addEventListener('click', changeTokenVersions);
      }
      
      // Version selector
      const versionSelector = document.getElementById('versionSelector');
      if (versionSelector) {
        versionSelector.addEventListener('change', function() {
          selectedVersion = parseInt(this.value);
        });
      }
      
      // Initialize
      updateSelectedUI();
    });

    // Add styles for images
    const styleSheet = document.createElement("style");
    styleSheet.textContent = `
      .token-image-container {
        width: 100%;
        aspect-ratio: 1/1;
        overflow: hidden;
        border-radius: 4px;
        background-color: #f0f0f0;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      
      .token-image {
        width: 100%;
        height: 100%;
        object-fit: contain;
        display: block;
      }

      .token-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
        gap: 1rem;
        padding: 1rem;
      }

      @media (max-width: 768px) {
        .token-grid {
          grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
        }
      }
    `;
    document.head.appendChild(styleSheet);

    // Check if wallet is already connected when page loads
    window.addEventListener('load', async () => {
      try {
        if (window.ethereum) {
          const accounts = await window.ethereum.request({ method: 'eth_accounts' });
          if (accounts.length > 0) {
            console.log("Wallet found, connecting automatically...");
            await connectWallet();
          }
        }
      } catch (error) {
        console.error("Error checking wallet:", error);
      }
    });

    // Actualizar el balance de tokens
    async function updateTokenBalance() {
      try {
        if (!signer || !account) return;
        
        // Initialize token contract
        const TOKEN_ABI = ["function balanceOf(address account) view returns (uint256)"];
        const TOKEN_ADDRESS = "0x7E99075Ce287F1cF8cBCAaa6A1C7894e404fD7Ea";
        const tokenContract = new ethers.Contract(TOKEN_ADDRESS, TOKEN_ABI, signer);
        
        const balanceRaw = await tokenContract.balanceOf(account);
        const balance = parseFloat(ethers.utils.formatUnits(balanceRaw, 18));
        let formattedBalance = balance >= 1000000 ? (balance / 1000000).toFixed(1) + 'M' :
                              balance >= 1000 ? (balance / 1000).toFixed(1) + 'K' :
                              balance.toFixed(1);
        
        document.getElementById("tokenBalance").innerText = `Balance: ${formattedBalance} $ADRIAN`;
      } catch (error) {
        console.error("Error fetching token balance:", error);
        document.getElementById("tokenBalance").innerText = "Balance: Error";
      }
    }
    
    // Función para cambiar el tema
    function toggleTheme() {
      const html = document.documentElement;
      const themeButton = document.getElementById('themeButton');
      const themeButtonText = document.getElementById('themeButtonText');
      const isDark = html.getAttribute('data-theme') === 'dark';
      
      if (!isDark) {
        html.setAttribute('data-theme', 'dark');
        localStorage.setItem('theme', 'dark');
        themeButtonText.textContent = 'LightMode';
        themeButton.classList.remove('btn-outline-dark');
        themeButton.classList.add('btn-dark');
      } else {
        html.removeAttribute('data-theme');
        localStorage.setItem('theme', 'light');
        themeButtonText.textContent = 'DarkMode';
        themeButton.classList.remove('btn-dark');
        themeButton.classList.add('btn-secondary');
      }
    }
    
    // Cargar el tema guardado
    function loadSavedTheme() {
      const savedTheme = localStorage.getItem('theme');
      const html = document.documentElement;
      const themeButton = document.getElementById('themeButton');
      const themeButtonText = document.getElementById('themeButtonText');
      
      if (savedTheme === 'dark') {
        html.setAttribute('data-theme', 'dark');
        themeButtonText.textContent = 'LightMode';
        themeButton.classList.remove('btn-outline-dark');
        themeButton.classList.add('btn-dark');
      } else {
        themeButtonText.textContent = 'DarkMode';
        themeButton.classList.remove('btn-dark');
        themeButton.classList.add('btn-secondary');
      }
    }
    
    // Configurar el botón principal de wallet
    function setupMainConnectButton() {
      const mainWalletButton = document.getElementById('mainConnectWalletButton');
      if (mainWalletButton) {
        // Si ya existe un método de conexión, usemos ese
        mainWalletButton.addEventListener('click', function() {
          connectWallet();
        });
      }
    }
    
    // Función para mostrar notificaciones
    function showToast(message, type = 'info') {
      // Eliminar cualquier toast anterior
      const oldToast = document.getElementById('customToast');
      if (oldToast) {
        oldToast.remove();
      }
      
      // Crear el nuevo toast
      const toast = document.createElement('div');
      toast.id = 'customToast';
      toast.className = `toast-notification ${type}`;
      toast.textContent = message;
      
      // Agregar estilos al toast
      toast.style.position = 'fixed';
      toast.style.bottom = '20px';
      toast.style.left = '50%';
      toast.style.transform = 'translateX(-50%)';
      toast.style.padding = '10px 20px';
      toast.style.borderRadius = '4px';
      toast.style.backgroundColor = type === 'error' ? '#f44336' : '#4CAF50';
      toast.style.color = 'white';
      toast.style.boxShadow = '0 2px 4px rgba(0,0,0,0.2)';
      toast.style.zIndex = '9999';
      toast.style.opacity = '0';
      toast.style.transition = 'opacity 0.3s ease-in-out';
      
      // Añadir al DOM
      document.body.appendChild(toast);
      
      // Mostrar y ocultar automáticamente
      setTimeout(() => {
        toast.style.opacity = '1';
      }, 100);
      
      setTimeout(() => {
        toast.style.opacity = '0';
        setTimeout(() => {
          toast.remove();
        }, 300);
      }, 3000);
    }
    
    // Funciones para redireccionamiento
    function openFloorOfferPopup() {
      window.location.href = '/market/?action=floorOffer';
    }
    
    function openMyOffersModal() {
      window.location.href = '/market/?action=myOffers';
    }
    
    function openMyListingsModal() {
      window.location.href = '/market/?action=myListings';
    }
    
    function openRecentActivityModal() {
      window.location.href = '/market/?action=recentActivity';
    }
    
    function openMyTokensModal() {
      window.location.href = '/market/?action=myTokens';
    }
  </script>
</body>
</html>