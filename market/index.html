<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AdrianPunks Market v3.12</title>
  <link rel="icon" type="image/x-icon" href="favicon.ico">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
  <link rel="stylesheet" href="/market/styles.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css">
  <style>
    /* Estilos base */
    :root {
      --bg-color: #ffffff;
      --text-color: #333333;
      --card-bg: #ffffff;
      --border-color: #dee2e6;
      --modal-bg: #ffffff;
      --modal-header-bg: #f8f9fa;
      --dropdown-bg: #ffffff;
      --dropdown-text: #333333;
      --badge-bg: #007bff;
      --badge-text: #ffffff;
      --list-group-bg: #ffffff;
      --list-group-text: #333333;
      --list-group-border: #dee2e6;
    }

    /* Estilos dark mode */
    [data-theme="dark"] {
      --bg-color: #1a1a1a;
      --text-color: #ffffff;
      --card-bg: #2d2d2d;
      --border-color: #404040;
      --modal-bg: #2d2d2d;
      --modal-header-bg: #1a1a1a;
      --dropdown-bg: #2d2d2d;
      --dropdown-text: #ffffff;
      --badge-bg: #0d6efd;
      --badge-text: #ffffff;
      --list-group-bg: #2d2d2d;
      --list-group-text: #ffffff;
      --list-group-border: #404040;
      --modal-text: #ffffff;
      --modal-border: #404040;
      --modal-input-bg: #1a1a1a;
      --modal-input-text: #ffffff;
      --modal-input-border: #404040;
    }

    body {
      background-color: var(--bg-color);
      color: var(--text-color);
    }

    .container {
      background-color: var(--bg-color);
    }

    .card {
      background-color: var(--card-bg);
      border-color: var(--border-color);
      color: var(--text-color);
    }

    .card-title, .card-text {
      color: var(--text-color);
    }

    .text-muted {
      color: #a0a0a0 !important;
    }

    .modal-content {
      background-color: var(--modal-bg);
      color: var(--modal-text);
      border-color: var(--modal-border);
    }

    .modal-header {
      background-color: var(--modal-header-bg);
      border-bottom-color: var(--modal-border);
    }

    .modal-body {
      background-color: var(--modal-bg);
      color: var(--modal-text);
    }

    .modal-footer {
      background-color: var(--modal-bg);
      border-top-color: var(--modal-border);
    }

    .form-control {
      background-color: var(--modal-input-bg);
      color: var(--modal-input-text);
      border-color: var(--modal-input-border);
    }

    .form-control:focus {
      background-color: var(--modal-input-bg);
      color: var(--modal-input-text);
      border-color: var(--modal-input-border);
    }

    .dropdown-menu {
      background-color: var(--dropdown-bg);
      color: var(--dropdown-text);
    }

    .badge {
      background-color: var(--badge-bg);
      color: var(--badge-text);
    }

    .list-group-item {
      background-color: var(--list-group-bg);
      color: var(--list-group-text);
      border-color: var(--list-group-border);
    }

    /* Estilos del switch */
    .theme-switch {
      position: fixed;
      bottom: 20px;
      right: 20px;
      z-index: 1000;
      background-color: var(--card-bg);
      padding: 8px 12px;
      border-radius: 20px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    }

    .theme-switch .form-check-input {
      cursor: pointer;
    }

    .theme-switch .form-check-label {
      color: var(--text-color);
      cursor: pointer;
      margin-left: 8px;
    }

    /* Mantener los estilos existentes */
    #tokenBalance {
      margin-top: 10px;
    }
    @media (max-width: 768px) {
      #tokenBalance {
        margin-top: 70px;
      }
      .card-title {
        font-size: 1rem;
        line-height: 1.2;
        margin-bottom: 0.25rem;
      }
      .nft-card .card-body {
        padding: 0.5rem;
      }
      .nft-card .card-text {
        font-size: 0.85rem;
      }
      .action-btn {
        font-size: 0.9rem;
        padding: 0.4rem 0.6rem;
      }
      .action-btn.dropdown-toggle::after {
        margin-left: 0.3rem;
      }
    }
    .modal-dialog {
      max-width: 500px;
    }
    .modal-body img {
      max-width: 300px;
      margin: 0 auto;
      display: block;
    }
    /* Asegurar que el backdrop se elimine correctamente */
    .modal-backdrop {
      opacity: 0.5;
    }
    body.modal-open {
      overflow: auto !important;
      padding-right: 0 !important;
    }
    .offer-form {
      transition: all 0.3s ease;
      opacity: 1;
      transform: translateY(0);
    }
    .offer-form.hiding {
      opacity: 0;
      transform: translateY(-10px);
    }
    .modal-body {
      max-height: 80vh;
      overflow-y: auto;
      scroll-behavior: smooth;
    }
    .trait-info {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .badge {
      font-size: 0.9em;
      padding: 8px 12px;
    }
    .trait-categories {
      max-height: 400px;
      overflow-y: auto;
      padding-right: 10px;
    }
    .trait-category {
      margin-bottom: 1rem;
    }
    .trait-category-title {
      font-size: 0.9rem;
      font-weight: 600;
      color: #333;
    }
    .trait-values {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
      gap: 0.5rem;
    }
    .trait-value-item button {
      font-size: 0.8rem;
      padding: 0.25rem 0.5rem;
    }
    #activeFilters {
      margin-bottom: 1rem;
    }
    #activeFilters .badge {
      font-size: 0.8rem;
      padding: 0.35rem 0.65rem;
    }
    #traitFilterMenu {
      max-height: 80vh;
      overflow-y: auto;
    }
  </style>
  <!-- Load ethers.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/5.7.2/ethers.umd.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
</head>
<body>
  <!-- Include the menu -->
  <div id="menu-container"></div>
  <script>
    // Load the menu with relative path
    fetch('components/menu.html')
      .then(response => response.text())
      .then(html => {
        document.getElementById('menu-container').innerHTML = html;
        
        // Asegurar que el men칰 tenga el estilo correcto
        const menu = document.querySelector('.navbar');
        if (menu) {
          menu.classList.add('navbar-dark', 'bg-dark');
        }
        
        // Verificar si el script ya ha sido cargado para evitar duplicaci칩n
        if (!document.querySelector('script[src="components/menu.js"]')) {
          const script = document.createElement('script');
          script.src = 'components/menu.js';
          script.onload = function() {
            // Esperar un momento para que el script se inicialice completamente
            setTimeout(() => {
              // Intentar configurar los event listeners manualmente
              if (typeof window.connectMetaMaskWallet === 'function') {
                const mobileButton = document.getElementById('connectWalletButtonMobile');
                const desktopButton = document.getElementById('connectWalletButton');
                
                if (mobileButton) {
                  mobileButton.addEventListener('click', function(e) {
                    e.preventDefault();
                    console.log("Mobile button clicked from index.html");
                    window.connectMetaMaskWallet();
                  });
                }
                
                if (desktopButton) {
                  desktopButton.addEventListener('click', function(e) {
                    e.preventDefault();
                    console.log("Desktop button clicked from index.html");
                    window.connectMetaMaskWallet();
                  });
                }
              }
            }, 500);
          };
          document.head.appendChild(script);
        }
      })
      .catch(error => console.error('Error loading menu:', error));
  </script>

  <!-- Main Container -->
  <div class="container">
    <!-- Balance Info -->
    <div class="info-section mb-4">
      <h2 id="tokenBalance" class="mb-2">Balance: Loading...</h2>
    </div>

    <!-- Botonera Principal Unificada -->
    <div class="main-actions mb-4">
      <div class="action-buttons">
        <button class="action-btn secondary" onclick="openMyListingsModal()">
          <span class="d-none d-md-inline">My</span> Listings
        </button>
        <button class="action-btn dark" onclick="openRecentActivityModal()">
          <span class="d-none d-md-inline">Recent</span> Activity
        </button>
        <div class="dropdown">
          <button class="action-btn primary dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false">
            <span>Traits</span>
          </button>
          <ul class="dropdown-menu p-3" id="traitFilterMenu">
            <div class="d-flex justify-content-between mb-2">
              <button class="btn btn-sm btn-danger me-2" onclick="clearTraitFilters()">Clear Filters</button>
              <span class="text-muted" id="filteredCount"></span>
            </div>
            <div id="activeFilters" class="mb-2"></div>
            <div class="trait-categories" id="traitCategories">
              <!-- Categor칤as de traits se cargar치n din치micamente -->
            </div>
          </ul>
        </div>
        <button class="action-btn outline" onclick="filterByActiveListings()">
          <span class="d-none d-md-inline">Listed</span><span class="d-md-none">Listed</span>
        </button>
        <button class="action-btn outline" onclick="sortByFloorPrice()">
          <span class="d-none d-md-inline">Sort by FP</span><span class="d-md-none">Sort FP</span>
        </button>
        <div class="dropdown">
          <button class="action-btn warning dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" onclick="updateSweepFloorInfo()">
            <span>游 Sweep Floor</span>
          </button>
          <ul class="dropdown-menu p-3" id="sweepFloorMenu" style="min-width: 300px;">
            <h6 class="dropdown-header">FloorEngine Sweep</h6>
            <div id="sweepFloorInfo" class="mb-3">
              <p class="text-muted mb-0">Loading...</p>
            </div>
            <button id="sweepFloorBtn" class="btn btn-warning w-100" onclick="sweepFloor()">Execute Sweep</button>
          </ul>
        </div>
        <button class="action-btn outline" onclick="openMyTokensModal()">
          <span class="d-none d-md-inline">My</span> Tokens
        </button>
        <button class="action-btn" id="themeButton" onclick="toggleTheme()">
          <span id="themeButtonText">DarkMode</span>
        </button>
        <!-- Bot칩n para cambiar entre colecciones de im치genes -->
        <button class="action-btn" id="collectionToggleButton" onclick="toggleImageCollection()">
          <span id="collectionToggleText">HalfxAdrian</span>
        </button>
        <!-- Nuevo bot칩n de wallet para la botonera principal -->
        <button class="action-btn outline" id="mainConnectWalletButton">
          Connect Wallet
        </button>
      </div>
    </div>

    <!-- NFT Grid -->
    <div class="nft-grid" id="nftGrid"></div>
  </div>

  <!-- Modal para NFT Details -->
  <div class="modal fade" id="nftModal" tabindex="-1" aria-labelledby="nftModalLabel" aria-hidden="true" data-bs-backdrop="static">
    <div class="modal-dialog modal-dialog-centered">
      <div class="modal-content" id="nftModalContent">
        <!-- Contenido cargado din치micamente -->
      </div>
    </div>
  </div>

  <!-- Modal for My Offers -->
  <div class="modal fade" id="myOffersModal" tabindex="-1" aria-labelledby="myOffersModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered modal-xl">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title" id="myOffersModalLabel">My Active Offers</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body">
          <!-- Tabs: Token, Floor y Trait -->
          <ul class="nav nav-tabs mb-3 d-flex" id="offersTab" role="tablist">
            <li class="nav-item flex-equal" role="presentation">
              <button class="nav-link active w-100" id="token-offers-tab" data-bs-toggle="tab" data-bs-target="#token-offers" type="button" role="tab">
                Token
              </button>
            </li>
            <li class="nav-item flex-equal" role="presentation">
              <button class="nav-link w-100" id="floor-offers-tab" data-bs-toggle="tab" data-bs-target="#floor-offers" type="button" role="tab">
                Floor
              </button>
            </li>
            <li class="nav-item flex-equal" role="presentation">
              <button class="nav-link w-100" id="trait-offers-tab" data-bs-toggle="tab" data-bs-target="#trait-offers" type="button" role="tab">
                Trait
              </button>
            </li>
          </ul>
          
          <style>
            .flex-equal {
              flex: 1 1 0;
            }
            #offersTab .nav-link {
              padding: 0.5rem;
              text-align: center;
              white-space: nowrap;
              color: #333;
              background-color: #e9ecef;
              border: 1px solid #dee2e6;
              margin: 0 2px;
              font-size: 0.9rem;
            }
            #offersTab .nav-link.active {
              background-color: #007bff;
              color: white;
              border-color: #007bff;
            }
            #offersTab .nav-link:hover {
              background-color: #dde2e6;
              color: #333;
            }
            #offersTab .nav-link.active:hover {
              background-color: #0069d9;
              color: white;
            }
            @media (max-width: 768px) {
              #offersTab .nav-link {
                font-size: 0.8rem;
                padding: 0.4rem;
              }
            }
          </style>

          <!-- Contenido de los tabs -->
          <div class="tab-content" id="offersTabContent">
            <!-- Token Offers -->
            <div class="tab-pane fade show active" id="token-offers" role="tabpanel">
              <div id="tokenOffersContent">
                <div class="text-center">
                  <div class="spinner-border text-primary" role="status">
                    <span class="visually-hidden">Loading...</span>
                  </div>
                </div>
              </div>
            </div>
            <!-- Floor Offers -->
            <div class="tab-pane fade" id="floor-offers" role="tabpanel">
              <div id="floorOffersContent">
                <div class="text-center">
                  <div class="spinner-border text-primary" role="status">
                    <span class="visually-hidden">Loading...</span>
                  </div>
                </div>
              </div>
            </div>
            <!-- Trait Offers -->
            <div class="tab-pane fade" id="trait-offers" role="tabpanel">
              <div id="traitOffersContent">
                <div class="text-center">
                  <div class="spinner-border text-primary" role="status">
                    <span class="visually-hidden">Loading...</span>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Modal for My Listings -->
  <div class="modal fade" id="myListingsModal" tabindex="-1" aria-labelledby="myListingsModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title" id="myListingsModalLabel">My Listings</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body" id="myListingsContent">
          <!-- Listado de mis listados -->
        </div>
      </div>
    </div>
  </div>

  <!-- Modal for Recent Activity -->
  <div class="modal fade" id="recentActivityModal" tabindex="-1" aria-labelledby="recentActivityModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered modal-lg">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title" id="recentActivityModalLabel">Recent Activity</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body" id="recentActivityContent">
          <!-- Datos de actividad reciente se inyectan aqu칤 -->
        </div>
      </div>
    </div>
  </div>

  <!-- Modal for Floor Offer Popup -->
  <div class="modal fade" id="floorOfferPopupModal" tabindex="-1" aria-labelledby="floorOfferPopupModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title" id="floorOfferPopupModalLabel">Make Floor Offer for the Collection</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body" id="floorOfferPopupContent">
          <div id="floorOfferForm">
            <label>Offer Amount (in $ADRIAN): 
              <input type="text" id="popupOfferAmount" value="10000" class="form-control">
            </label>
            <button class="btn btn-primary mt-2" onclick="makeFloorOfferPopup()">Submit Floor Offer</button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Modal for My Tokens -->
  <div class="modal fade" id="myTokensModal" tabindex="-1" aria-labelledby="myTokensModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered modal-lg">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title" id="myTokensModalLabel">My Tokens</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body" id="myTokensModalContent">
          <div class="text-center">
            <div class="spinner-border text-primary" role="status">
              <span class="visually-hidden">Loading...</span>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Bootstrap JS -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
  
  <!-- Main Script: NFT loading and Contract Interactions -->
  <script>
    /*********** Global Variables and Contract Setup ***********/
    const INFURA_URL = "https://base-mainnet.infura.io/v3/cc0c8013b1e044dcba79d4f7ec3b2ba1";
    const CHAIN_ID = 8453;

    let nftData = [];
    // Usar las variables existentes si ya fueron definidas por el men칰
    if (typeof window.provider === 'undefined') window.provider = null;
    if (typeof window.signer === 'undefined') window.signer = null;
    if (typeof window.userAccount === 'undefined') window.userAccount = null;
    
    // Referencias locales a las variables globales
    let provider = window.provider;
    let signer = window.signer;
    let userAccount = window.userAccount;
    
    let tokenContract, nftContract, floorEngineContract, multicallContract;
    let readProvider; // Provider de Alchemy para lecturas
    let tokenReadContract, nftReadContract, floorEngineReadContract, multicallReadContract;

    // Direcciones de contratos y ABIs
    const TOKEN_ADDRESS  = "0x7E99075Ce287F1cF8cBCAaa6A1C7894e404fD7Ea"; // $ADRIAN
    const NFT_ADDRESS    = "0x79BE8AcdD339C7b92918fcC3fd3875b5Aaad7566"; // AdrianPunks
    const FLOOR_ENGINE_ADDRESS = "0x0351F7cBA83277E891D4a85Da498A7eACD764D58"; // FloorEngine
    const MULTICALL3_ADDRESS = "0xcA11bde05977b3631167028862bE2a173976CA11"; // Multicall3 on Base

    // Alchemy API Configuration for faster token loading
    const ALCHEMY_API_KEY = "5qIXA1UZxOAzi8b9l0nrYmsQBO9-W7Ot";
    const ALCHEMY_RPC_URL = `https://base-mainnet.g.alchemy.com/v2/${ALCHEMY_API_KEY}`;

    // Variables para manejar las rutas de imagen
    let currentImageCollection = 'adrianpunks'; // Por defecto
    // Array para rotar entre las colecciones disponibles en el orden correcto
    const availableCollections = ['adrianpunks', 'halfxadrian', 'vectoradrians', 'adrianvectors'];

    // FloorEngine ABI
    const FLOOR_ENGINE_ABI = [
      // Events
      "event Listed(uint256 indexed tokenId, address indexed seller, uint256 price, bool isContractOwned)",
      "event Cancelled(uint256 indexed tokenId, address indexed seller)",
      "event Bought(uint256 indexed tokenId, address indexed buyer, address indexed seller, uint256 price, bool isContractOwned)",
      "event FloorSweep(uint256 indexed tokenId, uint256 buyPrice, uint256 relistPrice, address indexed caller, uint256 callerReward)",
      "event PremiumUpdated(uint16 oldPremiumBps, uint16 newPremiumBps)",
      "event MaxBuyPriceUpdated(uint256 oldMaxBuyPrice, uint256 newMaxBuyPrice)",
      
      // Main functions
      "function list(uint256 tokenId, uint256 price) external",
      "function cancel(uint256 tokenId) external",
      "function buy(uint256 tokenId) external",
      "function sweepFloorWithBalance() external",
      
      // View functions
      "function listings(uint256 tokenId) external view returns (address seller, uint256 price, bool isContractOwned)",
      "function isListed(uint256 tokenId) external view returns (bool)",
      "function getListedTokenIds() external view returns (uint256[])",
      "function getListedCount() external view returns (uint256)",
      "function token() external view returns (address)",
      "function collection() external view returns (address)",
      "function premiumBps() external view returns (uint16)",
      "function maxBuyPrice() external view returns (uint256)",
      "function callerRewardBps() external view returns (uint16)",
      "function callerRewardFixed() external view returns (uint256)",
      "function callerRewardIsPercentage() external view returns (bool)",
      
      // Admin functions
      "function setPremiumBps(uint16 newPremiumBps) external",
      "function setMaxBuyPrice(uint256 newMaxBuyPrice) external",
      "function setCallerRewardBps(uint16 bps) external",
      "function setCallerRewardFixed(uint256 amount) external",
      "function rescueERC721(address to, uint256 tokenId) external",
      "function rescueERC20(address tokenAddress, address to, uint256 amount) external",
      "function owner() external view returns (address)"
    ];

    // Multicall3 ABI
    const MULTICALL3_ABI = [
      "function aggregate3(tuple(address target, bool allowFailure, bytes callData)[] calls) external payable returns (tuple(bool success, bytes returnData)[] returnData)"
    ];

    const TOKEN_ABI = [
      "function balanceOf(address account) view returns (uint256)",
      "function approve(address spender, uint256 amount) external returns (bool)",
      "function allowance(address owner, address spender) view returns (uint256)"
    ];
    const NFT_ABI = [
      "function tokenURI(uint256 tokenId) view returns (string)",
      "function ownerOf(uint256 tokenId) view returns (address)",
      "function getApproved(uint256 tokenId) view returns (address)",
      "function approve(address to, uint256 tokenId) external",
      "function isApprovedForAll(address owner, address operator) view returns (bool)",
      "function setApprovalForAll(address operator, bool approved) external",
      "function balanceOf(address owner) view returns (uint256)",
      "function tokenOfOwnerByIndex(address owner, uint256 index) view returns (uint256)",
      "function totalMinted() view returns (uint256)"
    ];
    
    async function initContracts() {
      // Configurar el provider de Alchemy para lecturas
      readProvider = new ethers.providers.JsonRpcProvider(ALCHEMY_RPC_URL, {
        name: "base",
        chainId: 8453
      });

      // Inicializar contratos de solo lectura
      tokenReadContract = new ethers.Contract(TOKEN_ADDRESS, TOKEN_ABI, readProvider);
      nftReadContract = new ethers.Contract(NFT_ADDRESS, NFT_ABI, readProvider);
      floorEngineReadContract = new ethers.Contract(FLOOR_ENGINE_ADDRESS, FLOOR_ENGINE_ABI, readProvider);
      multicallReadContract = new ethers.Contract(MULTICALL3_ADDRESS, MULTICALL3_ABI, readProvider);

      if (window.ethereum) {
        // Usar el provider existente si ya fue definido por el men칰, o crear uno nuevo
        if (!window.provider) {
          window.provider = new ethers.providers.Web3Provider(window.ethereum);
          window.signer = window.provider.getSigner();
          
          try {
            window.userAccount = await window.signer.getAddress();
          } catch (e) {
            console.log("No user connected yet");
          }
        }
        
        // Actualizar las referencias locales
        provider = window.provider;
        signer = window.signer;
        userAccount = window.userAccount;
        
        if (userAccount) {
          tokenContract = new ethers.Contract(TOKEN_ADDRESS, TOKEN_ABI, signer);
          nftContract = new ethers.Contract(NFT_ADDRESS, NFT_ABI, signer);
          floorEngineContract = new ethers.Contract(FLOOR_ENGINE_ADDRESS, FLOOR_ENGINE_ABI, signer);
          multicallContract = new ethers.Contract(MULTICALL3_ADDRESS, MULTICALL3_ABI, signer);
          updateTokenBalance();
        }
      } else {
        console.error("Ethereum provider not found.");
      }
    }
    
    /*********** NFT Data Loading and Display ***********/
    let activeFilters = new Map();
    let allTraits = new Map();
    
    function extractTraits(nfts) {
      allTraits.clear();
      nfts.forEach(nft => {
        if (nft.attributes) {
          nft.attributes.forEach(attr => {
            if (!allTraits.has(attr.trait_type)) {
              allTraits.set(attr.trait_type, new Set());
            }
            allTraits.get(attr.trait_type).add(attr.value);
          });
        }
      });
      return allTraits;
    }
    
    function renderTraitFilters() {
      const container = document.getElementById('traitCategories');
      container.innerHTML = '';
      allTraits.forEach((values, traitType) => {
        const categoryDiv = document.createElement('div');
        categoryDiv.className = 'trait-category mb-3';
        categoryDiv.innerHTML = `
          <h6 class="trait-category-title mb-2">${traitType}</h6>
          <div class="trait-values">
            ${Array.from(values).map(value => `
              <div class="trait-value-item">
                <button class="btn btn-sm ${activeFilters.get(traitType) === value ? 'btn-primary' : 'btn-outline-secondary'} w-100 text-start mb-1"
                  onclick="toggleTraitFilter('${traitType}', '${value}')">
                  ${value}
                </button>
              </div>
            `).join('')}
          </div>
        `;
        container.appendChild(categoryDiv);
      });
      updateActiveFiltersDisplay();
    }
    
    function updateActiveFiltersDisplay() {
      const container = document.getElementById('activeFilters');
      if (activeFilters.size === 0) {
        container.innerHTML = '<small class="text-muted">No active filters</small>';
        return;
      }
      container.innerHTML = Array.from(activeFilters.entries()).map(([type, value]) => `
        <span class="badge bg-primary me-1 mb-1">
          ${type}: ${value}
          <button type="button" class="btn-close btn-close-white" style="font-size: 0.5em;" 
            onclick="removeTraitFilter('${type}')"></button>
        </span>
      `).join('');
    }
    
    function toggleTraitFilter(traitType, value) {
      if (activeFilters.get(traitType) === value) {
        activeFilters.delete(traitType);
      } else {
        activeFilters.set(traitType, value);
      }
      renderTraitFilters();
      filterAndDisplayNFTs();
    }
    
    function removeTraitFilter(traitType) {
      activeFilters.delete(traitType);
      renderTraitFilters();
      filterAndDisplayNFTs();
    }
    
    function clearTraitFilters() {
      activeFilters.clear();
      renderTraitFilters();
      filterAndDisplayNFTs();
    }
    
    function filterAndDisplayNFTs() {
      if (!nftData) return;
      let filteredNFTs = nftData;
      if (activeFilters.size > 0) {
        filteredNFTs = nftData.filter(nft => {
          return Array.from(activeFilters.entries()).every(([type, value]) => {
            return nft.attributes.some(attr => attr.trait_type === type && attr.value === value);
          });
        });
      }
      document.getElementById('filteredCount').textContent = `Showing ${filteredNFTs.length} of ${nftData.length}`;
      displayNFTs(filteredNFTs);
    }
    
    let activeListingsData = [];
    let currentSortOrder = 'asc';
    
    async function loadActiveListings() {
      try {
        // Get all listed token IDs from FloorEngine
        const listedTokenIds = await floorEngineReadContract.getListedTokenIds();
        console.log(`Found ${listedTokenIds.length} listed tokens on FloorEngine`);
        
        // For each listed token, get its listing details
        activeListingsData = [];
        for (const tokenId of listedTokenIds) {
          const listing = await floorEngineReadContract.listings(tokenId);
          activeListingsData.push({
            tokenId: tokenId.toNumber(),
            seller: listing.seller,
            price: listing.price,
            isContractOwned: listing.isContractOwned
          });
        }
        
        console.log("Active listings loaded from FloorEngine:", activeListingsData);
      } catch (error) {
        console.error("Error loading active listings:", error);
        activeListingsData = [];
      }
    }
    
    // MODIFICACI칍N: Filtrar NFTs seg칰n la cantidad minteada
    async function loadNFTs() {
      try {
        if (!window.ethereum) {
          document.getElementById("nftGrid").innerHTML = `
            <div class="col-12 text-center">
              <p class="text-muted">Please install MetaMask to view NFTs</p>
            </div>
          `;
          return;
        }
        if (!userAccount) {
          document.getElementById("nftGrid").innerHTML = `
            <div class="col-12 text-center">
              <p class="text-muted">Please connect your wallet to view NFTs</p>
            </div>
          `;
          return;
        }
        // Consultamos cu치ntos tokens se han minteado hasta el momento
        const mintedCountBN = await nftContract.totalMinted();
        const mintedCount = mintedCountBN.toNumber();
        console.log("Minted count:", mintedCount);

        const response = await fetch('./adrianpunks.json');
        if (!response.ok) throw new Error('Error loading NFTs');
        const data = await response.json();
        // Filtrar para mostrar solo los tokens cuyo ID <= mintedCount
        nftData = (data.collection || []).filter(nft => {
          const tokenIdStr = nft.name.split('#')[1];
          const tokenId = parseInt(tokenIdStr);
          return tokenId <= mintedCount;
        });
        await loadActiveListings();
        extractTraits(nftData);
        renderTraitFilters();
        filterAndDisplayNFTs();
      } catch (error) {
        console.error('Error:', error);
        document.getElementById('nftGrid').innerHTML = `<div class="alert alert-danger">Error loading NFTs: ${error.message}</div>`;
      }
    }
    
    async function displayNFTs(nfts) {
      const grid = document.getElementById('nftGrid');
      grid.innerHTML = '';
      if (!nfts || nfts.length === 0) {
        grid.innerHTML = '<div class="alert alert-info">No NFTs found</div>';
        return;
      }
      
      // Si estamos mostrando la colecci칩n halfxadrian, cargar ese JSON
      let halfxadrianData = null;
      if (currentImageCollection === 'halfxadrian') {
        try {
          const response = await fetch('./halfxadrian.json');
          if (response.ok) {
            const data = await response.json();
            halfxadrianData = data.collection || [];
          }
        } catch (error) {
          console.error('Error loading halfxadrian.json:', error);
        }
      }
      
      nfts.forEach(nft => {
        const tokenId = nft.name.split('#')[1];
        
        // Determinar el nombre a mostrar seg칰n la colecci칩n
        let displayName = nft.name;
        if (currentImageCollection === 'halfxadrian' && halfxadrianData) {
          const halfNft = halfxadrianData.find(n => parseInt(n.name.split('#')[1]) === parseInt(tokenId));
          if (halfNft) {
            displayName = halfNft.name;
          }
        } else if (currentImageCollection === 'vectoradrians') {
          displayName = `VECTORAdrian#${tokenId}`;
        } else if (currentImageCollection === 'adrianvectors') {
          displayName = `ADRIANvector#${tokenId}`;
        }
        
        const listing = activeListingsData.find(l => l.tokenId.toString() === tokenId);
        const card = document.createElement('div');
        card.className = 'card nft-card';
        card.style.cursor = 'pointer';
        card.onclick = () => showNFTDetails(nft.name);
        
        // Formatear el precio para mostrar K o M si es necesario
        const formattedPrice = listing ? 
          (parseFloat(ethers.utils.formatUnits(listing.price, 18)) >= 1000000 ? 
            (parseFloat(ethers.utils.formatUnits(listing.price, 18)) / 1000000).toFixed(1) + 'M' :
            parseFloat(ethers.utils.formatUnits(listing.price, 18)) >= 1000 ? 
            (parseFloat(ethers.utils.formatUnits(listing.price, 18)) / 1000).toFixed(1) + 'K' :
            parseFloat(ethers.utils.formatUnits(listing.price, 18)).toFixed(1)) : '';
        
        // Determinar el badge seg칰n si es del contrato o de usuario
        const badgeHtml = listing ? (listing.isContractOwned ? 
          '<span class="badge bg-primary">ENGINE</span>' : 
          '<span class="badge bg-secondary">USER</span>') : '';

        // Obtener URL de la imagen
        const imgUrl = getImageUrl(nft);
        
        // A침adir atributos de datos para las im치genes de colecciones din치micas
        const dataAttrs = (currentImageCollection === 'vectoradrians' || currentImageCollection === 'adrianvectors') ?
          `` : '';

        card.innerHTML = `
          <img src="${imgUrl}" class="card-img-top" alt="${displayName}" ${dataAttrs}>
          <div class="card-body">
            <h5 class="card-title">${displayName}</h5>
            <p class="card-text">Rarity: ${typeof nft.rarity === 'number' ? nft.rarity.toFixed(2) : 'N/A'}</p>
            ${listing ? `
              <div class="price-tag alert alert-info py-1 px-2 mb-2">
                <small>Listed: ${formattedPrice} $A ${badgeHtml}</small>
              </div>
              <button class="btn btn-primary btn-sm w-100" 
                onclick="event.stopPropagation(); buyToken(${tokenId}, '${listing.price}')"
                style="font-size: 0.8rem;">
                Buy Now
              </button>
            ` : ''}
          </div>
        `;
        grid.appendChild(card);
      });
    }
    
    async function showNFTDetails(nftName) {
      try {
        // Cargar el JSON correspondiente a la colecci칩n actual
        const jsonFile = currentImageCollection === 'adrianpunks' ? './adrianpunks.json' : './halfxadrian.json';
        const data = await fetch(jsonFile).then(response => response.json());
        
        // Obtener el ID del token del nombre
        const tokenId = parseInt(nftName.split('#')[1]);
        
        // Buscar el NFT por su ID en lugar de por su nombre, ya que el nombre puede variar entre colecciones
        const nft = data.collection.find(n => parseInt(n.name.split('#')[1]) === tokenId);
        
        if (!nft) throw new Error("NFT not found");
        
        // Determinar el nombre a mostrar seg칰n la colecci칩n
        let displayName = nft.name;
        if (currentImageCollection === 'vectoradrians') {
          displayName = `VECTORAdrian#${tokenId}`;
        } else if (currentImageCollection === 'adrianvectors') {
          displayName = `ADRIANvector#${tokenId}`;
        }
        
        let ownershipStatus = '';
        let isOwner = false;
        try {
          const owner = await nftContract.ownerOf(tokenId);
          isOwner = owner.toLowerCase() === userAccount.toLowerCase();
          ownershipStatus = isOwner ? `<div class="alert alert-success">You are the owner of this token</div>` : `<div class="alert alert-info">Owner: ${owner.substring(0, 6)}...${owner.substring(38)}</div>`;
        } catch (error) {
          ownershipStatus = `<div class="alert alert-warning">Could not verify token ownership</div>`;
        }
        const activeListings = await newMarketplaceContract.getActiveListingsDetailed();
        const tokenListing = activeListings.find(listing => listing.tokenId.toString() === tokenId.toString() && listing.expirationTime > Math.floor(Date.now() / 1000));
        const tokenOffers = await newMarketplaceContract.getTokenOffersForToken(NFT_ADDRESS, tokenId);
        console.log("Token offers:", tokenOffers);
        const relevantOffers = tokenOffers.filter(offer => offer.exists);
        let floorOffer;
        try {
          floorOffer = await newMarketplaceContract.callStatic.floorOffers(NFT_ADDRESS, 0);
        } catch (e) {
          console.error("Error retrieving floor offer, defaulting to no active offer:", e);
          floorOffer = { offerAmount: ethers.BigNumber.from(0), buyer: "", active: false };
        }
        const modalContent = document.getElementById('nftModalContent');
        modalContent.innerHTML = `
          <div class="modal-header">
            <h5 class="modal-title">${displayName}</h5>
            <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
          </div>
          <div class="modal-body text-center">
            <img src="${getImageUrl(nft)}" class="img-fluid rounded mb-3" alt="${displayName}">
            <div class="nft-details text-start">
              ${ownershipStatus}
              <p><strong>Description:</strong> ${nft.description || 'N/A'}</p>
              <p><strong>Compiler:</strong> ${nft.compiler || 'N/A'}</p>
              <p><strong>Masterminds:</strong> ${nft.masterminds && Array.isArray(nft.masterminds) ? nft.masterminds.join(', ') : 'N/A'}</p>
              <p><strong>Rarity:</strong> ${typeof nft.rarity === 'number' ? nft.rarity.toFixed(2) : 'N/A'}</p>
              ${isOwner ? `
                ${!tokenListing ? `
                  <button class="btn btn-primary w-100 mb-2" onclick="openListingForm('${nft.name}', 'NewAdrianMarket')">
                    List for Sale
                  </button>
                ` : `
                  <div class="listing-info alert alert-info">
                    <h6>Active Listing</h6>
                    <p>Price: ${parseFloat(ethers.utils.formatUnits(tokenListing.price, 18)).toLocaleString('en-US', {minimumFractionDigits: 1, maximumFractionDigits: 1})} $ADRIAN</p>
                    <p>Seller: ${tokenListing.seller.substring(0, 6)}...${tokenListing.seller.substring(38)}</p>
                    <p>Expires: ${new Date(tokenListing.expirationTime * 1000).toLocaleString()}</p>
                    <button class="btn btn-danger btn-sm" onclick="cancelListing(${tokenListing.id})">Cancel Listing</button>
                  </div>
                `}
              ` : ''}
              <div class="offers-section mt-3">
                <h6>Active Offers</h6>
                ${relevantOffers && relevantOffers.length > 0 ? `
                  <div class="list-group">
                    ${relevantOffers.map(offer => `
                      <div class="list-group-item">
                        <p class="mb-1">Offer: ${parseFloat(ethers.utils.formatUnits(offer.offerAmount, 18)).toLocaleString('en-US', {minimumFractionDigits: 1, maximumFractionDigits: 1})} $A</p>
                        <small>By: ${offer.buyer.substring(0, 6)}...${offer.buyer.substring(38)}</small>
                        ${isOwner ? `
                          <button class="btn btn-success btn-sm float-end" 
                            onclick="acceptTokenOffer('${NFT_ADDRESS}', ${tokenId}, ${offer.id})">
                            Accept Offer
                          </button>
                        ` : ''}
                        ${offer.buyer.toLowerCase() === userAccount.toLowerCase() ? `
                          <button class="btn btn-danger btn-sm float-end" 
                            onclick="cancelTokenOffer('${NFT_ADDRESS}', ${tokenId})">
                            Cancel Offer
                          </button>
                        ` : ''}
                      </div>
                    `).join('')}
                  </div>
                ` : `
                  <div class="text-center">
                    <p class="text-muted">No active offers</p>
                  </div>
                `}
                ${floorOffer.offerAmount.gt(0) ? `
                  <div class="floor-offer-info mt-2">
                    <p class="mb-1">Floor Offer: ${parseFloat(ethers.utils.formatUnits(floorOffer.offerAmount, 18)).toLocaleString('en-US', {minimumFractionDigits: 1, maximumFractionDigits: 1})} $A</p>
                    <small>By: ${floorOffer.buyer.substring(0, 6)}...${floorOffer.buyer.substring(38)}</small>
                    ${isOwner ? `
                      <button class="btn btn-success btn-sm" onclick="acceptFloorOffer(${tokenId})">
                        Accept Floor Offer
                      </button>
                    ` : ''}
                  </div>
                ` : ''}
              </div>
              <h6 class="mt-3">Attributes:</h6>
              <ul class="list-group">
                ${nft.attributes && Array.isArray(nft.attributes) ? nft.attributes.map(attr => 
                  `<li class="list-group-item d-flex justify-content-between align-items-center">
                    <div>
                      <strong>${attr.trait_type}:</strong> ${attr.value}
                    </div>
                    <button class="btn btn-sm btn-outline-primary" 
                      onclick="openTraitOfferForm('${attr.trait_type}', '${attr.value}')" 
                      title="Make Trait Offer">
                      游눯
                    </button>
                  </li>`
                ).join('') : '<li class="list-group-item">No attributes found</li>'}
              </ul>
              <div class="text-center mt-3">
                ${!isOwner ? `
                  <button class="btn btn-secondary w-100" onclick="openMakeTokenOfferForm('${nft.name.split('#')[1]}')">
                    Make Token Offer
                  </button>
                ` : ''}
              </div>
            </div>
          </div>
        `;
        const modal = new bootstrap.Modal(document.getElementById('nftModal'));
        const modalElement = document.getElementById('nftModal');
        modalElement.addEventListener('hidden.bs.modal', function () {
          document.body.classList.remove('modal-open');
          const backdrop = document.querySelector('.modal-backdrop');
          if (backdrop) { backdrop.remove(); }
          modalContent.innerHTML = '';
        });
        modal.show();
      } catch (error) {
        console.error('Error:', error);
        alert('Error loading NFT details: ' + error.message);
      }
    }
    
    async function cancelListing(tokenId) {
      try {
        const tx = await floorEngineContract.cancel(tokenId, { gasLimit: 300000 });
        await tx.wait();
        alert("Listing cancelled successfully!");
        const modal = bootstrap.Modal.getInstance(document.getElementById('nftModal'));
        modal.hide();
        loadNFTs();
      } catch (error) {
        console.error("Error cancelling listing:", error);
        alert("Error cancelling listing: " + error.message);
      }
    }
    
    function openListingForm(nftName, marketType) {
      const tokenId = nftName.split('#')[1];
      const modalBody = document.querySelector('.modal-body');
      const existingForm = document.querySelector('.listing-form');
      if (existingForm) existingForm.remove();
      const listingForm = document.createElement('div');
      listingForm.className = 'listing-form mt-4 border-top pt-3';
      listingForm.innerHTML = `
        <h5 class="mb-3">List Token #${tokenId} for Sale</h5>
        <div class="form-group mb-3">
          <label class="mb-2">Price (in $ADRIAN):</label>
          <input type="text" id="listingPrice" class="form-control" value="10000">
        </div>
        <div class="d-flex justify-content-between">
          <button class="btn btn-primary" onclick="createListing('${tokenId}')">Create Listing</button>
          <button class="btn btn-outline-secondary" onclick="closeListingForm()">Cancel</button>
        </div>
      `;
      modalBody.appendChild(listingForm);
      listingForm.scrollIntoView({ behavior: 'smooth', block: 'center' });
    }
    
    function closeListingForm() {
      const form = document.querySelector('.listing-form');
      if (form) form.remove();
    }
    
    async function createListing(tokenId) {
      try {
        const price = ethers.utils.parseUnits(document.getElementById('listingPrice').value, 18);
        
        // Step 1: Check if NFT is approved
        const approvedAddress = await nftContract.getApproved(tokenId);
        if (approvedAddress.toLowerCase() !== FLOOR_ENGINE_ADDRESS.toLowerCase()) {
          alert("Approving NFT for FloorEngine...");
          const txApprove = await nftContract.approve(FLOOR_ENGINE_ADDRESS, tokenId);
          await txApprove.wait();
          console.log("NFT approved for FloorEngine");
        }
        
        // Step 2: List on FloorEngine
        alert("Creating listing...");
        const tx = await floorEngineContract.list(tokenId, price, { gasLimit: 300000 });
        await tx.wait();
        alert("Listing created successfully!");
        
        const modal = bootstrap.Modal.getInstance(document.getElementById('nftModal'));
        modal.hide();
        loadNFTs();
      } catch (error) {
        console.error("Error creating listing:", error);
        alert("Error creating listing: " + error.message);
      }
    }
    
    async function buyNFT(nftName) {
      try {
        if (!marketplaceContract || !tokenContract) {
          alert("Please connect your wallet to continue.");
          return;
        }
        const response = await fetch('adrianpunks.json');
        const data = await response.json();
        const nft = data.collection.find(n => n.name === nftName);
        if (!nft) { alert("NFT not found."); return; }
        const tokenId = parseInt(nft.name.split("#")[1]);
        const price = await marketplaceContract.buyListing(tokenId, 1);
        console.log("NFT Price:", price.toString());
        const currentAllowance = await tokenContract.allowance(userAccount, MARKET_ADDRESS);
        if (currentAllowance.lt(price)) {
          const txApprove = await tokenContract.approve(MARKET_ADDRESS, price);
          await txApprove.wait();
        }
        const txPurchase = await marketplaceContract.buyListing(tokenId, 1);
        await txPurchase.wait();
        alert("Purchase successful!");
      } catch (error) {
        console.error("Error purchasing NFT:", error);
        alert("Error purchasing NFT: " + error.message);
      }
    }
    
    async function buyToken(tokenId, priceStr) {
      try {
        const price = ethers.BigNumber.from(priceStr);
        
        // Step 1: Check allowance and approve if needed
        const currentAllowance = await tokenContract.allowance(userAccount, FLOOR_ENGINE_ADDRESS);
        if (currentAllowance.lt(price)) {
          alert("Approving $ADRIAN for purchase...");
          const txApprove = await tokenContract.approve(FLOOR_ENGINE_ADDRESS, price);
          await txApprove.wait();
          console.log("$ADRIAN approved");
        }
        
        // Step 2: Buy from FloorEngine
        alert("Purchasing token...");
        const txPurchase = await floorEngineContract.buy(tokenId, { gasLimit: 300000 });
        await txPurchase.wait();
        alert("Purchase successful!");
        
        loadNFTs();
        const modal = bootstrap.Modal.getInstance(document.getElementById('nftModal'));
        modal.hide();
      } catch (error) {
        console.error("Error purchasing token:", error);
        alert("Error purchasing token: " + error.message);
      }
    }
    
    async function updateTokenBalance() {
      try {
        const balanceRaw = await tokenContract.balanceOf(userAccount);
        const balance = parseFloat(ethers.utils.formatUnits(balanceRaw, 18));
        let formattedBalance = balance >= 1000000 ? (balance / 1000000).toFixed(1) + 'M' :
                              balance >= 1000 ? (balance / 1000).toFixed(1) + 'K' :
                              balance.toFixed(1);
        document.getElementById("tokenBalance").innerText = `Balance: ${formattedBalance} $ADRIAN`;
      } catch (error) {
        console.error("Error fetching token balance:", error);
        document.getElementById("tokenBalance").innerText = "Balance: Error";
      }
    }
    
    async function sweepFloor() {
      try {
        if (!floorEngineContract || !userAccount) {
          alert("Please connect your wallet first.");
          return;
        }
        
        // Get info before sweeping
        const contractBalance = await tokenReadContract.balanceOf(FLOOR_ENGINE_ADDRESS);
        console.log("Contract balance:", ethers.utils.formatUnits(contractBalance, 18), "$ADRIAN");
        
        if (contractBalance.eq(0)) {
          alert("FloorEngine has no balance to sweep the floor.");
          return;
        }
        
        // Execute sweep
        alert("Executing Sweep Floor...");
        const tx = await floorEngineContract.sweepFloorWithBalance({ gasLimit: 500000 });
        await tx.wait();
        alert("Sweep Floor executed successfully! Check your wallet for rewards.");
        
        // Reload marketplace
        loadNFTs();
      } catch (error) {
        console.error("Error during Sweep Floor:", error);
        alert("Error during Sweep Floor: " + error.message);
      }
    }
    
    async function updateSweepFloorInfo() {
      try {
        if (!floorEngineReadContract) return;
        
        // Get contract balance
        const contractBalance = await tokenReadContract.balanceOf(FLOOR_ENGINE_ADDRESS);
        const balanceFormatted = parseFloat(ethers.utils.formatUnits(contractBalance, 18)).toFixed(2);
        
        // Get cheapest external listing (if any)
        const listedTokenIds = await floorEngineReadContract.getListedTokenIds();
        let cheapestPrice = null;
        let cheapestTokenId = null;
        
        for (const tokenId of listedTokenIds) {
          const listing = await floorEngineReadContract.listings(tokenId);
          if (!listing.isContractOwned) {
            const price = listing.price;
            if (!cheapestPrice || price.lt(cheapestPrice)) {
              cheapestPrice = price;
              cheapestTokenId = tokenId.toNumber();
            }
          }
        }
        
        // Update UI
        const infoDiv = document.getElementById('sweepFloorInfo');
        if (!infoDiv) return;
        
        if (!cheapestPrice) {
          infoDiv.innerHTML = '<p class="text-muted mb-0">No external listings available for sweeping</p>';
          document.getElementById('sweepFloorBtn').disabled = true;
          return;
        }
        
        const cheapestFormatted = parseFloat(ethers.utils.formatUnits(cheapestPrice, 18)).toFixed(2);
        
        // Calculate estimated reward
        const premiumBps = await floorEngineReadContract.premiumBps();
        const callerRewardBps = await floorEngineReadContract.callerRewardBps();
        const callerRewardIsPercentage = await floorEngineReadContract.callerRewardIsPercentage();
        const callerRewardFixed = await floorEngineReadContract.callerRewardFixed();
        
        let rewardFormatted = "0";
        if (callerRewardIsPercentage) {
          const rewardEstimate = cheapestPrice.mul(callerRewardBps).div(10000);
          rewardFormatted = parseFloat(ethers.utils.formatUnits(rewardEstimate, 18)).toFixed(2);
        } else {
          rewardFormatted = parseFloat(ethers.utils.formatUnits(callerRewardFixed, 18)).toFixed(2);
        }
        
        const relistPrice = cheapestPrice.mul(10000 + premiumBps.toNumber()).div(10000);
        const relistFormatted = parseFloat(ethers.utils.formatUnits(relistPrice, 18)).toFixed(2);
        
        // Check if contract has enough balance
        const canExecute = contractBalance.gte(cheapestPrice);
        
        infoDiv.innerHTML = `
          <div class="mb-2">
            <strong>Cheapest Listing:</strong> Token #${cheapestTokenId} - ${cheapestFormatted} $ADRIAN
          </div>
          <div class="mb-2">
            <strong>Contract Balance:</strong> ${balanceFormatted} $ADRIAN
          </div>
          <div class="mb-2">
            <strong>Your Reward:</strong> ~${rewardFormatted} $ADRIAN
          </div>
          <div class="mb-2">
            <strong>Relist Price:</strong> ${relistFormatted} $ADRIAN
          </div>
          ${!canExecute ? '<div class="alert alert-warning mb-0 p-2">Insufficient contract balance</div>' : ''}
        `;
        
        document.getElementById('sweepFloorBtn').disabled = !canExecute;
      } catch (error) {
        console.error("Error updating sweep floor info:", error);
      }
    }
    
    async function openMyListingsModal() {
      if (!marketplaceContract) {
        alert("Please connect your wallet first.");
        return;
      }
      try {
        const myListings = await newMarketplaceContract.getMyListings(userAccount);
        let contentHtml = "";
        if (myListings.length === 0) {
          contentHtml = "<p class='text-center'>No listings found.</p>";
        } else {
          contentHtml = "<ul class='list-group'>";
          myListings.forEach(listing => {
            contentHtml += `<li class="list-group-item">
              Listing #${listing.id.toString()} - Token #${listing.tokenId.toString()} - Price: ${ethers.utils.formatUnits(listing.price, 18)} $ADRIAN - Qty: ${listing.quantity.toString()}
            </li>`;
          });
          contentHtml += "</ul>";
        }
        document.getElementById("myListingsContent").innerHTML = contentHtml;
        let modal = new bootstrap.Modal(document.getElementById('myListingsModal'));
        modal.show();
      } catch (e) {
        console.error(e);
        alert("Error loading my listings: " + e.message);
      }
    }
    
    async function openRecentActivityModal() {
      if (!marketplaceContract) {
        alert("Please connect your wallet first.");
        return;
      }
      try {
        const activeListings = await newMarketplaceContract.getActiveListingsDetailed();
        let contentHtml = "";
        if (activeListings.length === 0) {
          contentHtml = "<p class='text-center'>No active listings.</p>";
        } else {
          contentHtml = "<div class='list-group'>";
          for (const listing of activeListings) {
            const nft = nftData.find(n => parseInt(n.name.split('#')[1]) === listing.tokenId.toNumber());
            const price = parseFloat(ethers.utils.formatUnits(listing.price, 18));
            const formattedPrice = price >= 1000000 ? (price / 1000000).toFixed(1) + 'M' :
                                 price >= 1000 ? (price / 1000).toFixed(1) + 'K' :
                                 price.toFixed(1);
            contentHtml += `
              <div class="list-group-item d-flex justify-content-between align-items-center">
                <div>
                  <span class="fw-bold">Listing</span> - 
                  <span class="text-muted">${listing.seller.substring(0, 6)}...${listing.seller.substring(38)}</span> - 
                  <span class="fw-bold">${listing.tokenId.toString()}</span> - 
                  <span class="text-primary">${formattedPrice} $A</span> - 
                  <small class="text-muted">Expires: ${new Date(listing.expirationTime * 1000).toLocaleString()}</small>
                </div>
                ${nft ? `
                  <img src="${nft.image}" 
                       class="rounded" 
                       style="width: 30px; height: 30px; object-fit: cover; cursor: pointer;" 
                       alt="Token ${listing.tokenId}"
                       onclick="closeAndShowNFTDetails('${nft.name}')">
                ` : ''}
              </div>
            `;
          }
          contentHtml += "</div>";
        }
        document.getElementById("recentActivityContent").innerHTML = contentHtml;
        let modal = new bootstrap.Modal(document.getElementById('recentActivityModal'));
        modal.show();
      } catch (e) {
        console.error(e);
        alert("Error loading recent activity: " + e.message);
      }
    }
    
    function closeAndShowNFTDetails(nftName) {
      try {
        const currentModal = document.querySelector('.modal.show');
        if (currentModal) {
          const modalInstance = bootstrap.Modal.getInstance(currentModal);
          if (modalInstance) {
            modalInstance.hide();
          }
        }
        showNFTDetails(nftName);
      } catch (error) {
        console.error("Error al manejar los modales:", error);
        showNFTDetails(nftName);
      }
    }
    
    async function openMyTokensModal() {
      if (!nftContract || !userAccount) {
        alert("Please connect your wallet first.");
        return;
      }
      const modal = new bootstrap.Modal(document.getElementById('myTokensModal'));
      modal.show();
      loadMyTokensModal();
    }
    
    async function loadMyTokensModal() {
      const container = document.getElementById('myTokensModalContent');
      container.innerHTML = '<div class="text-center"><div class="spinner-border text-primary" role="status"><span class="visually-hidden">Loading...</span></div></div>';
      
      try {
        if (!userAccount) {
          container.innerHTML = '<p class="text-center text-muted">Please connect your wallet first.</p>';
          return;
        }

        // Configurar el provider de Alchemy para consultas m치s r치pidas
        if (!readProvider) {
          readProvider = new ethers.providers.JsonRpcProvider(ALCHEMY_RPC_URL, {
            name: "base",
            chainId: 8453
          });
          // Inicializar todos los contratos de solo lectura
          tokenReadContract = new ethers.Contract(TOKEN_ADDRESS, TOKEN_ABI, readProvider);
          nftReadContract = new ethers.Contract(NFT_ADDRESS, NFT_ABI, readProvider);
          floorEngineReadContract = new ethers.Contract(FLOOR_ENGINE_ADDRESS, FLOOR_ENGINE_ABI, readProvider);
          multicallReadContract = new ethers.Contract(MULTICALL3_ADDRESS, MULTICALL3_ABI, readProvider);
        }

        // Cargar tokens usando Multicall3 para mayor velocidad
        console.log('Loading tokens using Multicall3...');
        
        // Step 1: Get balance
        const balance = await nftReadContract.balanceOf(userAccount);
        const totalTokens = balance.toNumber();
        console.log(`User has ${totalTokens} tokens`);
        
        if (totalTokens === 0) {
          container.innerHTML = '<p class="text-center text-muted">No tokens found for this wallet.</p>';
          return;
        }
        
        // Step 2: Prepare multicall to get all tokenIds
        const calls = [];
        for (let i = 0; i < totalTokens; i++) {
          calls.push({
            target: NFT_ADDRESS,
            allowFailure: true,
            callData: nftReadContract.interface.encodeFunctionData('tokenOfOwnerByIndex', [userAccount, i])
          });
        }
        
        // Step 3: Execute multicall
        const results = await multicallReadContract.aggregate3(calls);
        const tokenIds = results
          .filter(result => result.success)
          .map(result => {
            const decoded = nftReadContract.interface.decodeFunctionResult('tokenOfOwnerByIndex', result.returnData);
            return decoded[0].toNumber();
          });
        
        console.log(`Retrieved ${tokenIds.length} token IDs via Multicall3`);
        
        // Step 4: Load metadata and render tokens
        let tokensHtml = '<div class="row row-cols-2 row-cols-md-3 row-cols-lg-4 g-2">';
        
        // Cargar el JSON con la informaci칩n de los tokens
        const response = await fetch('./adrianpunks.json');
        const data = await response.json();
        const jsonCollection = data.collection;

        // Procesar cada tokenId obtenido con Multicall
        for (const tokenIdInt of tokenIds) {
          try {
            const tokenInfo = jsonCollection.find(item => parseInt(item.name.split('#')[1]) === tokenIdInt);
            
            // Crear un objeto nft con el formato necesario para getImageUrl
            const nftObj = tokenInfo || { name: `AdrianPunk #${tokenIdInt}` };
            
            // Usar la misma funci칩n getImageUrl para mantener consistencia
            const imgUrl = getImageUrl(nftObj);

            tokensHtml += `
              <div class="col">
                <div class="card h-100" style="cursor: pointer;" onclick="closeAndShowNFTDetails('${tokenInfo ? tokenInfo.name : `AdrianPunk #${tokenIdInt}`}')">
                  <div class="ratio ratio-1x1">
                    <img src="${imgUrl}" class="card-img-top" alt="Token #${tokenIdInt}" style="object-fit: cover;">
                  </div>
                  <div class="card-body p-2">
                    <h6 class="card-title mb-0">#${tokenIdInt}</h6>
                    ${tokenInfo ? `<small class="text-muted">Rarity: ${tokenInfo.rarity.toFixed(2)}</small>` : ''}
                  </div>
                </div>
              </div>
            `;
          } catch (error) {
            console.error(`Error processing token ${tokenIdInt}:`, error);
          }
        }
        tokensHtml += '</div>';
        container.innerHTML = tokensHtml;
      } catch (error) {
        console.error("Error loading MyTokens:", error);
        let errorMessage = 'Error loading tokens';
        if (error.message.includes('429') || error.message.includes('rate limit')) {
          errorMessage = 'Too many requests. Please wait a moment and try again.';
        }
        container.innerHTML = `<div class="alert alert-danger">${errorMessage}</div>`;
      }
    }
    
    document.addEventListener('DOMContentLoaded', async () => {
      await initContracts();
      loadNFTs();
      
      // Escuchar eventos de cambio de cuenta desde MetaMask
      if (window.ethereum) {
        window.ethereum.on('accountsChanged', async (accounts) => {
          console.log("Accounts changed:", accounts);
          if (accounts.length > 0) {
            // Actualizar las referencias locales
            window.userAccount = accounts[0];
            userAccount = window.userAccount;
            
            // Reinicializar los contratos con la nueva cuenta
            await initContracts();
            loadNFTs();
          } else {
            // Desconexi칩n
            window.userAccount = null;
            userAccount = null;
            location.reload();
          }
        });
      }
    });

    // Funci칩n para cambiar el tema
    function toggleTheme() {
      const html = document.documentElement;
      const themeButton = document.getElementById('themeButton');
      const themeButtonText = document.getElementById('themeButtonText');
      const isDark = html.getAttribute('data-theme') === 'dark';
      
      if (!isDark) {
        html.setAttribute('data-theme', 'dark');
        localStorage.setItem('theme', 'dark');
        themeButtonText.textContent = 'LightMode';
        themeButton.classList.remove('btn-outline-dark');
        themeButton.classList.add('btn-dark');
      } else {
        html.removeAttribute('data-theme');
        localStorage.setItem('theme', 'light');
        themeButtonText.textContent = 'DarkMode';
        themeButton.classList.remove('btn-dark');
        themeButton.classList.add('btn-secondary');
      }
    }

    // Cargar el tema guardado
    document.addEventListener('DOMContentLoaded', () => {
      const savedTheme = localStorage.getItem('theme');
      const html = document.documentElement;
      const themeButton = document.getElementById('themeButton');
      const themeButtonText = document.getElementById('themeButtonText');
      
      if (savedTheme === 'dark') {
        html.setAttribute('data-theme', 'dark');
        themeButtonText.textContent = 'LightMode';
        themeButton.classList.remove('btn-outline-dark');
        themeButton.classList.add('btn-dark');
      } else {
        themeButtonText.textContent = 'DarkMode';
        themeButton.classList.remove('btn-dark');
        themeButton.classList.add('btn-secondary');
      }
    });

    async function filterByActiveListings() {
      const button = document.querySelector('button[onclick="filterByActiveListings()"]');
      const isActive = button.classList.contains('active');
      if (!isActive) {
        button.classList.remove('btn-outline-primary');
        button.classList.add('btn-primary', 'active');
        const listedNFTs = nftData.filter(nft => {
          const tokenId = parseInt(nft.name.split('#')[1]);
          return activeListingsData.some(listing => listing.tokenId.toString() === tokenId.toString());
        });
        displayNFTs(listedNFTs);
      } else {
        button.classList.remove('btn-primary', 'active');
        button.classList.add('btn-outline-primary');
        filterAndDisplayNFTs();
      }
    }
    
    async function sortByFloorPrice() {
      const button = document.querySelector('button[onclick="sortByFloorPrice()"]');
      currentSortOrder = currentSortOrder === 'asc' ? 'desc' : 'asc';
      button.classList.remove('btn-outline-primary');
      button.classList.add('btn-primary');
      const arrowDirection = currentSortOrder === 'asc' ? '' : '';
      button.innerHTML = `<span class="d-none d-md-inline">Sort by FP</span><span class="d-md-none">Sort FP</span> ${arrowDirection}`;
      const priceMap = new Map();
      activeListingsData.forEach(listing => {
        const currentPrice = priceMap.get(listing.tokenId.toString());
        const thisPrice = parseFloat(ethers.utils.formatUnits(listing.price, 18));
        if (!currentPrice || thisPrice < currentPrice) {
          priceMap.set(listing.tokenId.toString(), thisPrice);
        }
      });
      const sortedNFTs = [...nftData].sort((a, b) => {
        const tokenIdA = a.name.split('#')[1];
        const tokenIdB = b.name.split('#')[1];
        const priceA = priceMap.get(tokenIdA) || Number.MAX_VALUE;
        const priceB = priceMap.get(tokenIdB) || Number.MAX_VALUE;
        return currentSortOrder === 'asc' ? priceA - priceB : priceB - priceA;
      });
      displayNFTs(sortedNFTs);
    }

    // Funci칩n para mostrar notificaciones
    function showToast(message, type = 'info') {
      // Eliminar cualquier toast anterior
      const oldToast = document.getElementById('customToast');
      if (oldToast) {
        oldToast.remove();
      }
      
      // Crear el nuevo toast
      const toast = document.createElement('div');
      toast.id = 'customToast';
      toast.className = `toast-notification ${type}`;
      toast.textContent = message;
      
      // Agregar estilos al toast
      toast.style.position = 'fixed';
      toast.style.bottom = '20px';
      toast.style.left = '50%';
      toast.style.transform = 'translateX(-50%)';
      toast.style.padding = '10px 20px';
      toast.style.borderRadius = '4px';
      toast.style.backgroundColor = type === 'error' ? '#f44336' : '#4CAF50';
      toast.style.color = 'white';
      toast.style.boxShadow = '0 2px 4px rgba(0,0,0,0.2)';
      toast.style.zIndex = '9999';
      toast.style.opacity = '0';
      toast.style.transition = 'opacity 0.3s ease-in-out';
      
      // A침adir al DOM
      document.body.appendChild(toast);
      
      // Mostrar y ocultar autom치ticamente
      setTimeout(() => {
        toast.style.opacity = '1';
      }, 100);
      
      setTimeout(() => {
        toast.style.opacity = '0';
        setTimeout(() => {
          toast.remove();
        }, 300);
      }, 3000);
    }
    
    async function toggleImageCollection() {
      const button = document.getElementById('collectionToggleButton');
      const buttonText = document.getElementById('collectionToggleText');
      
      // Obtener el 칤ndice actual en el array de colecciones
      const currentIndex = availableCollections.indexOf(currentImageCollection);
      // Calcular el siguiente 칤ndice (volviendo al principio si llegamos al final)
      const nextIndex = (currentIndex + 1) % availableCollections.length;
      // Actualizar la colecci칩n actual
      currentImageCollection = availableCollections[nextIndex];
      
      // Actualizar texto del bot칩n seg칰n la colecci칩n
      switch(currentImageCollection) {
        case 'halfxadrian':
          buttonText.textContent = 'HalfxAdrian';
          button.classList.remove('btn-danger', 'btn-info', 'btn-warning');
          button.classList.add('btn-success');
          break;
        case 'vectoradrians':
          buttonText.textContent = 'VECTORadrians';
          button.classList.remove('btn-danger', 'btn-success', 'btn-warning');
          button.classList.add('btn-info');
          break;
        case 'adrianvectors':
          buttonText.textContent = 'ADRIANvectors';
          button.classList.remove('btn-danger', 'btn-success', 'btn-info');
          button.classList.add('btn-warning');
          break;
        default: // adrianpunks
          buttonText.textContent = 'AdrianPunks';
          button.classList.remove('btn-success', 'btn-info', 'btn-warning');
          button.classList.add('btn-danger');
      }
      
      // Mostrar mensaje de confirmaci칩n
      let toastMessage;
      switch(currentImageCollection) {
        case 'halfxadrian':
          toastMessage = 'Showing images from HalfxAdrian';
          break;
        case 'vectoradrians':
          toastMessage = 'Showing images from VECTORadrians';
          break;
        case 'adrianvectors':
          toastMessage = 'Showing images from ADRIANvectors';
          break;
        default:
          toastMessage = 'Showing images from AdrianPunks';
      }
      showToast(toastMessage);
      
      // Recargar la visualizaci칩n con las nuevas im치genes
      filterAndDisplayNFTs();
    }

    function getImageUrl(nft) {
      const tokenId = nft.name.split('#')[1];
      const gifIds = ['1', '13', '221', '369', '420', '555', '69', '690', '777', '807', '911'];
      
      switch(currentImageCollection) {
        case 'halfxadrian':
          // Mantener intacta la l칩gica original para halfxadrian
          return `./halfxadrianimages/${tokenId}.jpg`;
          
        case 'vectoradrians':
          // Cargar directamente como JPG o GIF, similar a halfxadrian
          if (gifIds.includes(tokenId)) {
            return `/market/alpha/${tokenId}.gif`;
          } else {
            return `/market/alpha/${tokenId}.jpg`;
          }
          
        case 'adrianvectors':
          // Cargar directamente como JPG o GIF, similar a halfxadrian
          if (gifIds.includes(tokenId)) {
            return `/market/omega/${tokenId}.gif`;
          } else {
            return `/market/omega/${tokenId}.jpg`;
          }
          
        default: // adrianpunks
          // Mantener intacta la l칩gica original para adrianpunks
          const extension = gifIds.includes(tokenId) ? 'gif' : 'png';
          return `./adrianpunksimages/${tokenId}.${extension}`;
      }
    }
    
    // Funci칩n para cargar im치genes din치micamente e intentar diferentes formatos
    // Esta funci칩n ya no se usa, pero la dejamos por si acaso es necesaria en el futuro
    function loadDynamicImage(tokenId, collection) {
      // Definir los formatos a probar en orden
      const formats = ['jpg', 'png', 'jpeg', 'webp'];
      let basePath = collection === 'vectoradrians' ? '/market/alpha/' : '/market/omega/';
      
      // Crear un mapa para identificar qu칠 imagen pertenece a qu칠 token y colecci칩n
      let imageElements = document.querySelectorAll(`img[data-token-id="${tokenId}"][data-collection="${collection}"]`);
      if (imageElements.length === 0) {
        // Si no encontramos elementos con los atributos de datos, buscar por src
        imageElements = document.querySelectorAll(`img[src="${basePath}placeholder.jpg"], img[src^="${basePath}${tokenId}."]`);
      }
      
      // Funci칩n para probar secuencialmente cada formato
      function tryNextFormat(index = 0) {
        if (index >= formats.length) {
          console.log(`No se pudo cargar ning칰n formato para el token ${tokenId} en ${collection}`);
          return;
        }
        
        const format = formats[index];
        const imgUrl = `${basePath}${tokenId}.${format}`;
        
        // Crear una imagen temporal para probar si existe
        const testImg = new Image();
        testImg.onload = function() {
          // La imagen carg칩 correctamente, actualizar todas las referencias
          imageElements.forEach(img => {
            // Verificar si el elemento tiene los atributos de datos correctos
            const imgTokenId = img.getAttribute('data-token-id');
            const imgCollection = img.getAttribute('data-collection');
            
            if ((imgTokenId === tokenId.toString() && imgCollection === collection) || 
                img.src.includes(`${basePath}placeholder.jpg`) || 
                img.src.includes(`${basePath}${tokenId}.`)) {
              img.src = imgUrl;
              // Asegurarnos de que tenga los atributos correctos
              img.setAttribute('data-token-id', tokenId);
              img.setAttribute('data-collection', collection);
            }
          });
        };
        
        testImg.onerror = function() {
          // Probar el siguiente formato
          tryNextFormat(index + 1);
        };
        
        // Iniciar la carga con un peque침o timeout para asegurar que la red tenga tiempo de responder
        setTimeout(() => {
          testImg.src = imgUrl;
        }, 50);
      }
      
      // Iniciar la secuencia de pruebas
      setTimeout(() => {
        // Actualizar referencias a im치genes despu칠s de que el DOM se ha actualizado
        if (imageElements.length === 0) {
          imageElements = document.querySelectorAll(`img[src="${basePath}placeholder.jpg"], img[src^="${basePath}${tokenId}."]`);
        }
        
        // A침adir atributos de datos para identificar las im치genes si no los tienen
        imageElements.forEach(img => {
          if (!img.hasAttribute('data-token-id')) {
            img.setAttribute('data-token-id', tokenId);
          }
          if (!img.hasAttribute('data-collection')) {
            img.setAttribute('data-collection', collection);
          }
        });
        
        tryNextFormat();
      }, 100);
    }
  </script>

  <!-- Inicializaci칩n de Web3 y conexi칩n a la wallet -->
  <script>
    // Setup para el nuevo bot칩n de wallet en la botonera principal
    document.addEventListener('DOMContentLoaded', function() {
      const mainWalletButton = document.getElementById('mainConnectWalletButton');
      if (mainWalletButton) {
        mainWalletButton.addEventListener('click', connectMainWallet);
      }

      // Verificar si ya hay una wallet conectada al cargar la p치gina
      checkWalletConnection();
    });

    let mainWalletProvider;
    let mainWalletSigner;
    let mainWalletConnected = false;
    let mainWalletAddress = '';

    async function connectMainWallet() {
      try {
        const mainWalletButton = document.getElementById('mainConnectWalletButton');
        
        if (!window.ethereum) {
          showToast("Por favor instala MetaMask para conectar tu wallet");
          return;
        }

        if (!mainWalletConnected) {
          mainWalletProvider = new ethers.providers.Web3Provider(window.ethereum);
          await mainWalletProvider.send("eth_requestAccounts", []);
          mainWalletSigner = mainWalletProvider.getSigner();
          mainWalletAddress = await mainWalletSigner.getAddress();
          
          // Reducir a solo 4 caracteres al inicio y 4 al final para que quepa mejor
          const shortAddress = `${mainWalletAddress.slice(0, 4)}..${mainWalletAddress.slice(-4)}`;
          mainWalletButton.innerHTML = shortAddress;
          mainWalletButton.classList.add('active');
          
          mainWalletConnected = true;
          
          // Escuchar cambios de cuenta
          window.ethereum.on('accountsChanged', handleMainAccountsChanged);
          
          // Notificar al usuario
          showToast("Wallet conectada: " + shortAddress);
          
          // Actualizar la informaci칩n de NFTs del usuario si es necesario
          loadUserNFTs();
        } else {
          // Desconectar
          disconnectMainWallet();
        }
      } catch (error) {
        console.error("Error conectando wallet:", error);
        showToast("Error conectando wallet: " + error.message);
      }
    }

    function disconnectMainWallet() {
      mainWalletConnected = false;
      mainWalletProvider = null;
      mainWalletSigner = null;
      mainWalletAddress = '';
      
      const mainWalletButton = document.getElementById('mainConnectWalletButton');
      mainWalletButton.innerHTML = "Connect Wallet";
      mainWalletButton.classList.remove('active');
      
      // Remover listener
      if (window.ethereum) {
        window.ethereum.removeListener('accountsChanged', handleMainAccountsChanged);
      }
      
      showToast("Wallet desconectada");
    }

    function handleMainAccountsChanged(accounts) {
      if (accounts.length === 0) {
        // Usuario desconect칩 desde MetaMask
        disconnectMainWallet();
      } else {
        // Actualizar con la nueva direcci칩n
        mainWalletAddress = accounts[0];
        const shortAddress = `${mainWalletAddress.slice(0, 6)}...${mainWalletAddress.slice(-4)}`;
        
        const mainWalletButton = document.getElementById('mainConnectWalletButton');
        mainWalletButton.innerHTML = `Connected: ${shortAddress}`;
        
        // Actualizar la informaci칩n de NFTs del usuario si es necesario
        loadUserNFTs();
      }
    }

    // Verificar si hay una wallet conectada al cargar la p치gina
    async function checkWalletConnection() {
      if (window.ethereum) {
        try {
          mainWalletProvider = new ethers.providers.Web3Provider(window.ethereum);
          const accounts = await mainWalletProvider.listAccounts();
          
          if (accounts.length > 0) {
            mainWalletSigner = mainWalletProvider.getSigner();
            mainWalletAddress = accounts[0];
            const shortAddress = `${mainWalletAddress.slice(0, 6)}...${mainWalletAddress.slice(-4)}`;
            
            const mainWalletButton = document.getElementById('mainConnectWalletButton');
            if (mainWalletButton) {
              mainWalletButton.innerHTML = `Connected: ${shortAddress}`;
              mainWalletButton.classList.add('active');
            }
            
            mainWalletConnected = true;
            
            // Escuchar cambios de cuenta
            window.ethereum.on('accountsChanged', handleMainAccountsChanged);
            
            // Actualizar informaci칩n de NFTs si es necesario
            loadUserNFTs();
          }
        } catch (error) {
          console.error("Error verificando conexi칩n de wallet:", error);
        }
      }
    }

    // Funci칩n para cargar NFTs del usuario si es necesario
    function loadUserNFTs() {
      // Aqu칤 puedes agregar la l칩gica para cargar los NFTs del usuario
      // cuando se conecte la wallet
      console.log("Wallet conectada. Puedes implementar la carga de NFTs del usuario aqu칤.");
    }
  </script>
</body>
</html>