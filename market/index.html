<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AdrianPunks Market v3.12</title>
  <link rel="icon" type="image/x-icon" href="favicon.ico">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
  <link rel="stylesheet" href="/market/styles.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css">
  <style>
    /* Estilos base */
    :root {
      --bg-color: #ffffff;
      --text-color: #333333;
      --card-bg: #ffffff;
      --border-color: #dee2e6;
      --modal-bg: #ffffff;
      --modal-header-bg: #f8f9fa;
      --dropdown-bg: #ffffff;
      --dropdown-text: #333333;
      --badge-bg: #007bff;
      --badge-text: #ffffff;
      --list-group-bg: #ffffff;
      --list-group-text: #333333;
      --list-group-border: #dee2e6;
    }

    /* Estilos dark mode */
    [data-theme="dark"] {
      --bg-color: #1a1a1a;
      --text-color: #ffffff;
      --card-bg: #2d2d2d;
      --border-color: #404040;
      --modal-bg: #2d2d2d;
      --modal-header-bg: #1a1a1a;
      --dropdown-bg: #2d2d2d;
      --dropdown-text: #ffffff;
      --badge-bg: #0d6efd;
      --badge-text: #ffffff;
      --list-group-bg: #2d2d2d;
      --list-group-text: #ffffff;
      --list-group-border: #404040;
      --modal-text: #ffffff;
      --modal-border: #404040;
      --modal-input-bg: #1a1a1a;
      --modal-input-text: #ffffff;
      --modal-input-border: #404040;
    }

    body {
      background-color: var(--bg-color);
      color: var(--text-color);
    }

    .container {
      background-color: var(--bg-color);
    }

    .card {
      background-color: var(--card-bg);
      border-color: var(--border-color);
      color: var(--text-color);
    }

    .card-title, .card-text {
      color: var(--text-color);
    }

    .text-muted {
      color: #a0a0a0 !important;
    }

    .modal-content {
      background-color: var(--modal-bg);
      color: var(--modal-text);
      border-color: var(--modal-border);
    }

    .modal-header {
      background-color: var(--modal-header-bg);
      border-bottom-color: var(--modal-border);
    }

    .modal-body {
      background-color: var(--modal-bg);
      color: var(--modal-text);
    }

    .modal-footer {
      background-color: var(--modal-bg);
      border-top-color: var(--modal-border);
    }

    .form-control {
      background-color: var(--modal-input-bg);
      color: var(--modal-input-text);
      border-color: var(--modal-input-border);
    }

    .form-control:focus {
      background-color: var(--modal-input-bg);
      color: var(--modal-input-text);
      border-color: var(--modal-input-border);
    }

    .dropdown-menu {
      background-color: var(--dropdown-bg);
      color: var(--dropdown-text);
    }

    .badge {
      background-color: var(--badge-bg);
      color: var(--badge-text);
    }

    .list-group-item {
      background-color: var(--list-group-bg);
      color: var(--list-group-text);
      border-color: var(--list-group-border);
    }

    /* Estilos del switch */
    .theme-switch {
      position: fixed;
      bottom: 20px;
      right: 20px;
      z-index: 1000;
      background-color: var(--card-bg);
      padding: 8px 12px;
      border-radius: 20px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    }

    .theme-switch .form-check-input {
      cursor: pointer;
    }

    .theme-switch .form-check-label {
      color: var(--text-color);
      cursor: pointer;
      margin-left: 8px;
    }

    /* Mantener los estilos existentes */
    #tokenBalance {
      margin-top: 10px;
    }
    @media (max-width: 768px) {
      #tokenBalance {
        margin-top: 70px;
      }
      .card-title {
        font-size: 1rem;
        line-height: 1.2;
        margin-bottom: 0.25rem;
      }
      .nft-card .card-body {
        padding: 0.5rem;
      }
      .nft-card .card-text {
        font-size: 0.85rem;
      }
      .action-btn {
        font-size: 0.9rem;
        padding: 0.4rem 0.6rem;
      }
      .action-btn.dropdown-toggle::after {
        margin-left: 0.3rem;
      }
    }
    .modal-dialog {
      max-width: 500px;
    }
    .modal-body img {
      max-width: 300px;
      margin: 0 auto;
      display: block;
    }
    /* Asegurar que el backdrop se elimine correctamente */
    .modal-backdrop {
      opacity: 0.5;
    }
    body.modal-open {
      overflow: auto !important;
      padding-right: 0 !important;
    }
    .offer-form {
      transition: all 0.3s ease;
      opacity: 1;
      transform: translateY(0);
    }
    .offer-form.hiding {
      opacity: 0;
      transform: translateY(-10px);
    }
    .modal-body {
      max-height: 80vh;
      overflow-y: auto;
      scroll-behavior: smooth;
    }
    .trait-info {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .badge {
      font-size: 0.9em;
      padding: 8px 12px;
    }
    .trait-categories {
      max-height: 400px;
      overflow-y: auto;
      padding-right: 10px;
    }
    .trait-category {
      margin-bottom: 1rem;
    }
    .trait-category-title {
      font-size: 0.9rem;
      font-weight: 600;
      color: #333;
    }
    .trait-values {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
      gap: 0.5rem;
    }
    .trait-value-item button {
      font-size: 0.8rem;
      padding: 0.25rem 0.5rem;
    }
    #activeFilters {
      margin-bottom: 1rem;
    }
    #activeFilters .badge {
      font-size: 0.8rem;
      padding: 0.35rem 0.65rem;
    }
    #traitFilterMenu {
      max-height: 80vh;
      overflow-y: auto;
    }
  </style>
  <!-- Load ethers.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/5.7.2/ethers.umd.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
</head>
<body>
  <!-- Include the menu -->
  <div id="menu-container"></div>
  <script>
    // Load the menu
    fetch('components/menu.html')
      .then(response => response.text())
      .then(html => {
        document.getElementById('menu-container').innerHTML = html;
        const script = document.createElement('script');
        script.src = 'components/menu.js';
        document.head.appendChild(script);
      })
      .catch(error => console.error('Error loading menu:', error));
  </script>

  <!-- Main Container -->
  <div class="container">
    <!-- Balance y Floor Offer Info -->
    <div class="info-section mb-4">
      <h2 id="tokenBalance" class="mb-2">Balance: Loading...</h2>
      <div id="floorOfferSection" class="text-secondary">
        <span id="floorOfferText">Highest floor offer: -- $ADRIAN</span>
      </div>
    </div>

    <!-- Botonera Principal Unificada -->
    <div class="main-actions mb-4">
      <div class="action-buttons">
        <button class="action-btn warning" onclick="openFloorOfferPopup()">
          <span class="d-none d-md-inline">Make Floor</span> Offer
        </button>
        <button class="action-btn info" onclick="openMyOffersModal()">
          <span class="d-none d-md-inline">My</span> Offers
        </button>
        <button class="action-btn secondary" onclick="openMyListingsModal()">
          <span class="d-none d-md-inline">My</span> Listings
        </button>
        <button class="action-btn dark" onclick="openRecentActivityModal()">
          <span class="d-none d-md-inline">Recent</span> Activity
        </button>
        <div class="dropdown">
          <button class="action-btn primary dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false">
            <span>Traits</span>
          </button>
          <ul class="dropdown-menu p-3" id="traitFilterMenu">
            <div class="d-flex justify-content-between mb-2">
              <button class="btn btn-sm btn-danger me-2" onclick="clearTraitFilters()">Clear Filters</button>
              <span class="text-muted" id="filteredCount"></span>
            </div>
            <div id="activeFilters" class="mb-2"></div>
            <div class="trait-categories" id="traitCategories">
              <!-- Categorías de traits se cargarán dinámicamente -->
            </div>
          </ul>
        </div>
        <button class="action-btn outline" onclick="filterByActiveListings()">
          <span class="d-none d-md-inline">Listed</span><span class="d-md-none">Listed</span>
        </button>
        <button class="action-btn outline" onclick="sortByFloorPrice()">
          <span class="d-none d-md-inline">Sort by FP</span><span class="d-md-none">Sort FP</span>
        </button>
        <div class="dropdown">
          <button class="action-btn warning dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false">
            <span>Sweep Floor</span>
          </button>
          <ul class="dropdown-menu p-3" id="sweepFloorMenu">
            <div class="form-group mb-3">
              <label for="sweepAmount" class="form-label">Number of tokens to sweep:</label>
              <input type="number" class="form-control" id="sweepAmount" value="1" min="1">
            </div>
            <button class="btn btn-primary w-100" onclick="sweepFloor()">Execute Sweep</button>
          </ul>
        </div>
        <button class="action-btn outline" onclick="openMyTokensModal()">
          <span class="d-none d-md-inline">My</span> Tokens
        </button>
        <button class="action-btn" id="themeButton" onclick="toggleTheme()">
          <span id="themeButtonText">DarkMode</span>
        </button>
      </div>
    </div>

    <!-- NFT Grid -->
    <div class="nft-grid" id="nftGrid"></div>
  </div>

  <!-- Modal para NFT Details -->
  <div class="modal fade" id="nftModal" tabindex="-1" aria-labelledby="nftModalLabel" aria-hidden="true" data-bs-backdrop="static">
    <div class="modal-dialog modal-dialog-centered">
      <div class="modal-content" id="nftModalContent">
        <!-- Contenido cargado dinámicamente -->
      </div>
    </div>
  </div>

  <!-- Modal for My Offers -->
  <div class="modal fade" id="myOffersModal" tabindex="-1" aria-labelledby="myOffersModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered modal-xl">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title" id="myOffersModalLabel">My Active Offers</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body">
          <!-- Tabs: Token, Floor y Trait -->
          <ul class="nav nav-tabs mb-3 d-flex" id="offersTab" role="tablist">
            <li class="nav-item flex-equal" role="presentation">
              <button class="nav-link active w-100" id="token-offers-tab" data-bs-toggle="tab" data-bs-target="#token-offers" type="button" role="tab">
                Token
              </button>
            </li>
            <li class="nav-item flex-equal" role="presentation">
              <button class="nav-link w-100" id="floor-offers-tab" data-bs-toggle="tab" data-bs-target="#floor-offers" type="button" role="tab">
                Floor
              </button>
            </li>
            <li class="nav-item flex-equal" role="presentation">
              <button class="nav-link w-100" id="trait-offers-tab" data-bs-toggle="tab" data-bs-target="#trait-offers" type="button" role="tab">
                Trait
              </button>
            </li>
          </ul>
          
          <style>
            .flex-equal {
              flex: 1 1 0;
            }
            #offersTab .nav-link {
              padding: 0.5rem;
              text-align: center;
              white-space: nowrap;
              color: #333;
              background-color: #e9ecef;
              border: 1px solid #dee2e6;
              margin: 0 2px;
              font-size: 0.9rem;
            }
            #offersTab .nav-link.active {
              background-color: #007bff;
              color: white;
              border-color: #007bff;
            }
            #offersTab .nav-link:hover {
              background-color: #dde2e6;
              color: #333;
            }
            #offersTab .nav-link.active:hover {
              background-color: #0069d9;
              color: white;
            }
            @media (max-width: 768px) {
              #offersTab .nav-link {
                font-size: 0.8rem;
                padding: 0.4rem;
              }
            }
          </style>

          <!-- Contenido de los tabs -->
          <div class="tab-content" id="offersTabContent">
            <!-- Token Offers -->
            <div class="tab-pane fade show active" id="token-offers" role="tabpanel">
              <div id="tokenOffersContent">
                <div class="text-center">
                  <div class="spinner-border text-primary" role="status">
                    <span class="visually-hidden">Loading...</span>
                  </div>
                </div>
              </div>
            </div>
            <!-- Floor Offers -->
            <div class="tab-pane fade" id="floor-offers" role="tabpanel">
              <div id="floorOffersContent">
                <div class="text-center">
                  <div class="spinner-border text-primary" role="status">
                    <span class="visually-hidden">Loading...</span>
                  </div>
                </div>
              </div>
            </div>
            <!-- Trait Offers -->
            <div class="tab-pane fade" id="trait-offers" role="tabpanel">
              <div id="traitOffersContent">
                <div class="text-center">
                  <div class="spinner-border text-primary" role="status">
                    <span class="visually-hidden">Loading...</span>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Modal for My Listings -->
  <div class="modal fade" id="myListingsModal" tabindex="-1" aria-labelledby="myListingsModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title" id="myListingsModalLabel">My Listings</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body" id="myListingsContent">
          <!-- Listado de mis listados -->
        </div>
      </div>
    </div>
  </div>

  <!-- Modal for Recent Activity -->
  <div class="modal fade" id="recentActivityModal" tabindex="-1" aria-labelledby="recentActivityModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered modal-lg">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title" id="recentActivityModalLabel">Recent Activity</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body" id="recentActivityContent">
          <!-- Datos de actividad reciente se inyectan aquí -->
        </div>
      </div>
    </div>
  </div>

  <!-- Modal for Floor Offer Popup -->
  <div class="modal fade" id="floorOfferPopupModal" tabindex="-1" aria-labelledby="floorOfferPopupModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title" id="floorOfferPopupModalLabel">Make Floor Offer for the Collection</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body" id="floorOfferPopupContent">
          <div id="floorOfferForm">
            <label>Offer Amount (in $ADRIAN): 
              <input type="text" id="popupOfferAmount" value="10000" class="form-control">
            </label>
            <button class="btn btn-primary mt-2" onclick="makeFloorOfferPopup()">Submit Floor Offer</button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Modal for My Tokens -->
  <div class="modal fade" id="myTokensModal" tabindex="-1" aria-labelledby="myTokensModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered modal-lg">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title" id="myTokensModalLabel">My Tokens</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body" id="myTokensModalContent">
          <div class="text-center">
            <div class="spinner-border text-primary" role="status">
              <span class="visually-hidden">Loading...</span>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Bootstrap JS -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
  
  <!-- Main Script: NFT loading and Contract Interactions -->
  <script>
    /*********** Global Variables and Contract Setup ***********/
    let nftData = [];
    let provider, signer, userAccount;
    let tokenContract, nftContract, marketplaceContract, newMarketplaceContract;
    
    // Direcciones de contratos y ABIs
    const TOKEN_ADDRESS  = "0x7E99075Ce287F1cF8cBCAaa6A1C7894e404fD7Ea";
    const NFT_ADDRESS    = "0x79BE8AcdD339C7b92918fcC3fd3875b5Aaad7566";
    const MARKET_ADDRESS = "0xe746999546e65c44543a443cc1e9b5fe168ede5d";
    const NEW_MARKET_ADDRESS = "0x4B09395Dd0B826Ab3D54272D5dba6769D1640297";
    const ACTIVITY_LOGGER_ADDRESS = "0x5B38Da6a701c568545dCfcB03FcB875f56beddC4";
    const OFFER_MANAGER_ADDRESS = "0x5B38Da6a701c568545dCfcB03FcB875f56beddC4";

    // ABI actualizado del contrato AdrianMarket (incluye Trait Offers)
    const MARKET_ABI = [
      "constructor(address _paymentToken)",
      "event FloorOfferAccepted(address indexed collection, address indexed seller, uint256 tokenId, uint256 offerAmount)",
      "event FloorOfferSet(address indexed collection, address indexed buyer, uint256 offerAmount)",
      "event ListingCancelled(uint256 indexed listingId)",
      "event ListingCreated(uint256 indexed listingId, address indexed seller, address collection, uint256 tokenId, uint256 quantity, uint256 price, uint256 expirationTime, uint8 nftType)",
      "event ListingEdited(uint256 indexed listingId, uint256 newPrice, uint256 newExpirationTime)",
      "event ListingPurchased(uint256 indexed listingId, address indexed buyer, uint256 quantity)",
      "event OfferAccepted(uint256 indexed offerId, uint256 indexed listingId, address indexed buyer, address seller)",
      "event OfferCreated(uint256 indexed offerId, uint256 indexed listingId, address indexed buyer, uint256 tokenId, uint256 quantity, uint256 offerAmount)",
      "event OfferWithdrawn(uint256 indexed offerId, uint256 indexed listingId, address indexed buyer)",
      "event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)",
      "event Paused(address account)",
      "event TokenOfferCreated(uint256 indexed offerId, address indexed collection, uint256 tokenId, address buyer, uint256 quantity, uint256 offerAmount)",
      "event TokenOfferWithdrawn(uint256 indexed offerId, address indexed collection, uint256 tokenId, address buyer)",
      "event TokenOfferAccepted(uint256 indexed offerId, address indexed collection, uint256 tokenId, address seller, address buyer, uint256 offerAmount)",
      "event TraitOfferSet(string traitType, string traitValue, address indexed buyer, uint256 offerAmount)",
      "event TraitOfferAccepted(string traitType, string traitValue, address indexed seller, uint256 tokenId, uint256 offerAmount)",
      "event TraitOfferCancelled(string traitType, string traitValue, address indexed buyer)",
      "event Unpaused(address account)",

      // Funciones de listings
      "function createListing(address collection, uint256 tokenId, uint256 quantity, uint256 price, uint256 duration, uint8 nftTypeParam) external",
      "function cancelListing(uint256 listingId) external",
      "function buyListing(uint256 listingId, uint256 purchaseQuantity) external",
      "function editListing(uint256 listingId, uint256 newPrice, uint256 newDuration) external",
      "function getActiveListingsDetailed() external view returns (tuple(uint256 id, address seller, address collection, uint256 tokenId, uint256 quantity, uint256 price, uint256 expirationTime, uint8 nftType)[])",
      "function getMyListings(address seller) external view returns (tuple(uint256 id, address seller, address collection, uint256 tokenId, uint256 quantity, uint256 price, uint256 expirationTime, uint8 nftType)[])",
      "function getListing(uint256 listingId) external view returns (tuple(uint256 id, address seller, address collection, uint256 tokenId, uint256 quantity, uint256 price, uint256 expirationTime, uint8 nftType))",
      "function getActiveTokenListings() external view returns (tuple(address collection, uint256 tokenId, uint256 totalQuantity)[])",
      
      // Floor offers
      "function floorOffers(address, uint256) external view returns (uint256 offerAmount, address buyer, bool active)",
      "function setFloorOffer(address collection, uint256 offerAmount) external",
      "function withdrawFloorOffer(address collection) external",
      "function acceptFloorOffer(address collection, uint256 tokenId, uint8 nftTypeParam) external",
      "function acceptMultipleFloorOffers(address collection, uint256 tokenId, uint8 nftTypeParam, address[] buyers) external",
      
      // Listing Offers
      "function makeOffer(uint256 listingId, uint256 quantity, uint256 offerAmount) external",
      "function withdrawOffer(uint256 listingId) external",
      "function acceptOffer(uint256 listingId, address buyer) external",
      "function getMyListingOffers(address buyer) external view returns (tuple(uint256 id, uint256 listingId, address buyer, uint256 tokenId, uint256 quantity, uint256 offerAmount, bool exists)[])",
      
      // Token offers
      "function makeTokenOffer(address collection, uint256 tokenId, uint256 quantity, uint256 offerAmount) external",
      "function withdrawTokenOffer(address collection, uint256 tokenId) external",
      "function acceptTokenOffer(address collection, uint256 tokenId, uint256 offerId, uint8 nftTypeParam) external",
      "function getMyTokenOffers(address buyer) external view returns (tuple(uint256 id, address collection, uint256 tokenId, uint256 quantity, uint256 offerAmount, address buyer, bool exists)[])",
      "function getTokenOffersForToken(address collection, uint256 tokenId) external view returns (tuple(uint256 id, address collection, uint256 tokenId, uint256 quantity, uint256 offerAmount, address buyer, bool exists)[])",
      
      // Trait offers
      "function setTraitOffer(string traitType, string traitValue, uint256 offerAmount) external",
      "function cancelTraitOffer(string traitType, string traitValue) external",
      "function acceptTraitOffer(string traitType, string traitValue, uint256 tokenId, address collection, uint8 nftTypeParam) external",
      "function getTraitOffers(address buyer) external view returns (tuple(string traitType, string traitValue, uint256 offerAmount, address buyer, bool exists)[])",
      
      // Funciones administrativas
      "function owner() external view returns (address)",
      "function paused() external view returns (bool)",
      "function paymentToken() external view returns (address)",
      "function renounceOwnership() external",
      "function transferOwnership(address newOwner) external",
      
      // Funciones de soporte
      "function supportsInterface(bytes4 interfaceId) external view returns (bool)",
      "function onERC1155Received(address, address, uint256, uint256, bytes) external pure returns (bytes4)",
      "function onERC1155BatchReceived(address, address, uint256[], uint256[], bytes) external pure returns (bytes4)"
    ];

    const TOKEN_ABI = [
      "function balanceOf(address account) view returns (uint256)",
      "function approve(address spender, uint256 amount) external returns (bool)",
      "function allowance(address owner, address spender) view returns (uint256)"
    ];
    const NFT_ABI = [
      "function tokenURI(uint256 tokenId) view returns (string)",
      "function ownerOf(uint256 tokenId) view returns (address)",
      "function getApproved(uint256 tokenId) view returns (address)",
      "function approve(address to, uint256 tokenId) external",
      "function isApprovedForAll(address owner, address operator) view returns (bool)",
      "function setApprovalForAll(address operator, bool approved) external",
      "function balanceOf(address owner) view returns (uint256)",
      "function tokenOfOwnerByIndex(address owner, uint256 index) view returns (uint256)",
      "function totalMinted() view returns (uint256)"
    ];
    
    async function initContracts() {
      if (window.ethereum) {
        provider = new ethers.providers.Web3Provider(window.ethereum);
        signer = provider.getSigner();
        userAccount = await signer.getAddress();
        tokenContract = new ethers.Contract(TOKEN_ADDRESS, TOKEN_ABI, signer);
        nftContract = new ethers.Contract(NFT_ADDRESS, NFT_ABI, signer);
        // Usamos el nuevo contrato para listados y trait offers
        marketplaceContract = new ethers.Contract(MARKET_ADDRESS, MARKET_ABI, signer);
        newMarketplaceContract = new ethers.Contract(NEW_MARKET_ADDRESS, MARKET_ABI, signer);
        updateTokenBalance();
        loadFloorOffer();
      } else {
        console.error("Ethereum provider not found.");
      }
    }
    
    /*********** NFT Data Loading and Display ***********/
    let activeFilters = new Map();
    let allTraits = new Map();
    
    function extractTraits(nfts) {
      allTraits.clear();
      nfts.forEach(nft => {
        if (nft.attributes) {
          nft.attributes.forEach(attr => {
            if (!allTraits.has(attr.trait_type)) {
              allTraits.set(attr.trait_type, new Set());
            }
            allTraits.get(attr.trait_type).add(attr.value);
          });
        }
      });
      return allTraits;
    }
    
    function renderTraitFilters() {
      const container = document.getElementById('traitCategories');
      container.innerHTML = '';
      allTraits.forEach((values, traitType) => {
        const categoryDiv = document.createElement('div');
        categoryDiv.className = 'trait-category mb-3';
        categoryDiv.innerHTML = `
          <h6 class="trait-category-title mb-2">${traitType}</h6>
          <div class="trait-values">
            ${Array.from(values).map(value => `
              <div class="trait-value-item">
                <button class="btn btn-sm ${activeFilters.get(traitType) === value ? 'btn-primary' : 'btn-outline-secondary'} w-100 text-start mb-1"
                  onclick="toggleTraitFilter('${traitType}', '${value}')">
                  ${value}
                </button>
              </div>
            `).join('')}
          </div>
        `;
        container.appendChild(categoryDiv);
      });
      updateActiveFiltersDisplay();
    }
    
    function updateActiveFiltersDisplay() {
      const container = document.getElementById('activeFilters');
      if (activeFilters.size === 0) {
        container.innerHTML = '<small class="text-muted">No active filters</small>';
        return;
      }
      container.innerHTML = Array.from(activeFilters.entries()).map(([type, value]) => `
        <span class="badge bg-primary me-1 mb-1">
          ${type}: ${value}
          <button type="button" class="btn-close btn-close-white" style="font-size: 0.5em;" 
            onclick="removeTraitFilter('${type}')"></button>
        </span>
      `).join('');
    }
    
    function toggleTraitFilter(traitType, value) {
      if (activeFilters.get(traitType) === value) {
        activeFilters.delete(traitType);
      } else {
        activeFilters.set(traitType, value);
      }
      renderTraitFilters();
      filterAndDisplayNFTs();
    }
    
    function removeTraitFilter(traitType) {
      activeFilters.delete(traitType);
      renderTraitFilters();
      filterAndDisplayNFTs();
    }
    
    function clearTraitFilters() {
      activeFilters.clear();
      renderTraitFilters();
      filterAndDisplayNFTs();
    }
    
    function filterAndDisplayNFTs() {
      if (!nftData) return;
      let filteredNFTs = nftData;
      if (activeFilters.size > 0) {
        filteredNFTs = nftData.filter(nft => {
          return Array.from(activeFilters.entries()).every(([type, value]) => {
            return nft.attributes.some(attr => attr.trait_type === type && attr.value === value);
          });
        });
      }
      document.getElementById('filteredCount').textContent = `Showing ${filteredNFTs.length} of ${nftData.length}`;
      displayNFTs(filteredNFTs);
    }
    
    let activeListingsData = [];
    let currentSortOrder = 'asc';
    
    async function loadActiveListings() {
      try {
        activeListingsData = await newMarketplaceContract.getActiveListingsDetailed();
        activeListingsData = activeListingsData.filter(listing => listing.expirationTime > Math.floor(Date.now() / 1000));
        console.log("Active listings loaded:", activeListingsData);
      } catch (error) {
        console.error("Error loading active listings:", error);
        activeListingsData = [];
      }
    }
    
    // MODIFICACIÓN: Filtrar NFTs según la cantidad minteada
    async function loadNFTs() {
        try {
            // Verificar si MetaMask está instalado
            if (typeof window.ethereum === 'undefined') {
                displayMessage('Please install MetaMask to view NFTs', 'error');
                return;
            }

            // Verificar si hay una cuenta conectada
            const accounts = await ethereum.request({ method: 'eth_accounts' });
            if (accounts.length === 0) {
                displayMessage('Please connect your wallet to view NFTs', 'warning');
                return;
            }

            // Obtener el total de NFTs minteados
            const totalMinted = await nftContract.methods.totalSupply().call();
            
            // Cargar datos del JSON
            const response = await fetch('adrianpunks.json');
            const data = await response.json();
            nftData = data.collection;

            // Limpiar el grid de NFTs
            const nftGrid = document.getElementById('nft-grid');
            nftGrid.innerHTML = '';

            // Mostrar los NFTs minteados
            for (let i = 0; i < totalMinted; i++) {
                const nft = nftData[i];
                if (nft) {
                    const nftCard = createNFTCard(nft);
                    nftGrid.appendChild(nftCard);
                }
            }
        } catch (error) {
            console.error('Error loading NFTs:', error);
            displayMessage('Error loading NFTs: ' + error.message, 'error');
        }
    }
    
    async function displayNFTs(nfts) {
      const grid = document.getElementById('nftGrid');
      grid.innerHTML = '';
      if (!nfts || nfts.length === 0) {
        grid.innerHTML = '<div class="alert alert-info">No NFTs found</div>';
        return;
      }
      nfts.forEach(nft => {
        const tokenId = nft.name.split('#')[1];
        const listing = activeListingsData.find(l => l.tokenId.toString() === tokenId && l.expirationTime > Math.floor(Date.now() / 1000));
        const card = document.createElement('div');
        card.className = 'card nft-card';
        card.style.cursor = 'pointer';
        card.onclick = () => showNFTDetails(nft.name);
        card.innerHTML = `
          <img src="${nft.image}" class="card-img-top" alt="${nft.name}" onerror="this.src='placeholder.png'">
          <div class="card-body">
            <h5 class="card-title">${nft.name}</h5>
            <p class="card-text">Rarity: ${nft.rarity.toFixed(2)}</p>
            ${listing ? `
              <div class="price-tag alert alert-info py-1 px-2 mb-0">
                <small>Listed: ${(parseFloat(ethers.utils.formatUnits(listing.price, 18)) >= 1000000 ? 
                  (parseFloat(ethers.utils.formatUnits(listing.price, 18)) / 1000000).toFixed(1) + 'M' :
                  parseFloat(ethers.utils.formatUnits(listing.price, 18)) >= 1000 ? 
                  (parseFloat(ethers.utils.formatUnits(listing.price, 18)) / 1000).toFixed(1) + 'K' :
                  parseFloat(ethers.utils.formatUnits(listing.price, 18)).toFixed(1))} $A</small>
              </div>
            ` : ''}
          </div>
        `;
        grid.appendChild(card);
      });
    }
    
    async function showNFTDetails(nftName) {
      try {
        const data = await fetch('/market/adrianpunks.json').then(response => response.json());
        const nft = data.collection.find(n => n.name === nftName);
        if (!nft) throw new Error("NFT not found");
        const tokenId = parseInt(nft.name.split('#')[1]);
        let ownershipStatus = '';
        let isOwner = false;
        try {
          const owner = await nftContract.ownerOf(tokenId);
          isOwner = owner.toLowerCase() === userAccount.toLowerCase();
          ownershipStatus = isOwner ? `<div class="alert alert-success">You are the owner of this token</div>` : `<div class="alert alert-info">Owner: ${owner.substring(0, 6)}...${owner.substring(38)}</div>`;
        } catch (error) {
          ownershipStatus = `<div class="alert alert-warning">Could not verify token ownership</div>`;
        }
        const activeListings = await newMarketplaceContract.getActiveListingsDetailed();
        const tokenListing = activeListings.find(listing => listing.tokenId.toString() === tokenId.toString() && listing.expirationTime > Math.floor(Date.now() / 1000));
        const tokenOffers = await newMarketplaceContract.getTokenOffersForToken(NFT_ADDRESS, tokenId);
        console.log("Token offers:", tokenOffers);
        const relevantOffers = tokenOffers.filter(offer => offer.exists);
        let floorOffer;
        try {
          floorOffer = await newMarketplaceContract.callStatic.floorOffers(NFT_ADDRESS, 0);
        } catch (e) {
          console.error("Error retrieving floor offer, defaulting to no active offer:", e);
          floorOffer = { offerAmount: ethers.BigNumber.from(0), buyer: "", active: false };
        }
        const modalContent = document.getElementById('nftModalContent');
        modalContent.innerHTML = `
          <div class="modal-header">
            <h5 class="modal-title">${nft.name}</h5>
            <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
          </div>
          <div class="modal-body text-center">
            <img src="${nft.image}" class="img-fluid rounded mb-3" alt="${nft.name}" onerror="this.src='placeholder.png'">
            <div class="nft-details text-start">
              ${ownershipStatus}
              <p><strong>Description:</strong> ${nft.description}</p>
              <p><strong>Compiler:</strong> ${nft.compiler}</p>
              <p><strong>Masterminds:</strong> ${nft.masterminds.join(', ')}</p>
              <p><strong>Rarity:</strong> ${nft.rarity.toFixed(2)}</p>
              ${isOwner ? `
                ${!tokenListing ? `
                  <button class="btn btn-primary w-100 mb-2" onclick="openListingForm('${nft.name}', 'NewAdrianMarket')">
                    List for Sale
                  </button>
                ` : `
                  <div class="listing-info alert alert-info">
                    <h6>Active Listing</h6>
                    <p>Price: ${parseFloat(ethers.utils.formatUnits(tokenListing.price, 18)).toLocaleString('en-US', {minimumFractionDigits: 1, maximumFractionDigits: 1})} $ADRIAN</p>
                    <p>Seller: ${tokenListing.seller.substring(0, 6)}...${tokenListing.seller.substring(38)}</p>
                    <p>Expires: ${new Date(tokenListing.expirationTime * 1000).toLocaleString()}</p>
                    <button class="btn btn-danger btn-sm" onclick="cancelListing(${tokenListing.id})">Cancel Listing</button>
                  </div>
                `}
              ` : ''}
              <div class="offers-section mt-3">
                <h6>Active Offers</h6>
                ${relevantOffers && relevantOffers.length > 0 ? `
                  <div class="list-group">
                    ${relevantOffers.map(offer => `
                      <div class="list-group-item">
                        <p class="mb-1">Offer: ${parseFloat(ethers.utils.formatUnits(offer.offerAmount, 18)).toLocaleString('en-US', {minimumFractionDigits: 1, maximumFractionDigits: 1})} $A</p>
                        <small>By: ${offer.buyer.substring(0, 6)}...${offer.buyer.substring(38)}</small>
                        ${isOwner ? `
                          <button class="btn btn-success btn-sm float-end" 
                            onclick="acceptTokenOffer('${NFT_ADDRESS}', ${tokenId}, ${offer.id})">
                            Accept Offer
                          </button>
                        ` : ''}
                        ${offer.buyer.toLowerCase() === userAccount.toLowerCase() ? `
                          <button class="btn btn-danger btn-sm float-end" 
                            onclick="cancelTokenOffer('${NFT_ADDRESS}', ${tokenId})">
                            Cancel Offer
                          </button>
                        ` : ''}
                      </div>
                    `).join('')}
                  </div>
                ` : `
                  <div class="text-center">
                    <p class="text-muted">No active offers</p>
                  </div>
                `}
                ${floorOffer.offerAmount.gt(0) ? `
                  <div class="floor-offer-info mt-2">
                    <p class="mb-1">Floor Offer: ${parseFloat(ethers.utils.formatUnits(floorOffer.offerAmount, 18)).toLocaleString('en-US', {minimumFractionDigits: 1, maximumFractionDigits: 1})} $A</p>
                    <small>By: ${floorOffer.buyer.substring(0, 6)}...${floorOffer.buyer.substring(38)}</small>
                    ${isOwner ? `
                      <button class="btn btn-success btn-sm" onclick="acceptFloorOffer(${tokenId})">
                        Accept Floor Offer
                      </button>
                    ` : ''}
                  </div>
                ` : ''}
              </div>
              <h6 class="mt-3">Attributes:</h6>
              <ul class="list-group">
                ${nft.attributes.map(attr => 
                  `<li class="list-group-item d-flex justify-content-between align-items-center">
                    <div>
                      <strong>${attr.trait_type}:</strong> ${attr.value}
                    </div>
                    <button class="btn btn-sm btn-outline-primary" 
                      onclick="openTraitOfferForm('${attr.trait_type}', '${attr.value}')" 
                      title="Make Trait Offer">
                      💰
                    </button>
                  </li>`
                ).join('')}
              </ul>
              <div class="text-center mt-3">
                ${!isOwner ? `
                  <button class="btn btn-secondary w-100" onclick="openMakeTokenOfferForm('${nft.name.split('#')[1]}')">
                    Make Token Offer
                  </button>
                ` : ''}
              </div>
            </div>
          </div>
        `;
        const modal = new bootstrap.Modal(document.getElementById('nftModal'));
        const modalElement = document.getElementById('nftModal');
        modalElement.addEventListener('hidden.bs.modal', function () {
          document.body.classList.remove('modal-open');
          const backdrop = document.querySelector('.modal-backdrop');
          if (backdrop) { backdrop.remove(); }
          modalContent.innerHTML = '';
        });
        modal.show();
      } catch (error) {
        console.error('Error:', error);
        alert('Error loading NFT details: ' + error.message);
      }
    }
    
    async function cancelListing(listingId) {
      try {
        const tx = await newMarketplaceContract.cancelListing(listingId, { gasLimit: 1000000 });
        await tx.wait();
        alert("Listing cancelled successfully!");
        const modal = bootstrap.Modal.getInstance(document.getElementById('nftModal'));
        modal.hide();
        loadNFTs();
      } catch (error) {
        console.error("Error cancelling listing:", error);
        alert("Error cancelling listing: " + error.message);
      }
    }
    
    function openListingForm(nftName, marketType) {
      const tokenId = nftName.split('#')[1];
      const modalBody = document.querySelector('.modal-body');
      const existingForm = document.querySelector('.listing-form');
      if (existingForm) existingForm.remove();
      const listingForm = document.createElement('div');
      listingForm.className = 'listing-form mt-4 border-top pt-3';
      listingForm.innerHTML = `
        <h5 class="mb-3">List Token #${tokenId} for Sale in ${marketType}</h5>
        <div class="form-group mb-3">
          <label class="mb-2">Price (in $ADRIAN):</label>
          <input type="text" id="listingPrice" class="form-control" value="10000">
        </div>
        <div class="form-group mb-3">
          <label class="mb-2">Duration (in days):</label>
          <input type="number" id="listingDuration" class="form-control" value="7" min="1">
        </div>
        <div class="d-flex justify-content-between">
          <button class="btn btn-primary" onclick="createListing('${tokenId}')">Create Listing</button>
          <button class="btn btn-outline-secondary" onclick="closeListingForm()">Cancel</button>
        </div>
      `;
      modalBody.appendChild(listingForm);
      listingForm.scrollIntoView({ behavior: 'smooth', block: 'center' });
    }
    
    function closeListingForm() {
      const form = document.querySelector('.listing-form');
      if (form) form.remove();
    }
    
    async function createListing(tokenId) {
      try {
        const price = ethers.utils.parseUnits(document.getElementById('listingPrice').value, 18);
        const duration = document.getElementById('listingDuration').value * 24 * 60 * 60;
        const approvedAddress = await nftContract.getApproved(tokenId);
        if (approvedAddress.toLowerCase() !== NEW_MARKET_ADDRESS.toLowerCase()) {
          const txApprove = await nftContract.approve(NEW_MARKET_ADDRESS, tokenId);
          await txApprove.wait();
          console.log("NFT específico aprobado para el nuevo marketplace");
        }
        const tx = await newMarketplaceContract.createListing(
          NFT_ADDRESS,
          tokenId,
          1,
          price,
          duration,
          1,
          { gasLimit: 1000000 }
        );
        await tx.wait();
        alert("Listing created successfully!");
        const modal = bootstrap.Modal.getInstance(document.getElementById('nftModal'));
        modal.hide();
        loadNFTs();
      } catch (error) {
        console.error("Error creating listing:", error);
        alert("Error creating listing: " + error.message);
      }
    }
    
    async function buyNFT(nftName) {
      try {
        if (!marketplaceContract || !tokenContract) {
          alert("Please connect your wallet to continue.");
          return;
        }
        const response = await fetch('adrianpunks.json');
        const data = await response.json();
        const nft = data.collection.find(n => n.name === nftName);
        if (!nft) { alert("NFT not found."); return; }
        const tokenId = parseInt(nft.name.split("#")[1]);
        const price = await marketplaceContract.buyListing(tokenId, 1);
        console.log("NFT Price:", price.toString());
        const currentAllowance = await tokenContract.allowance(userAccount, MARKET_ADDRESS);
        if (currentAllowance.lt(price)) {
          const txApprove = await tokenContract.approve(MARKET_ADDRESS, price);
          await txApprove.wait();
        }
        const txPurchase = await marketplaceContract.buyListing(tokenId, 1);
        await txPurchase.wait();
        alert("Purchase successful!");
      } catch (error) {
        console.error("Error purchasing NFT:", error);
        alert("Error purchasing NFT: " + error.message);
      }
    }
    
    async function buyToken(listingId, priceStr) {
      try {
        const price = ethers.BigNumber.from(priceStr);
        const currentAllowance = await tokenContract.allowance(userAccount, NEW_MARKET_ADDRESS);
        if (currentAllowance.lt(price)) {
          const txApprove = await tokenContract.approve(NEW_MARKET_ADDRESS, price);
          await txApprove.wait();
        }
        const txPurchase = await newMarketplaceContract.buyListing(listingId, 1, { gasLimit: 1000000 });
        await txPurchase.wait();
        alert("Purchase successful!");
        loadNFTs();
        const modal = bootstrap.Modal.getInstance(document.getElementById('nftModal'));
        modal.hide();
      } catch (error) {
        console.error("Error purchasing token:", error);
        alert("Error purchasing token: " + error.message);
      }
    }
    
    async function updateTokenBalance() {
      try {
        const balanceRaw = await tokenContract.balanceOf(userAccount);
        const balance = parseFloat(ethers.utils.formatUnits(balanceRaw, 18));
        let formattedBalance = balance >= 1000000 ? (balance / 1000000).toFixed(1) + 'M' :
                              balance >= 1000 ? (balance / 1000).toFixed(1) + 'K' :
                              balance.toFixed(1);
        document.getElementById("tokenBalance").innerText = `Balance: ${formattedBalance} $ADRIAN`;
      } catch (error) {
        console.error("Error fetching token balance:", error);
        document.getElementById("tokenBalance").innerText = "Balance: Error";
      }
    }
    
    async function loadFloorOffer() {
      try {
        const floorOffer = await newMarketplaceContract.callStatic.floorOffers(NFT_ADDRESS, 0);
        const offerAmount = floorOffer.offerAmount;
        const floorSection = document.getElementById("floorOfferSection");
        if (offerAmount.gt(0)) {
          document.getElementById("floorOfferText").innerText = `Highest floor offer: ${ethers.utils.formatUnits(offerAmount, 18)} $ADRIAN`;
          floorSection.classList.remove("no-offer");
        } else {
          document.getElementById("floorOfferText").innerText = "Highest floor offer: 0 $ADRIAN";
          floorSection.classList.add("no-offer");
        }
      } catch (error) {
        console.error("Error loading floor offer:", error);
        document.getElementById("floorOfferText").innerText = "Highest floor offer: 0 $ADRIAN";
        document.getElementById("floorOfferSection").classList.add("no-offer");
      }
    }
    
    async function sweepFloor() {
      if (!newMarketplaceContract) {
        alert("Please connect your wallet first.");
        return;
      }
      const numTokens = parseInt(document.getElementById('sweepAmount').value);
      if (isNaN(numTokens) || numTokens <= 0) {
        alert("Invalid number. Please try again.");
        return;
      }
      try {
        // Obtenemos listados activos del nuevo contrato
        const activeListings = await newMarketplaceContract.getActiveListingsDetailed();
        // Filtramos los listados que aún no han expirado
        let listingsArr = activeListings.filter(listing => {
          // Suponemos que listing.expirationTime es un BigNumber
          return listing.expirationTime.gt(Math.floor(Date.now() / 1000));
        });
        // Ordenamos por precio unitario (precio / cantidad) de menor a mayor
        listingsArr.sort((a, b) => {
          const unitPriceA = a.price.div(a.quantity);
          const unitPriceB = b.price.div(b.quantity);
          // Usamos BigNumber.sub() y toNumber() para la comparación
          return unitPriceA.sub(unitPriceB).toNumber();
        });
        
        let tokensBought = 0;
        let totalCost = ethers.BigNumber.from(0);
        let remaining = numTokens;
        
        // Recorremos los listados para comprar tokens hasta cubrir la cantidad solicitada
        for (let listing of listingsArr) {
          if (remaining <= 0) break;
          const available = listing.quantity.toNumber(); // Asumimos que listing.quantity es un BigNumber
          if (available <= 0) continue;
          
          // Calculamos cuántos tokens podemos comprar en este listado
          const purchaseQuantity = Math.min(available, remaining);
          const unitPrice = listing.price.div(listing.quantity);
          const purchaseTotalPrice = unitPrice.mul(purchaseQuantity);
          
          // Comprobamos y aprobamos tokens para el nuevo contrato si es necesario
          const currentAllowance = await tokenContract.allowance(userAccount, NEW_MARKET_ADDRESS);
          if (currentAllowance.lt(purchaseTotalPrice)) {
            const txApprove = await tokenContract.approve(NEW_MARKET_ADDRESS, purchaseTotalPrice);
            await txApprove.wait();
          }
          
          try {
            const txBuy = await newMarketplaceContract.buyListing(listing.id, purchaseQuantity, { gasLimit: 1000000 });
            await txBuy.wait();
            tokensBought += purchaseQuantity;
            totalCost = totalCost.add(purchaseTotalPrice);
            remaining -= purchaseQuantity;
            console.log(`Purchased ${purchaseQuantity} token(s) from listing ${listing.id}`);
          } catch (err) {
            console.error("Error purchasing listing " + listing.id, err);
          }
        }
        
        alert(`Sweep Floor complete! You purchased ${tokensBought} token(s) for a total cost of ${ethers.utils.formatUnits(totalCost, 18)} $ADRIAN.`);
        loadNFTs();
      } catch (error) {
        console.error("Error during Sweep Floor:", error);
        alert("Error during Sweep Floor: " + error.message);
      }
    }
    
    async function openMyListingsModal() {
      if (!marketplaceContract) {
        alert("Please connect your wallet first.");
        return;
      }
      try {
        const myListings = await newMarketplaceContract.getMyListings(userAccount);
        let contentHtml = "";
        if (myListings.length === 0) {
          contentHtml = "<p class='text-center'>No listings found.</p>";
        } else {
          contentHtml = "<ul class='list-group'>";
          myListings.forEach(listing => {
            contentHtml += `<li class="list-group-item">
              Listing #${listing.id.toString()} - Token #${listing.tokenId.toString()} - Price: ${ethers.utils.formatUnits(listing.price, 18)} $ADRIAN - Qty: ${listing.quantity.toString()}
            </li>`;
          });
          contentHtml += "</ul>";
        }
        document.getElementById("myListingsContent").innerHTML = contentHtml;
        let modal = new bootstrap.Modal(document.getElementById('myListingsModal'));
        modal.show();
      } catch (e) {
        console.error(e);
        alert("Error loading my listings: " + e.message);
      }
    }
    
    async function openRecentActivityModal() {
      if (!marketplaceContract) {
        alert("Please connect your wallet first.");
        return;
      }
      try {
        const activeListings = await newMarketplaceContract.getActiveListingsDetailed();
        let contentHtml = "";
        if (activeListings.length === 0) {
          contentHtml = "<p class='text-center'>No active listings.</p>";
        } else {
          contentHtml = "<div class='list-group'>";
          for (const listing of activeListings) {
            const nft = nftData.find(n => parseInt(n.name.split('#')[1]) === listing.tokenId.toNumber());
            const price = parseFloat(ethers.utils.formatUnits(listing.price, 18));
            const formattedPrice = price >= 1000000 ? (price / 1000000).toFixed(1) + 'M' :
                                 price >= 1000 ? (price / 1000).toFixed(1) + 'K' :
                                 price.toFixed(1);
            contentHtml += `
              <div class="list-group-item d-flex justify-content-between align-items-center">
                <div>
                  <span class="fw-bold">Listing</span> - 
                  <span class="text-muted">${listing.seller.substring(0, 6)}...${listing.seller.substring(38)}</span> - 
                  <span class="fw-bold">${listing.tokenId.toString()}</span> - 
                  <span class="text-primary">${formattedPrice} $A</span> - 
                  <small class="text-muted">Expires: ${new Date(listing.expirationTime * 1000).toLocaleString()}</small>
                </div>
                ${nft ? `
                  <img src="${nft.image}" 
                       class="rounded" 
                       style="width: 30px; height: 30px; object-fit: cover; cursor: pointer;" 
                       alt="Token ${listing.tokenId}"
                       onclick="closeAndShowNFTDetails('${nft.name}')">
                ` : ''}
              </div>
            `;
          }
          contentHtml += "</div>";
        }
        document.getElementById("recentActivityContent").innerHTML = contentHtml;
        let modal = new bootstrap.Modal(document.getElementById('recentActivityModal'));
        modal.show();
      } catch (e) {
        console.error(e);
        alert("Error loading recent activity: " + e.message);
      }
    }
    
    function closeAndShowNFTDetails(nftName) {
      try {
        const currentModal = document.querySelector('.modal.show');
        if (currentModal) {
          const modalInstance = bootstrap.Modal.getInstance(currentModal);
          if (modalInstance) {
            modalInstance.hide();
          }
        }
        showNFTDetails(nftName);
      } catch (error) {
        console.error("Error al manejar los modales:", error);
        showNFTDetails(nftName);
      }
    }
    
    async function openMyOffersModal() {
      if (!marketplaceContract || !userAccount) {
        alert("Please connect your wallet first.");
        return;
      }
      const modal = new bootstrap.Modal(document.getElementById('myOffersModal'));
      modal.show();
      loadMyOffers();
      document.querySelectorAll('#offersTab button').forEach(button => {
        button.addEventListener('click', (e) => {
          const tabId = e.target.getAttribute('data-bs-target').substring(1);
          if (tabId === 'token-offers') loadTokenOffers();
          else if (tabId === 'floor-offers') loadFloorOffers();
          else if (tabId === 'trait-offers') loadTraitOffers();
        });
      });
    }
    
    async function loadMyOffers() {
      loadTokenOffers();
      loadFloorOffers();
      loadTraitOffers();
    }
    
    async function loadTokenOffers() {
      const container = document.getElementById('tokenOffersContent');
      try {
        const offers = await marketplaceContract.getMyTokenOffers(userAccount);
        if (offers.length === 0) {
          container.innerHTML = '<p class="text-center text-muted">No active token offers found</p>';
          return;
        }
        let html = '<div class="list-group">';
        for (const offer of offers) {
          if (!offer.exists) continue;
          const offerAmount = ethers.utils.formatUnits(offer.offerAmount, 18);
          html += `
            <div class="list-group-item">
              <div class="d-flex justify-content-between align-items-center">
                <div>
                  <h6 class="mb-1">Offer on Token #${offer.tokenId.toString()}</h6>
                  <p class="mb-1">${offerAmount} $ADRIAN</p>
                  <small class="text-muted">Quantity: ${offer.quantity.toString()}</small>
                </div>
                <button class="btn btn-danger btn-sm" onclick="cancelTokenOffer('${offer.collection}', ${offer.tokenId})">
                  Cancel Offer
                </button>
              </div>
            </div>
          `;
        }
        html += '</div>';
        container.innerHTML = html;
      } catch (error) {
        console.error("Error loading token offers:", error);
        container.innerHTML = '<div class="alert alert-danger">Error loading token offers</div>';
      }
    }
    
    async function loadTraitOffers() {
      const container = document.getElementById('traitOffersContent');
      try {
        const filter = newMarketplaceContract.filters.TraitOfferSet(null, null, userAccount);
        const logs = await newMarketplaceContract.queryFilter(filter, 0, "latest");
        let offers = [];
        logs.forEach(log => {
          const parsed = newMarketplaceContract.interface.parseLog(log);
          offers.push({
            traitType: parsed.args.traitType,
            traitValue: parsed.args.traitValue,
            offerAmount: parsed.args.offerAmount,
            buyer: parsed.args.buyer
          });
        });
        let activeOffers = [];
        for (const offer of offers) {
          const key = ethers.utils.keccak256(ethers.utils.defaultAbiCoder.encode(["string", "string"], [offer.traitType, offer.traitValue]));
          const traitOffer = await newMarketplaceContract.traitOffers(key);
          if (traitOffer.active && traitOffer.buyer.toLowerCase() === userAccount.toLowerCase()) {
            activeOffers.push(traitOffer);
          }
        }
        if (activeOffers.length === 0) {
          container.innerHTML = '<p class="text-center text-muted">No active trait offers found</p>';
          return;
        }
        let html = '<div class="list-group">';
        for (const offer of activeOffers) {
          const offerAmountFormatted = ethers.utils.formatUnits(offer.offerAmount, 18);
          html += `
            <div class="list-group-item">
              <div class="d-flex justify-content-between align-items-center">
                <div>
                  <h6 class="mb-1">Trait Offer</h6>
                  <div class="trait-info mb-1">
                    <span class="badge bg-primary me-2">${offer.traitType}</span>
                    <span class="badge bg-secondary">${offer.traitValue}</span>
                  </div>
                  <p class="mb-1">${offerAmountFormatted} $ADRIAN</p>
                </div>
                <button class="btn btn-danger btn-sm" onclick="cancelTraitOffer('${offer.traitType}', '${offer.traitValue}')">
                  Cancel Offer
                </button>
              </div>
            </div>
          `;
        }
        html += '</div>';
        container.innerHTML = html;
      } catch (error) {
        console.error("Error loading trait offers:", error);
        container.innerHTML = '<div class="alert alert-danger">Error loading trait offers</div>';
      }
    }
    
    async function cancelTraitOffer(traitType, traitValue) {
      try {
        const tx = await newMarketplaceContract.cancelTraitOffer(traitType, traitValue, { gasLimit: 1000000 });
        await tx.wait();
        alert("Trait offer cancelled successfully!");
        loadTraitOffers();
      } catch (error) {
        console.error("Error cancelling trait offer:", error);
        alert("Error cancelling trait offer: " + error.message);
      }
    }
    
    async function openMyTokensModal() {
      if (!nftContract || !userAccount) {
        alert("Please connect your wallet first.");
        return;
      }
      const modal = new bootstrap.Modal(document.getElementById('myTokensModal'));
      modal.show();
      loadMyTokensModal();
    }
    
    async function loadMyTokensModal() {
      const container = document.getElementById('myTokensModalContent');
      container.innerHTML = '<div class="text-center"><div class="spinner-border text-primary" role="status"><span class="visually-hidden">Loading...</span></div></div>';
      try {
        const balance = await nftContract.balanceOf(userAccount);
        let tokensHtml = '';
        if (balance.toNumber() === 0) {
          tokensHtml = '<p class="text-center text-muted">No tokens found for this wallet.</p>';
        } else {
          tokensHtml = '<div class="row row-cols-2 row-cols-md-3 row-cols-lg-4 g-2">';
          for (let i = 0; i < balance; i++) {
            const tokenId = await nftContract.tokenOfOwnerByIndex(userAccount, i);
            const nft = nftData.find(n => parseInt(n.name.split('#')[1]) === tokenId.toNumber());
            if (nft) {
              const tokenOffers = await newMarketplaceContract.getTokenOffersForToken(NFT_ADDRESS, tokenId);
              const relevantOffers = tokenOffers.filter(offer => offer.exists);
              let highestOffer = null;
              if (relevantOffers.length > 0) {
                highestOffer = relevantOffers.reduce((max, offer) => 
                  offer.offerAmount.gt(max.offerAmount) ? offer : max
                );
              }
              const offerAmount = highestOffer ? ethers.utils.formatUnits(highestOffer.offerAmount, 18) : null;
              const formattedOffer = offerAmount ? 
                (parseFloat(offerAmount) >= 1000000 ? (parseFloat(offerAmount) / 1000000).toFixed(1) + 'M' :
                 parseFloat(offerAmount) >= 1000 ? (parseFloat(offerAmount) / 1000).toFixed(1) + 'K' :
                 parseFloat(offerAmount).toFixed(1)) + ' $A' : '';
              tokensHtml += `
                <div class="col">
                  <div class="card h-100" style="cursor: pointer;" onclick="closeAndShowNFTDetails('${nft.name}')">
                    <div class="ratio ratio-1x1">
                      <img src="${nft.image}" class="card-img-top" alt="Token #${tokenId}" style="object-fit: cover;">
                    </div>
                    <div class="card-body p-2">
                      <h6 class="card-title mb-0">${nft.name}</h6>
                      <small class="text-muted">Rarity: ${nft.rarity.toFixed(2)}</small>
                      ${formattedOffer ? `<small class="text-success d-block">Offer: ${formattedOffer}</small>` : ''}
                    </div>
                  </div>
                </div>
              `;
            }
          }
          tokensHtml += '</div>';
        }
        container.innerHTML = tokensHtml;
      } catch (error) {
        console.error("Error loading MyTokens:", error);
        container.innerHTML = '<div class="alert alert-danger">Error loading tokens: ' + error.message + '</div>';
      }
    }
    
    async function cancelTokenOffer(collection, tokenId) {
      try {
        const tx = await newMarketplaceContract.withdrawTokenOffer(collection, tokenId, { gasLimit: 1000000 });
        await tx.wait();
        alert("Token offer cancelled successfully!");
        loadTokenOffers();
      } catch (error) {
        console.error("Error cancelling token offer:", error);
        alert("Error cancelling token offer: " + error.message);
      }
    }
    
    async function openFloorOfferPopup() {
      const modal = new bootstrap.Modal(document.getElementById('floorOfferPopupModal'));
      modal.show();
    }
    
    async function makeFloorOfferPopup() {
      const offerAmount = document.getElementById("popupOfferAmount").value;
      const offerAmountWei = ethers.utils.parseUnits(offerAmount, 18);
      try {
        const allowance = await tokenContract.allowance(userAccount, NEW_MARKET_ADDRESS);
        if (allowance.lt(offerAmountWei)) {
          const txApprove = await tokenContract.approve(NEW_MARKET_ADDRESS, offerAmountWei);
          await txApprove.wait();
          alert("Approved " + ethers.utils.formatUnits(offerAmountWei, 18) + " $ADRIAN tokens.");
        }
        const tx = await newMarketplaceContract.setFloorOffer(NFT_ADDRESS, offerAmountWei);
        await tx.wait();
        alert("Floor offer created successfully!");
        loadFloorOffer();
      } catch (error) {
        console.error("Error creating floor offer:", error);
        alert("Error creating floor offer: " + error.message);
      }
    }
    
    function openTraitOfferForm(traitType, traitValue) {
      const modalBody = document.querySelector('.modal-body');
      const existingForm = document.querySelector('.trait-offer-form');
      if (existingForm) existingForm.remove();
      const offerForm = document.createElement('div');
      offerForm.className = 'trait-offer-form mt-4 border-top pt-3';
      offerForm.innerHTML = `
        <h5 class="mb-3">Make Trait Offer</h5>
        <div class="form-group mb-3">
          <div class="trait-info mb-3">
            <span class="badge bg-primary me-2">${traitType}</span>
            <span class="badge bg-secondary">${traitValue}</span>
          </div>
          <label class="mb-2">Offer Amount (in $ADRIAN):</label>
          <input type="text" id="traitOfferAmount_${traitType}_${traitValue}" value="5000" class="form-control">
        </div>
        <div class="d-flex justify-content-between">
          <button class="btn btn-primary" onclick="makeTraitOffer('${traitType}', '${traitValue}')">
            Submit Trait Offer
          </button>
          <button class="btn btn-outline-secondary" onclick="closeTraitOfferForm()">
            Cancel
          </button>
        </div>
      `;
      modalBody.appendChild(offerForm);
      offerForm.scrollIntoView({ behavior: 'smooth', block: 'center' });
    }
    
    function closeTraitOfferForm() {
      const form = document.querySelector('.trait-offer-form');
      if (form) form.remove();
    }
    
    async function makeTraitOffer(traitType, traitValue) {
      try {
        const offerAmount = document.getElementById(`traitOfferAmount_${traitType}_${traitValue}`).value;
        const offerAmountWei = ethers.utils.parseUnits(offerAmount, 18);
        const allowance = await tokenContract.allowance(userAccount, NEW_MARKET_ADDRESS);
        if (allowance.lt(offerAmountWei)) {
          const txApprove = await tokenContract.approve(NEW_MARKET_ADDRESS, offerAmountWei);
          await txApprove.wait();
          console.log("Approved tokens for trait offer");
        }
        const tx = await newMarketplaceContract.setTraitOffer(traitType, traitValue, offerAmountWei, { gasLimit: 1000000 });
        await tx.wait();
        alert("Trait offer created successfully!");
        closeTraitOfferForm();
      } catch (error) {
        console.error("Error creating trait offer:", error);
        alert("Error creating trait offer: " + error.message);
      }
    }
    
    function openMakeTokenOfferForm(tokenId) {
      const modalBody = document.querySelector('.modal-body');
      const existingForm = document.querySelector('.token-offer-form');
      if (existingForm) existingForm.remove();
      const offerForm = document.createElement('div');
      offerForm.className = 'token-offer-form mt-4 border-top pt-3';
      offerForm.innerHTML = `
        <h5 class="mb-3">Make Token Offer</h5>
        <div class="form-group mb-3">
          <div class="token-info mb-3">
            <span class="badge bg-primary">Token #${tokenId}</span>
          </div>
          <label class="mb-2">Offer Amount (in $ADRIAN):</label>
          <input type="text" id="tokenOfferAmount_${tokenId}" value="5000" class="form-control">
        </div>
        <div class="d-flex justify-content-between">
          <button class="btn btn-primary" onclick="makeTokenOffer('${tokenId}')">
            Submit Token Offer
          </button>
          <button class="btn btn-outline-secondary" onclick="closeTokenOfferForm()">
            Cancel
          </button>
        </div>
      `;
      modalBody.appendChild(offerForm);
      offerForm.scrollIntoView({ behavior: 'smooth', block: 'center' });
    }
    
    function closeTokenOfferForm() {
      const form = document.querySelector('.token-offer-form');
      if (form) form.remove();
    }
    
    async function makeTokenOffer(tokenId) {
      try {
        const offerAmount = document.getElementById(`tokenOfferAmount_${tokenId}`).value;
        const offerAmountWei = ethers.utils.parseUnits(offerAmount, 18);
        const allowance = await tokenContract.allowance(userAccount, NEW_MARKET_ADDRESS);
        if (allowance.lt(offerAmountWei)) {
          const txApprove = await tokenContract.approve(NEW_MARKET_ADDRESS, offerAmountWei);
          await txApprove.wait();
          console.log("Approved tokens for token offer");
        }
        const tx = await newMarketplaceContract.makeTokenOffer(
          NFT_ADDRESS,
          tokenId,
          1,
          offerAmountWei,
          { gasLimit: 1000000 }
        );
        await tx.wait();
        alert("Token offer created successfully!");
        closeTokenOfferForm();
        loadTokenOffers();
      } catch (error) {
        console.error("Error creating token offer:", error);
        alert("Error creating token offer: " + error.message);
      }
    }
    
    async function acceptFloorOffer(tokenId) {
      try {
        const floorOffer = await newMarketplaceContract.callStatic.floorOffers(NFT_ADDRESS, 0);
        if (floorOffer.offerAmount.eq(0)) {
          alert("No hay una floor offer activa para esta colección");
          return;
        }
        const owner = await nftContract.ownerOf(tokenId);
        if (owner.toLowerCase() !== userAccount.toLowerCase()) {
          alert("No eres el propietario de este token");
          return;
        }
        const approvedAddress = await nftContract.getApproved(tokenId);
        if (approvedAddress.toLowerCase() !== NEW_MARKET_ADDRESS.toLowerCase()) {
          const txApprove = await nftContract.approve(NEW_MARKET_ADDRESS, tokenId);
          await txApprove.wait();
          console.log("NFT específico aprobado para el nuevo marketplace");
        }
        console.log("Aceptando floor offer para token:", tokenId);
        const tx = await newMarketplaceContract.acceptFloorOffer(
          NFT_ADDRESS,
          tokenId,
          1,
          { gasLimit: 1000000 }
        );
        await tx.wait();
        alert("¡Floor offer aceptada exitosamente!");
        const modal = bootstrap.Modal.getInstance(document.getElementById('nftModal'));
        modal.hide();
        loadNFTs();
      } catch (error) {
        console.error("Error aceptando floor offer:", error);
        if (error.message.includes("revert")) {
          alert("Error: La transacción fue revertida. Verifica que el token esté aprobado y que seas el propietario.");
        } else {
          alert("Error aceptando floor offer: " + error.message);
        }
      }
    }
    
    async function loadFloorOffers() {
      const container = document.getElementById('floorOffersContent');
      try {
        console.log("Checking floor offers for address:", userAccount);
        const floorOffer = await newMarketplaceContract.callStatic.floorOffers(NFT_ADDRESS, 0);
        console.log("Floor offer data:", {
          amount: floorOffer.offerAmount.toString(),
          buyer: floorOffer.buyer,
          active: floorOffer.active,
          userAccount: userAccount
        });
        const buyerAddress = floorOffer.buyer.toLowerCase();
        const userAddress = userAccount.toLowerCase();
        if (floorOffer.offerAmount.eq(0)) {
          container.innerHTML = '<p class="text-center text-muted">No active floor offers found</p>';
          return;
        }
        const offerAmount = ethers.utils.formatUnits(floorOffer.offerAmount, 18);
        let html = `
          <div class="list-group">
            <div class="list-group-item">
              <div class="d-flex justify-content-between align-items-center">
                <div>
                  <h6 class="mb-1">Collection Floor Offer</h6>
                  <p class="mb-1">${offerAmount} $ADRIAN</p>
                  <small class="text-muted">
                    ${buyerAddress === userAddress ? 'Your offer - Valid for any token in the collection' : `Offer by: ${floorOffer.buyer.substring(0, 6)}...${floorOffer.buyer.substring(38)}`}
                  </small>
                </div>
                ${buyerAddress === userAddress ? `
                  <button class="btn btn-danger btn-sm" onclick="cancelFloorOffer()">
                    Cancel Floor Offer
                  </button>
                ` : ''}
              </div>
            </div>
          </div>
        `;
        container.innerHTML = html;
      } catch (error) {
        console.error("Error loading floor offers:", error);
        container.innerHTML = '<p class="text-center text-muted">No active floor offers found</p>';
      }
    }
    
    async function cancelFloorOffer() {
      try {
        const tx = await newMarketplaceContract.setFloorOffer(NFT_ADDRESS, 0, { gasLimit: 1000000 });
        await tx.wait();
        alert("Floor offer cancelled successfully!");
        loadFloorOffers();
      } catch (error) {
        console.error("Error cancelling floor offer:", error);
        alert("Error cancelling floor offer: " + error.message);
      }
    }
    
    async function acceptTokenOffer(collection, tokenId, offerId) {
      try {
        const owner = await nftContract.ownerOf(tokenId);
        if (owner.toLowerCase() !== userAccount.toLowerCase()) {
          alert("You are not the owner of this token");
          return;
        }
        const approvedAddress = await nftContract.getApproved(tokenId);
        if (approvedAddress.toLowerCase() !== NEW_MARKET_ADDRESS.toLowerCase()) {
          const txApprove = await nftContract.approve(NEW_MARKET_ADDRESS, tokenId);
          await txApprove.wait();
          console.log("NFT approved for the new marketplace");
        }
        const tx = await newMarketplaceContract.acceptTokenOffer(
          collection,
          tokenId,
          offerId,
          1,
          { gasLimit: 1000000 }
        );
        await tx.wait();
        alert("Token offer accepted successfully!");
        const modal = bootstrap.Modal.getInstance(document.getElementById('nftModal'));
        modal.hide();
        loadNFTs();
      } catch (error) {
        console.error("Error accepting token offer:", error);
        alert("Error accepting token offer: " + error.message);
      }
    }
    
    document.addEventListener('DOMContentLoaded', async () => {
      await initContracts();
      loadNFTs();
    });

    // Función para cambiar el tema
    function toggleTheme() {
      const html = document.documentElement;
      const themeButton = document.getElementById('themeButton');
      const themeButtonText = document.getElementById('themeButtonText');
      const isDark = html.getAttribute('data-theme') === 'dark';
      
      if (!isDark) {
        html.setAttribute('data-theme', 'dark');
        localStorage.setItem('theme', 'dark');
        themeButtonText.textContent = 'LightMode';
        themeButton.classList.remove('btn-outline-dark');
        themeButton.classList.add('btn-dark');
      } else {
        html.removeAttribute('data-theme');
        localStorage.setItem('theme', 'light');
        themeButtonText.textContent = 'DarkMode';
        themeButton.classList.remove('btn-dark');
        themeButton.classList.add('btn-secondary');
      }
    }

    // Cargar el tema guardado
    document.addEventListener('DOMContentLoaded', () => {
      const savedTheme = localStorage.getItem('theme');
      const html = document.documentElement;
      const themeButton = document.getElementById('themeButton');
      const themeButtonText = document.getElementById('themeButtonText');
      
      if (savedTheme === 'dark') {
        html.setAttribute('data-theme', 'dark');
        themeButtonText.textContent = 'LightMode';
        themeButton.classList.remove('btn-outline-dark');
        themeButton.classList.add('btn-dark');
      } else {
        themeButtonText.textContent = 'DarkMode';
        themeButton.classList.remove('btn-dark');
        themeButton.classList.add('btn-secondary');
      }
    });
  </script>
</body>
</html>