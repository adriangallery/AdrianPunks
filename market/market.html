<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AdrianPunks Market v3.1</title>
  <link rel="icon" type="image/x-icon" href="favicon.ico">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
  <link rel="stylesheet" href="styles.css">
  <!-- Load ethers.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/5.7.2/ethers.umd.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
</head>
<body>
  <!-- Include the menu -->
  <div id="menu-container"></div>
  <script>
    // Load the menu
    fetch('components/menu.html')
      .then(response => response.text())
      .then(html => {
        document.getElementById('menu-container').innerHTML = html;
        // Load menu.js after menu HTML is loaded
        const script = document.createElement('script');
        script.src = 'components/menu.js';
        document.head.appendChild(script);
      })
      .catch(error => console.error('Error loading menu:', error));
  </script>

  <!-- Main Container for NFT Grid and additional info -->
  <div class="container">
    <h2 id="tokenBalance" style="margin-top:10px;">Balance: Loading...</h2>
    <div id="floorOfferSection" style="cursor:pointer; margin-bottom:20px;">
      <span id="floorOfferText">Highest floor offer: -- $ADRIAN</span>
    </div>
    <div class="nft-grid" id="nftGrid"></div>
  </div>

  <!-- Modal to show NFT details and actions -->
  <div class="modal fade" id="nftModal" tabindex="-1" aria-labelledby="nftModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
      <div class="modal-content" id="nftModalContent">
        <!-- Modal content will be dynamically inserted -->
      </div>
    </div>
  </div>

  <!-- Bootstrap JS -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
  
  <!-- Main Script: NFT loading and Contract Interactions -->
  <script>
    /*********** Global Variables and Contract Setup ***********/
    let nftData = [];
    let provider, signer, userAccount;
    let tokenContract, nftContract, marketplaceContract;
    
    // Contract addresses and ABIs (update these if needed)
    const TOKEN_ADDRESS  = "0x7E99075Ce287F1cF8cBCAaa6A1C7894e404fD7Ea";
    const NFT_ADDRESS    = "0x4b9afc775d3D1969F727e81BA970B19b9e8054EF";
    const MARKET_ADDRESS = "0xcef57f12a949586ec2d7bbf9ee8a4b3a7e7abc73";
    
    const TOKEN_ABI = [
      "function balanceOf(address account) view returns (uint256)",
      "function approve(address spender, uint256 amount) external returns (bool)",
      "function allowance(address owner, address spender) view returns (uint256)"
    ];
    const NFT_ABI = [
      "function tokenURI(uint256 tokenId) view returns (string)"
    ];
    const MARKET_ABI = [
      "function buyNFT(uint256 tokenId) external",
      "function getNFTPrice(uint256 tokenId) view returns (uint256)",
      "function setFloorOffer(address collection, uint256 offerAmount) external",
      "function floorOffers(address) view returns (uint256 offerAmount, address buyer, bool active)",
      // Additional functions can be added here for offers, listings, etc.
      "function getActiveListings() view returns (uint256[])",
      "function listings(uint256) external view returns (uint256 id, address seller, address collection, uint256 tokenId, uint256 quantity, uint256 price, uint256 expirationTime)"
    ];
    
    async function initContracts() {
      if (window.ethereum) {
        provider = new ethers.providers.Web3Provider(window.ethereum);
        signer = provider.getSigner();
        userAccount = await signer.getAddress();
        tokenContract = new ethers.Contract(TOKEN_ADDRESS, TOKEN_ABI, signer);
        nftContract = new ethers.Contract(NFT_ADDRESS, NFT_ABI, signer);
        marketplaceContract = new ethers.Contract(MARKET_ADDRESS, MARKET_ABI, signer);
        updateTokenBalance();
        loadFloorOffer();
      } else {
        console.error("Ethereum provider not found.");
      }
    }
    
    /*********** NFT Data Loading and Display ***********/
    async function loadNFTs() {
      try {
        const response = await fetch('adrianpunks.json');
        if (!response.ok) {
          throw new Error('Error loading NFTs');
        }
        const data = await response.json();
        nftData = data.collection || [];
        displayNFTs(nftData);
      } catch (error) {
        console.error('Error:', error);
        document.getElementById('nftGrid').innerHTML = 
          `<div class="alert alert-danger">Error loading NFTs: ${error.message}</div>`;
      }
    }
    
    function displayNFTs(nfts) {
      const grid = document.getElementById('nftGrid');
      grid.innerHTML = '';
    
      if (!nfts || nfts.length === 0) {
        grid.innerHTML = '<div class="alert alert-info">No NFTs found</div>';
        return;
      }
    
      nfts.forEach(nft => {
        const card = document.createElement('div');
        card.className = 'card nft-card';
        card.innerHTML = `
          <img src="${nft.image}" class="card-img-top" alt="${nft.name}" onerror="this.src='placeholder.png'">
          <div class="card-body">
              <h5 class="card-title">${nft.name}</h5>
              <p class="card-text">Rarity: ${nft.rarity.toFixed(2)}</p>
              <button class="btn btn-primary" onclick="showNFTDetails('${nft.name}')">View Details</button>
          </div>
        `;
        grid.appendChild(card);
      });
    }
    
    function showNFTDetails(nftName) {
      fetch('adrianpunks.json')
        .then(response => response.json())
        .then(data => {
          const nft = data.collection.find(n => n.name === nftName);
          if (nft) {
            const modalContent = document.getElementById('nftModalContent');
            modalContent.innerHTML = `
              <div class="modal-header">
                <h5 class="modal-title">${nft.name}</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
              </div>
              <div class="modal-body">
                <img src="${nft.image}" class="img-fluid mb-3" alt="${nft.name}" onerror="this.src='placeholder.png'">
                <div class="nft-details">
                  <p><strong>Description:</strong> ${nft.description}</p>
                  <p><strong>Compiler:</strong> ${nft.compiler}</p>
                  <p><strong>Masterminds:</strong> ${nft.masterminds.join(', ')}</p>
                  <p><strong>Rarity:</strong> ${nft.rarity.toFixed(2)}</p>
                  <h6>Attributes:</h6>
                  <ul class="list-group">
                    ${nft.attributes.map(attr => 
                      `<li class="list-group-item">
                        <strong>${attr.trait_type}:</strong> ${attr.value}
                      </li>`
                    ).join('')}
                  </ul>
                  <button class="btn btn-success mt-3" onclick="buyNFT('${nft.name}')">Buy NFT</button>
                </div>
              </div>
            `;
            const modal = new bootstrap.Modal(document.getElementById('nftModal'));
            modal.show();
          }
        })
        .catch(error => {
          console.error('Error:', error);
          alert('Error loading NFT details');
        });
    }
    
    /*********** Contract Interaction Functions ***********/
    
    // Purchase NFT using Adrian Token
    async function buyNFT(nftName) {
      try {
        if (!marketplaceContract || !tokenContract) {
          alert("Please connect your wallet to continue.");
          return;
        }
        // Retrieve NFT info from JSON
        const response = await fetch('adrianpunks.json');
        const data = await response.json();
        const nft = data.collection.find(n => n.name === nftName);
        if (!nft) {
          alert("NFT not found.");
          return;
        }
        // Extract tokenId from NFT name (e.g. "AdrianPunks#1")
        const tokenId = parseInt(nft.name.split("#")[1]);
        // Get NFT price from the marketplace contract
        const price = await marketplaceContract.getNFTPrice(tokenId);
        console.log("NFT Price:", price.toString());
    
        // Check allowance and approve if necessary
        const currentAllowance = await tokenContract.allowance(userAccount, MARKET_ADDRESS);
        if (currentAllowance.lt(price)) {
          const txApprove = await tokenContract.approve(MARKET_ADDRESS, price);
          await txApprove.wait();
        }
    
        // Execute the purchase
        const txPurchase = await marketplaceContract.buyNFT(tokenId);
        await txPurchase.wait();
        alert("Purchase successful!");
      } catch (error) {
        console.error("Error purchasing NFT:", error);
        alert("Error purchasing NFT: " + error.message);
      }
    }
    
    // Update token balance display with formatted number
    async function updateTokenBalance() {
      try {
        const balanceRaw = await tokenContract.balanceOf(userAccount);
        const balance = parseFloat(ethers.utils.formatUnits(balanceRaw, 18));
        
        // Format the number
        let formattedBalance;
        if (balance >= 1000000) {
          formattedBalance = (balance / 1000000).toFixed(1) + 'M';
        } else if (balance >= 1000) {
          formattedBalance = (balance / 1000).toFixed(1) + 'K';
        } else {
          formattedBalance = balance.toFixed(1);
        }
        
        document.getElementById("tokenBalance").innerText = `Balance: ${formattedBalance} $ADRIAN`;
      } catch (error) {
        console.error("Error fetching token balance:", error);
        document.getElementById("tokenBalance").innerText = "Balance: Error";
      }
    }
    
    // Load floor offer and update display text
    async function loadFloorOffer() {
      try {
        const floorOffer = await marketplaceContract.floorOffers(NFT_ADDRESS);
        const offerAmount = floorOffer.offerAmount;
        const floorSection = document.getElementById("floorOfferSection");
        if (floorOffer.active && offerAmount.gt(0)) {
          document.getElementById("floorOfferText").innerText = 
            `Highest floor offer: ${ethers.utils.formatUnits(offerAmount, 18)} $ADRIAN`;
          floorSection.classList.remove("no-offer");
        } else {
          document.getElementById("floorOfferText").innerText = "No floor offer set";
          floorSection.classList.add("no-offer");
        }
      } catch (error) {
        console.error("Error loading floor offer:", error);
      }
    }
    
    // Example: Sweep floor function (buy multiple cheapest NFTs)
    async function sweepFloor() {
      if (!marketplaceContract) {
        alert("Please connect your wallet first.");
        return;
      }
      const countStr = prompt("How many tokens do you want to purchase from the floor?");
      const numTokens = parseInt(countStr);
      if (isNaN(numTokens) || numTokens <= 0) {
        alert("Invalid number. Please try again.");
        return;
      }
      try {
        const activeListings = await marketplaceContract.getActiveListings();
        let listingsArr = [];
        for (let i = 0; i < activeListings.length; i++) {
          const listing = await marketplaceContract.listings(activeListings[i]);
          // Check if listing is still active (using expirationTime)
          if (listing.expirationTime > Math.floor(Date.now() / 1000)) {
            listingsArr.push(listing);
          }
        }
        // Sort listings by price (lowest first)
        listingsArr.sort((a, b) => Number(a.price) - Number(b.price));
        let tokensBought = 0;
        for (let listing of listingsArr) {
          if (tokensBought >= numTokens) break;
          try {
            const requiredAmount = listing.price.div(listing.quantity);
            const currentAllowance = await tokenContract.allowance(userAccount, MARKET_ADDRESS);
            if (currentAllowance.lt(requiredAmount)) {
              const txApprove = await tokenContract.approve(MARKET_ADDRESS, requiredAmount);
              await txApprove.wait();
            }
            const txBuy = await marketplaceContract.buyNFT(listing.id, { gasLimit: 1000000 });
            await txBuy.wait();
            tokensBought++;
            console.log(`Token purchased from listing ${listing.id}`);
          } catch (err) {
            console.error("Error purchasing listing " + listing.id, err);
          }
        }
        alert(`Sweep Floor complete! You purchased ${tokensBought} token(s).`);
      } catch (error) {
        console.error("Error during Sweep Floor:", error);
        alert("Error during Sweep Floor: " + error.message);
      }
    }
    
    // Initialize contracts and load NFTs when page loads
    document.addEventListener('DOMContentLoaded', async () => {
      await initContracts();
      loadNFTs();
    });
  </script>
</body>
</html>