<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AdrianPunks Market v3.6</title>
  <link rel="icon" type="image/x-icon" href="favicon.ico">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
  <link rel="stylesheet" href="/market/styles.css">
  <style>
    #tokenBalance {
      margin-top: 10px;
    }
    @media (max-width: 768px) {
      #tokenBalance {
        margin-top: 70px;
      }
    }
    .modal-dialog {
      max-width: 500px;
    }
    .modal-body img {
      max-width: 300px;
      margin: 0 auto;
      display: block;
    }
    /* Asegurar que el backdrop se elimine correctamente */
    .modal-backdrop {
      opacity: 0.5;
    }
    body.modal-open {
      overflow: auto !important;
      padding-right: 0 !important;
    }
    .offer-form {
      transition: all 0.3s ease;
      opacity: 1;
      transform: translateY(0);
    }
    .offer-form.hiding {
      opacity: 0;
      transform: translateY(-10px);
    }
    .modal-body {
      max-height: 80vh;
      overflow-y: auto;
      scroll-behavior: smooth;
    }
    .trait-info {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .badge {
      font-size: 0.9em;
      padding: 8px 12px;
    }
  </style>
  <!-- Load ethers.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/5.7.2/ethers.umd.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
</head>
<body>
  <!-- Include the menu -->
  <div id="menu-container"></div>
  <script>
    // Load the menu
    fetch('components/menu.html')
      .then(response => response.text())
      .then(html => {
        document.getElementById('menu-container').innerHTML = html;
        // Load menu.js after menu HTML is loaded
        const script = document.createElement('script');
        script.src = 'components/menu.js';
        document.head.appendChild(script);
      })
      .catch(error => console.error('Error loading menu:', error));
  </script>

  <!-- Main Container -->
  <div class="container">
    <!-- Balance y Floor Offer Info -->
    <div class="info-section mb-4">
      <h2 id="tokenBalance" class="mb-2">Balance: Loading...</h2>
      <div id="floorOfferSection" class="text-secondary">
        <span id="floorOfferText">Highest floor offer: -- $ADRIAN</span>
      </div>
    </div>

    <!-- Botonera Principal Unificada -->
    <div class="main-actions mb-4">
      <div class="action-buttons">
        <button class="action-btn warning" onclick="openFloorOfferPopup()">
          <span class="d-none d-md-inline">Make Floor</span> Offer
        </button>
        <button class="action-btn info" onclick="openMyOffersModal()">
          <span class="d-none d-md-inline">My</span> Offers
        </button>
        <button class="action-btn secondary" onclick="openMyListingsModal()">
          <span class="d-none d-md-inline">My</span> Listings
        </button>
        <button class="action-btn dark" onclick="openRecentActivityModal()">
          <span class="d-none d-md-inline">Recent</span> Activity
        </button>
        <div class="dropdown">
          <button class="action-btn primary dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false">
            <span class="d-none d-md-inline">Filter by</span> Traits
          </button>
          <ul class="dropdown-menu p-3" id="traitFilterMenu">
            <div id="activeFilters" class="mb-2"></div>
            <div class="trait-categories" id="traitCategories">
              <!-- Categor√≠as de traits se cargar√°n din√°micamente -->
            </div>
            <div class="d-flex justify-content-between mt-2">
              <button class="btn btn-sm btn-danger" onclick="clearTraitFilters()">Clear Filters</button>
              <span class="text-muted" id="filteredCount"></span>
            </div>
          </ul>
        </div>
        <button class="action-btn outline" onclick="filterByActiveListings()">
          <span class="d-none d-md-inline">Show Listed</span><span class="d-md-none">Listed</span>
        </button>
        <button class="action-btn outline" onclick="sortByFloorPrice()">
          <span class="d-none d-md-inline">Sort by FP</span><span class="d-md-none">Sort FP</span>
        </button>
      </div>
    </div>

    <!-- NFT Grid -->
    <div class="nft-grid" id="nftGrid"></div>
  </div>

  <!-- Modal para NFT Details -->
  <div class="modal fade" id="nftModal" tabindex="-1" aria-labelledby="nftModalLabel" aria-hidden="true" data-bs-backdrop="static">
    <div class="modal-dialog modal-dialog-centered">
      <div class="modal-content" id="nftModalContent">
        <!-- Contenido cargado din√°micamente -->
      </div>
    </div>
  </div>

  <!-- Modal for My Offers -->
  <div class="modal fade" id="myOffersModal" tabindex="-1" aria-labelledby="myOffersModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered modal-xl">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title" id="myOffersModalLabel">My Active Offers</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body">
          <!-- Tabs para diferentes tipos de ofertas -->
          <ul class="nav nav-tabs mb-3 d-flex" id="offersTab" role="tablist">
            <li class="nav-item flex-equal" role="presentation">
              <button class="nav-link active w-100" id="listing-offers-tab" data-bs-toggle="tab" data-bs-target="#listing-offers" type="button" role="tab">
                Listing üìù
              </button>
            </li>
            <li class="nav-item flex-equal" role="presentation">
              <button class="nav-link w-100" id="token-offers-tab" data-bs-toggle="tab" data-bs-target="#token-offers" type="button" role="tab">
                Token üéØ
              </button>
            </li>
            <li class="nav-item flex-equal" role="presentation">
              <button class="nav-link w-100" id="floor-offers-tab" data-bs-toggle="tab" data-bs-target="#floor-offers" type="button" role="tab">
                Floor üí∞
              </button>
            </li>
            <li class="nav-item flex-equal" role="presentation">
              <button class="nav-link w-100" id="trait-offers-tab" data-bs-toggle="tab" data-bs-target="#trait-offers" type="button" role="tab">
                Trait üé®
              </button>
            </li>
          </ul>
          
          <style>
            .flex-equal {
              flex: 1 1 0;
            }
            #offersTab .nav-link {
              padding: 0.5rem;
              text-align: center;
              white-space: nowrap;
            }
          </style>

          <!-- Contenido de los tabs -->
          <div class="tab-content" id="offersTabContent">
            <!-- Listing Offers -->
            <div class="tab-pane fade show active" id="listing-offers" role="tabpanel">
              <div id="listingOffersContent">
                <div class="text-center">
                  <div class="spinner-border text-primary" role="status">
                    <span class="visually-hidden">Loading...</span>
                  </div>
                </div>
              </div>
            </div>
            
            <!-- Token Offers -->
            <div class="tab-pane fade" id="token-offers" role="tabpanel">
              <div id="tokenOffersContent">
                <div class="text-center">
                  <div class="spinner-border text-primary" role="status">
                    <span class="visually-hidden">Loading...</span>
                  </div>
                </div>
              </div>
            </div>

            <!-- Floor Offers -->
            <div class="tab-pane fade" id="floor-offers" role="tabpanel">
              <div id="floorOffersContent">
                <div class="text-center">
                  <div class="spinner-border text-primary" role="status">
                    <span class="visually-hidden">Loading...</span>
                  </div>
                </div>
              </div>
            </div>
            
            <!-- Trait Offers -->
            <div class="tab-pane fade" id="trait-offers" role="tabpanel">
              <div id="traitOffersContent">
                <div class="text-center">
                  <div class="spinner-border text-primary" role="status">
                    <span class="visually-hidden">Loading...</span>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Modal for My Listings -->
  <div class="modal fade" id="myListingsModal" tabindex="-1" aria-labelledby="myListingsModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title" id="myListingsModalLabel">My Listings</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body" id="myListingsContent">
          <!-- Listado de mis listados -->
        </div>
      </div>
    </div>
  </div>

  <!-- Modal for Recent Activity -->
  <div class="modal fade" id="recentActivityModal" tabindex="-1" aria-labelledby="recentActivityModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered modal-lg">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title" id="recentActivityModalLabel">Recent Activity</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body" id="recentActivityContent">
          <!-- Datos de actividad reciente se inyectan aqu√≠ -->
        </div>
      </div>
    </div>
  </div>

  <!-- Modal for Floor Offer Popup -->
  <div class="modal fade" id="floorOfferPopupModal" tabindex="-1" aria-labelledby="floorOfferPopupModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title" id="floorOfferPopupModalLabel">Make Floor Offer for the Collection</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body" id="floorOfferPopupContent">
          <div id="floorOfferForm">
            <label>Offer Amount (in $ADRIAN): 
              <input type="text" id="popupOfferAmount" value="10000" class="form-control">
            </label>
            <button class="btn btn-primary mt-2" onclick="makeFloorOfferPopup()">Submit Floor Offer</button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Bootstrap JS -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
  
  <!-- Main Script: NFT loading and Contract Interactions -->
  <script>
    /*********** Global Variables and Contract Setup ***********/
    let nftData = [];
    let provider, signer, userAccount;
    let tokenContract, nftContract, marketplaceContract;
    
    // Direcciones de contratos y ABIs
    const TOKEN_ADDRESS  = "0x7E99075Ce287F1cF8cBCAaa6A1C7894e404fD7Ea";
    const NFT_ADDRESS    = "0x79BE8AcdD339C7b92918fcC3fd3875b5Aaad7566";
    const MARKET_ADDRESS = "0xe746999546e65c44543a443cc1e9b5fe168ede5d";
    const ACTIVITY_LOGGER_ADDRESS = "0x5B38Da6a701c568545dCfcB03FcB875f56beddC4";
    const OFFER_MANAGER_ADDRESS = "0x5B38Da6a701c568545dCfcB03FcB875f56beddC4";

    // ABI actualizado del contrato AdrianMarket (se incluyen las funciones nuevas)
    const MARKET_ABI = [
      // Funciones de listings
      "function createListing(address collection, uint256 tokenId, uint256 quantity, uint256 price, uint256 duration, uint8 nftTypeParam) external",
      "function cancelListing(uint256 listingId) external",
      "function buyListing(uint256 listingId, uint256 purchaseQuantity) external",
      "function editListing(uint256 listingId, uint256 newPrice, uint256 newDuration) external",
      "function getActiveListingsDetailed() external view returns (tuple(uint256 id, address seller, address collection, uint256 tokenId, uint256 quantity, uint256 price, uint256 expirationTime, uint8 nftType)[])",
      "function getMyListings(address seller) external view returns (tuple(uint256 id, address seller, address collection, uint256 tokenId, uint256 quantity, uint256 price, uint256 expirationTime, uint8 nftType)[])",
      // Floor offers
      "function floorOffers(address) external view returns (uint256 offerAmount, address buyer, bool active)",
      "function setFloorOffer(address collection, uint256 offerAmount) external",
      "function acceptFloorOffer(address collection, uint256 tokenId, uint8 nftTypeParam) external",
      // Listing Offers
      "function makeOffer(uint256 listingId, uint256 quantity, uint256 offerAmount) external",
      "function withdrawOffer(uint256 listingId) external",
      "function acceptOffer(uint256 listingId, address buyer) external",
      "function getMyListingOffers(address buyer) external view returns (tuple(uint256 id, uint256 listingId, address buyer, uint256 tokenId, uint256 quantity, uint256 offerAmount, bool exists)[])",
      // Token offers (para tokens no listados)
      "function makeTokenOffer(address collection, uint256 tokenId, uint256 quantity, uint256 offerAmount) external",
      "function withdrawTokenOffer(address collection, uint256 tokenId) external",
      "function acceptTokenOffer(address collection, uint256 tokenId, uint256 offerId, uint8 nftTypeParam) external",
      "function getMyTokenOffers(address buyer) external view returns (tuple(uint256 id, address collection, uint256 tokenId, uint256 quantity, uint256 offerAmount, address buyer, bool exists)[])",
      // Trait offers (ya expuestas p√∫blicamente)
      "function setTraitOffer(string traitType, string traitValue, uint256 offerAmount) external",
      "function cancelTraitOffer(string traitType, string traitValue) external",
      "function acceptTraitOffer(string traitType, string traitValue, uint256 tokenId, address collection, uint8 nftTypeParam) external",
      // Read admin values
      "function commissionPercentage() external view returns (uint256)",
      "function commissionWallet() external view returns (address)",
      "function paymentToken() external view returns (address)"
    ];

    // ABI de los tokens y NFTs (no modificadas)
    const TOKEN_ABI = [
      "function balanceOf(address account) view returns (uint256)",
      "function approve(address spender, uint256 amount) external returns (bool)",
      "function allowance(address owner, address spender) view returns (uint256)"
    ];
    const NFT_ABI = [
      "function tokenURI(uint256 tokenId) view returns (string)",
      "function ownerOf(uint256 tokenId) view returns (address)",
      "function getApproved(uint256 tokenId) view returns (address)",
      "function approve(address to, uint256 tokenId) external",
      "function isApprovedForAll(address owner, address operator) view returns (bool)",
      "function setApprovalForAll(address operator, bool approved) external"
    ];
    
    async function initContracts() {
      if (window.ethereum) {
        provider = new ethers.providers.Web3Provider(window.ethereum);
        signer = provider.getSigner();
        userAccount = await signer.getAddress();
        tokenContract = new ethers.Contract(TOKEN_ADDRESS, TOKEN_ABI, signer);
        nftContract = new ethers.Contract(NFT_ADDRESS, NFT_ABI, signer);
        marketplaceContract = new ethers.Contract(MARKET_ADDRESS, MARKET_ABI, signer);
        updateTokenBalance();
        loadFloorOffer();
      } else {
        console.error("Ethereum provider not found.");
      }
    }
    
    /*********** NFT Data Loading and Display ***********/
    // Variables para el filtrado de traits
    let activeFilters = new Map();
    let allTraits = new Map();

    // Funci√≥n para extraer todos los traits √∫nicos
    function extractTraits(nfts) {
      allTraits.clear();
      nfts.forEach(nft => {
        if (nft.attributes) {
          nft.attributes.forEach(attr => {
            if (!allTraits.has(attr.trait_type)) {
              allTraits.set(attr.trait_type, new Set());
            }
            allTraits.get(attr.trait_type).add(attr.value);
          });
        }
      });
      return allTraits;
    }

    // Funci√≥n para renderizar el men√∫ de filtros
    function renderTraitFilters() {
      const container = document.getElementById('traitCategories');
      container.innerHTML = '';
      
      allTraits.forEach((values, traitType) => {
        const categoryDiv = document.createElement('div');
        categoryDiv.className = 'trait-category mb-2';
        categoryDiv.innerHTML = `
          <h6 class="trait-category-title mb-2">${traitType}</h6>
          <div class="trait-values" style="max-height: 150px; overflow-y: auto;">
            ${Array.from(values).map(value => `
              <div class="trait-value-item">
                <button class="btn btn-sm ${activeFilters.get(traitType) === value ? 'btn-primary' : 'btn-outline-secondary'} w-100 text-start mb-1"
                  onclick="toggleTraitFilter('${traitType}', '${value}')">
                  ${value}
                </button>
              </div>
            `).join('')}
          </div>
        `;
        container.appendChild(categoryDiv);
      });
      
      updateActiveFiltersDisplay();
    }

    // Funci√≥n para actualizar la visualizaci√≥n de filtros activos
    function updateActiveFiltersDisplay() {
      const container = document.getElementById('activeFilters');
      if (activeFilters.size === 0) {
        container.innerHTML = '<small class="text-muted">No active filters</small>';
        return;
      }
      
      container.innerHTML = Array.from(activeFilters.entries()).map(([type, value]) => `
        <span class="badge bg-primary me-1 mb-1">
          ${type}: ${value}
          <button type="button" class="btn-close btn-close-white" style="font-size: 0.5em;" 
            onclick="removeTraitFilter('${type}')"></button>
        </span>
      `).join('');
    }

    // Funci√≥n para alternar un filtro
    function toggleTraitFilter(traitType, value) {
      if (activeFilters.get(traitType) === value) {
        activeFilters.delete(traitType);
      } else {
        activeFilters.set(traitType, value);
      }
      renderTraitFilters();
      filterAndDisplayNFTs();
    }

    // Funci√≥n para eliminar un filtro espec√≠fico
    function removeTraitFilter(traitType) {
      activeFilters.delete(traitType);
      renderTraitFilters();
      filterAndDisplayNFTs();
    }

    // Funci√≥n para limpiar todos los filtros
    function clearTraitFilters() {
      activeFilters.clear();
      renderTraitFilters();
      filterAndDisplayNFTs();
    }

    // Funci√≥n para filtrar y mostrar NFTs
    function filterAndDisplayNFTs() {
      if (!nftData) return;
      
      let filteredNFTs = nftData;
      if (activeFilters.size > 0) {
        filteredNFTs = nftData.filter(nft => {
          return Array.from(activeFilters.entries()).every(([type, value]) => {
            return nft.attributes.some(attr => 
              attr.trait_type === type && attr.value === value
            );
          });
        });
      }
      
      document.getElementById('filteredCount').textContent = 
        `Showing ${filteredNFTs.length} of ${nftData.length}`;
      
      displayNFTs(filteredNFTs);
    }

    // Variables globales
    let activeListingsData = [];
    let currentSortOrder = 'asc';

    // Funci√≥n para cargar y almacenar listings activos
    async function loadActiveListings() {
      try {
        activeListingsData = await marketplaceContract.getActiveListingsDetailed();
        // Filtrar solo los listings que no han expirado
        activeListingsData = activeListingsData.filter(listing => 
          listing.expirationTime > Math.floor(Date.now() / 1000)
        );
        console.log("Active listings loaded:", activeListingsData);
      } catch (error) {
        console.error("Error loading active listings:", error);
        activeListingsData = [];
      }
    }

    // Modificar la funci√≥n loadNFTs para incluir la carga de listings
    async function loadNFTs() {
      try {
        const response = await fetch('adrianpunks.json');
        if (!response.ok) {
          throw new Error('Error loading NFTs');
        }
        const data = await response.json();
        nftData = data.collection || [];
        
        // Cargar listings activos
        await loadActiveListings();
        
        // Extraer y renderizar los filtros
        extractTraits(nftData);
        renderTraitFilters();
        
        // Mostrar los NFTs
        filterAndDisplayNFTs();
      } catch (error) {
        console.error('Error:', error);
        document.getElementById('nftGrid').innerHTML = 
          `<div class="alert alert-danger">Error loading NFTs: ${error.message}</div>`;
      }
    }

    // Funci√≥n para filtrar por tokens listados
    async function filterByActiveListings() {
      const button = document.querySelector('button[onclick="filterByActiveListings()"]');
      const isActive = button.classList.contains('active');
      
      if (!isActive) {
        // Activar filtro
        button.classList.remove('btn-outline-primary');
        button.classList.add('btn-primary', 'active');
        
        // Filtrar NFTs que tienen listings activos
        const listedNFTs = nftData.filter(nft => {
          const tokenId = parseInt(nft.name.split('#')[1]);
          return activeListingsData.some(listing => 
            listing.tokenId.toString() === tokenId.toString()
          );
        });
        
        displayNFTs(listedNFTs);
      } else {
        // Desactivar filtro
        button.classList.remove('btn-primary', 'active');
        button.classList.add('btn-outline-primary');
        filterAndDisplayNFTs(); // Mostrar todos los NFTs
      }
    }

    // Funci√≥n para ordenar por precio
    async function sortByFloorPrice() {
      const button = document.querySelector('button[onclick="sortByFloorPrice()"]');
      
      // Cambiar el orden de clasificaci√≥n
      currentSortOrder = currentSortOrder === 'asc' ? 'desc' : 'asc';
      
      // Actualizar el texto del bot√≥n
      button.classList.remove('btn-outline-primary');
      button.classList.add('btn-primary');
      const arrowDirection = currentSortOrder === 'asc' ? '‚Üë' : '‚Üì';
      button.innerHTML = `<span class="d-none d-md-inline">Sort by FP</span><span class="d-md-none">Sort FP</span> ${arrowDirection}`;
      
      // Crear un mapa de precios para acceso r√°pido
      const priceMap = new Map();
      activeListingsData.forEach(listing => {
        const currentPrice = priceMap.get(listing.tokenId.toString());
        const thisPrice = parseFloat(ethers.utils.formatUnits(listing.price, 18));
        if (!currentPrice || thisPrice < currentPrice) {
          priceMap.set(listing.tokenId.toString(), thisPrice);
        }
      });
      
      // Ordenar NFTs
      const sortedNFTs = [...nftData].sort((a, b) => {
        const tokenIdA = a.name.split('#')[1];
        const tokenIdB = b.name.split('#')[1];
        const priceA = priceMap.get(tokenIdA) || Number.MAX_VALUE;
        const priceB = priceMap.get(tokenIdB) || Number.MAX_VALUE;
        
        return currentSortOrder === 'asc' 
          ? priceA - priceB 
          : priceB - priceA;
      });
      
      displayNFTs(sortedNFTs);
    }

    // Modificar displayNFTs para mostrar el precio si est√° listado
    function displayNFTs(nfts) {
      const grid = document.getElementById('nftGrid');
      grid.innerHTML = '';
    
      if (!nfts || nfts.length === 0) {
        grid.innerHTML = '<div class="alert alert-info">No NFTs found</div>';
        return;
      }
    
      nfts.forEach(nft => {
        const tokenId = nft.name.split('#')[1];
        const listing = activeListingsData.find(l => 
          l.tokenId.toString() === tokenId &&
          l.expirationTime > Math.floor(Date.now() / 1000)
        );

        const card = document.createElement('div');
        card.className = 'card nft-card';
        card.style.cursor = 'pointer';
        card.onclick = () => showNFTDetails(nft.name);
        card.innerHTML = `
          <img src="${nft.image}" class="card-img-top" alt="${nft.name}" onerror="this.src='placeholder.png'">
          <div class="card-body">
            <h5 class="card-title">${nft.name}</h5>
            <p class="card-text">Rarity: ${nft.rarity.toFixed(2)}</p>
            ${listing ? `
              <div class="price-tag alert alert-info py-1 px-2 mb-0">
                <small>Listed: ${parseFloat(ethers.utils.formatUnits(listing.price, 18)).toLocaleString('en-US', {minimumFractionDigits: 1, maximumFractionDigits: 1})} $ADRIAN</small>
              </div>
            ` : ''}
          </div>
        `;
        grid.appendChild(card);
      });
    }
    
    async function showNFTDetails(nftName) {
      try {
        const data = await fetch('adrianpunks.json').then(response => response.json());
        const nft = data.collection.find(n => n.name === nftName);
        if (!nft) throw new Error("NFT not found");

        const tokenId = parseInt(nft.name.split('#')[1]);
        
        // Verificar si el usuario es propietario del token usando el contrato AdrianPunks
        let ownershipStatus = '';
        let isOwner = false;
        try {
          const owner = await nftContract.ownerOf(tokenId);
          isOwner = owner.toLowerCase() === userAccount.toLowerCase();
          ownershipStatus = isOwner ? 
            `<div class="alert alert-success">Eres el propietario de este token</div>` : 
            `<div class="alert alert-info">No eres el propietario de este token</div>`;
        } catch (error) {
          ownershipStatus = `<div class="alert alert-warning">No se pudo verificar la propiedad del token</div>`;
        }
        
        // Obtener listings activos para este token
        const activeListings = await marketplaceContract.getActiveListingsDetailed();
        const tokenListing = activeListings.find(listing => 
          listing.tokenId.toString() === tokenId.toString() &&
          listing.expirationTime > Math.floor(Date.now() / 1000)
        );

        // Obtener ofertas activas para este token
        const tokenOffers = await marketplaceContract.getMyTokenOffers(userAccount);
        const relevantOffers = tokenOffers.filter(offer => 
          offer.exists && 
          offer.tokenId.toString() === tokenId.toString()
        );

        // Obtener floor offer
        const floorOffer = await marketplaceContract.floorOffers(NFT_ADDRESS);

        // Construir el contenido del modal
        const modalContent = document.getElementById('nftModalContent');
        modalContent.innerHTML = `
          <div class="modal-header">
            <h5 class="modal-title">${nft.name}</h5>
            <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
          </div>
          <div class="modal-body text-center">
            <img src="${nft.image}" class="img-fluid rounded mb-3" alt="${nft.name}" onerror="this.src='placeholder.png'">
            <div class="nft-details text-start">
              ${ownershipStatus}
              <p><strong>Description:</strong> ${nft.description}</p>
              <p><strong>Compiler:</strong> ${nft.compiler}</p>
              <p><strong>Masterminds:</strong> ${nft.masterminds.join(', ')}</p>
              <p><strong>Rarity:</strong> ${nft.rarity.toFixed(2)}</p>

              <!-- Secci√≥n de Listing Activo -->
              ${tokenListing ? `
                <div class="listing-info alert alert-info">
                  <h6>Active Listing</h6>
                  <p>Price: ${ethers.utils.formatUnits(tokenListing.price, 18)} $ADRIAN</p>
                  <p>Seller: ${tokenListing.seller.substring(0, 6)}...${tokenListing.seller.substring(38)}</p>
                  <p>Expires: ${new Date(tokenListing.expirationTime * 1000).toLocaleString()}</p>
                  ${tokenListing.seller.toLowerCase() !== userAccount.toLowerCase() ? `
                    <button class="btn btn-success btn-sm" onclick="buyNFT('${nft.name}')">Buy NFT</button>
                  ` : `
                    <button class="btn btn-danger btn-sm" onclick="cancelListing(${tokenListing.id})">Cancel Listing</button>
                  `}
                </div>
              ` : ''}

              <!-- Secci√≥n de Ofertas -->
              <div class="offers-section mt-3">
                <h6>Active Offers</h6>
                ${relevantOffers && relevantOffers.length > 0 ? `
                  <div class="list-group">
                    ${relevantOffers.map(offer => `
                      <div class="list-group-item">
                        <p class="mb-1">Offer: ${ethers.utils.formatUnits(offer.offerAmount, 18)} $ADRIAN</p>
                        <small>By: ${offer.buyer.substring(0, 6)}...${offer.buyer.substring(38)}</small>
                        ${isOwner ? `
                          <button class="btn btn-success btn-sm float-end" 
                            onclick="acceptTokenOffer('${NFT_ADDRESS}', ${tokenId}, ${offer.id})">
                            Accept Offer
                          </button>
                        ` : ''}
                        ${offer.buyer.toLowerCase() === userAccount.toLowerCase() ? `
                          <button class="btn btn-danger btn-sm float-end" 
                            onclick="cancelTokenOffer('${NFT_ADDRESS}', ${tokenId})">
                            Cancel Offer
                          </button>
                        ` : ''}
                      </div>
                    `).join('')}
                  </div>
                ` : '<p class="text-muted">No direct offers for this token</p>'}

                ${floorOffer && floorOffer.active ? `
                  <div class="floor-offer-info mt-2">
                    <p class="mb-1">Floor Offer: ${ethers.utils.formatUnits(floorOffer.offerAmount, 18)} $ADRIAN</p>
                    <small>By: ${floorOffer.buyer.substring(0, 6)}...${floorOffer.buyer.substring(38)}</small>
                    ${isOwner ? `
                      <button class="btn btn-success btn-sm" onclick="acceptFloorOffer(${tokenId})">
                        Accept Floor Offer
                      </button>
                    ` : ''}
                  </div>
                ` : ''}
              </div>

              <!-- Secci√≥n de Atributos -->
              <h6 class="mt-3">Attributes:</h6>
              <ul class="list-group">
                ${nft.attributes.map(attr => 
                  `<li class="list-group-item d-flex justify-content-between align-items-center">
                    <div>
                      <strong>${attr.trait_type}:</strong> ${attr.value}
                    </div>
                    <button class="btn btn-sm btn-outline-primary" 
                      onclick="openTraitOfferForm('${attr.trait_type}', '${attr.value}')" 
                      title="Make Trait Offer">
                      üí∞
                    </button>
                  </li>`
                ).join('')}
              </ul>

              <div class="text-center mt-3">
                ${isOwner ? `
                  ${!tokenListing ? `
                    <button class="btn btn-primary w-100 mb-2" onclick="openListingForm('${nft.name}', 'AdrianMarket')">
                      List for Sale
                    </button>
                  ` : ''}
                ` : ''}
                <button class="btn btn-secondary w-100" onclick="openMakeTokenOfferForm('${nft.name.split('#')[1]}')">
                  Make Token Offer
                </button>
              </div>
            </div>
          </div>
        `;

        const modal = new bootstrap.Modal(document.getElementById('nftModal'));
        const modalElement = document.getElementById('nftModal');
        modalElement.addEventListener('hidden.bs.modal', function () {
          document.body.classList.remove('modal-open');
          const backdrop = document.querySelector('.modal-backdrop');
          if (backdrop) { backdrop.remove(); }
          modalContent.innerHTML = '';
        });
        modal.show();
      } catch (error) {
        console.error('Error:', error);
        alert('Error loading NFT details: ' + error.message);
      }
    }

    // Funci√≥n para cancelar un listing
    async function cancelListing(listingId) {
      try {
        const tx = await marketplaceContract.cancelListing(listingId, { gasLimit: 1000000 });
        await tx.wait();
        alert("Listing cancelled successfully!");
        const modal = bootstrap.Modal.getInstance(document.getElementById('nftModal'));
        modal.hide();
        loadNFTs(); // Recargar la vista
      } catch (error) {
        console.error("Error cancelling listing:", error);
        alert("Error cancelling listing: " + error.message);
      }
    }

    // Funci√≥n para abrir el formulario de listing
    function openListingForm(nftName, marketType) {
      const tokenId = nftName.split('#')[1];
      const modalBody = document.querySelector('.modal-body');
      
      // Eliminar cualquier formulario existente
      const existingForm = document.querySelector('.listing-form');
      if (existingForm) existingForm.remove();

      const listingForm = document.createElement('div');
      listingForm.className = 'listing-form mt-4 border-top pt-3';
      listingForm.innerHTML = `
        <h5 class="mb-3">List Token #${tokenId} for Sale in ${marketType}</h5>
        <div class="form-group mb-3">
          <label class="mb-2">Price (in $ADRIAN):</label>
          <input type="text" id="listingPrice" class="form-control" value="10000">
        </div>
        <div class="form-group mb-3">
          <label class="mb-2">Duration (in days):</label>
          <input type="number" id="listingDuration" class="form-control" value="7" min="1">
        </div>
        <div class="d-flex justify-content-between">
          <button class="btn btn-primary" onclick="createListing('${tokenId}')">Create Listing</button>
          <button class="btn btn-outline-secondary" onclick="closeListingForm()">Cancel</button>
        </div>
      `;
      modalBody.appendChild(listingForm);
      
      // Hacer scroll al formulario
      listingForm.scrollIntoView({ behavior: 'smooth', block: 'center' });
    }

    // Funci√≥n para cerrar el formulario de listing
    function closeListingForm() {
      const form = document.querySelector('.listing-form');
      if (form) form.remove();
    }

    // Funci√≥n para crear un listing
    async function createListing(tokenId) {
      try {
        const price = ethers.utils.parseUnits(document.getElementById('listingPrice').value, 18);
        const duration = document.getElementById('listingDuration').value * 24 * 60 * 60; // Convertir d√≠as a segundos
        
        // Verificar y aprobar el NFT espec√≠fico si es necesario
        const approvedAddress = await nftContract.getApproved(tokenId);
        if (approvedAddress.toLowerCase() !== MARKET_ADDRESS.toLowerCase()) {
          const txApprove = await nftContract.approve(MARKET_ADDRESS, tokenId);
          await txApprove.wait();
          console.log("NFT espec√≠fico aprobado para el marketplace");
        }

        const tx = await marketplaceContract.createListing(
          NFT_ADDRESS,
          tokenId,
          1, // quantity
          price,
          duration,
          1, // nftType = 1 para ERC721
          { gasLimit: 1000000 }
        );
        await tx.wait();
        alert("Listing created successfully!");
        const modal = bootstrap.Modal.getInstance(document.getElementById('nftModal'));
        modal.hide();
        loadNFTs(); // Recargar la vista
      } catch (error) {
        console.error("Error creating listing:", error);
        alert("Error creating listing: " + error.message);
      }
    }
    
    /*********** Contract Interaction Functions ***********/
    
    async function buyNFT(nftName) {
      try {
        if (!marketplaceContract || !tokenContract) {
          alert("Please connect your wallet to continue.");
          return;
        }
        const response = await fetch('adrianpunks.json');
        const data = await response.json();
        const nft = data.collection.find(n => n.name === nftName);
        if (!nft) { alert("NFT not found."); return; }
        const tokenId = parseInt(nft.name.split("#")[1]);
        const price = await marketplaceContract.buyListing(tokenId, 1);
        console.log("NFT Price:", price.toString());
        const currentAllowance = await tokenContract.allowance(userAccount, MARKET_ADDRESS);
        if (currentAllowance.lt(price)) {
          const txApprove = await tokenContract.approve(MARKET_ADDRESS, price);
          await txApprove.wait();
        }
        const txPurchase = await marketplaceContract.buyListing(tokenId, 1);
        await txPurchase.wait();
        alert("Purchase successful!");
      } catch (error) {
        console.error("Error purchasing NFT:", error);
        alert("Error purchasing NFT: " + error.message);
      }
    }
    
    async function updateTokenBalance() {
      try {
        const balanceRaw = await tokenContract.balanceOf(userAccount);
        const balance = parseFloat(ethers.utils.formatUnits(balanceRaw, 18));
        let formattedBalance = balance >= 1000000 ? (balance / 1000000).toFixed(1) + 'M' :
                              balance >= 1000 ? (balance / 1000).toFixed(1) + 'K' :
                              balance.toFixed(1);
        document.getElementById("tokenBalance").innerText = `Balance: ${formattedBalance} $ADRIAN`;
      } catch (error) {
        console.error("Error fetching token balance:", error);
        document.getElementById("tokenBalance").innerText = "Balance: Error";
      }
    }
    
    async function loadFloorOffer() {
      try {
        const floorOffer = await marketplaceContract.floorOffers(NFT_ADDRESS);
        const offerAmount = floorOffer.offerAmount;
        const floorSection = document.getElementById("floorOfferSection");
        if (floorOffer.active && offerAmount.gt(0)) {
          document.getElementById("floorOfferText").innerText = 
            `Highest floor offer: ${ethers.utils.formatUnits(offerAmount, 18)} $ADRIAN`;
          floorSection.classList.remove("no-offer");
        } else {
          document.getElementById("floorOfferText").innerText = "No floor offer set";
          floorSection.classList.add("no-offer");
        }
      } catch (error) {
        console.error("Error loading floor offer:", error);
      }
    }
    
    async function sweepFloor() {
      if (!marketplaceContract) {
        alert("Please connect your wallet first.");
        return;
      }
      const countStr = prompt("How many tokens do you want to purchase from the floor?");
      const numTokens = parseInt(countStr);
      if (isNaN(numTokens) || numTokens <= 0) {
        alert("Invalid number. Please try again.");
        return;
      }
      try {
        const activeListings = await marketplaceContract.getActiveListingsDetailed();
        let listingsArr = activeListings.filter(listing => listing.expirationTime > Math.floor(Date.now() / 1000));
        listingsArr.sort((a, b) => Number(a.price) - Number(b.price));
        let tokensBought = 0;
        for (let listing of listingsArr) {
          if (tokensBought >= numTokens) break;
          try {
            const requiredAmount = listing.price.div(listing.quantity);
            const currentAllowance = await tokenContract.allowance(userAccount, MARKET_ADDRESS);
            if (currentAllowance.lt(requiredAmount)) {
              const txApprove = await tokenContract.approve(MARKET_ADDRESS, requiredAmount);
              await txApprove.wait();
            }
            const txBuy = await marketplaceContract.buyListing(listing.id, 1, { gasLimit: 1000000 });
            await txBuy.wait();
            tokensBought++;
            console.log(`Token purchased from listing ${listing.id}`);
          } catch (err) {
            console.error("Error purchasing listing " + listing.id, err);
          }
        }
        alert(`Sweep Floor complete! You purchased ${tokensBought} token(s).`);
      } catch (error) {
        console.error("Error during Sweep Floor:", error);
        alert("Error during Sweep Floor: " + error.message);
      }
    }
    
    /*********** New Functions for Frontend Reads and Offers ***********/
    
    // Function to open the "My Listings" modal and load user's listings
    async function openMyListingsModal() {
      if (!marketplaceContract) {
        alert("Please connect your wallet first.");
        return;
      }
      try {
        const myListings = await marketplaceContract.getMyListings(userAccount);
        let contentHtml = "";
        if (myListings.length === 0) {
          contentHtml = "<p class='text-center'>No listings found.</p>";
        } else {
          contentHtml = "<ul class='list-group'>";
          myListings.forEach(listing => {
            contentHtml += `<li class="list-group-item">
              Listing #${listing.id.toString()} - Token #${listing.tokenId.toString()} - Price: ${ethers.utils.formatUnits(listing.price, 18)} $ADRIAN - Qty: ${listing.quantity.toString()}
            </li>`;
          });
          contentHtml += "</ul>";
        }
        document.getElementById("myListingsContent").innerHTML = contentHtml;
        let modal = new bootstrap.Modal(document.getElementById('myListingsModal'));
        modal.show();
      } catch (e) {
        console.error(e);
        alert("Error loading my listings: " + e.message);
      }
    }
    
    // Function to open the "Recent Activity" modal loading active listings
    async function openRecentActivityModal() {
      if (!marketplaceContract) {
        alert("Please connect your wallet first.");
        return;
      }
      try {
        const activeListings = await marketplaceContract.getActiveListingsDetailed();
        let contentHtml = "";
        if (activeListings.length === 0) {
          contentHtml = "<p class='text-center'>No active listings.</p>";
        } else {
          contentHtml = "<ul class='list-group'>";
          activeListings.forEach(listing => {
            contentHtml += `<li class="list-group-item">
              Listing #${listing.id.toString()} - Seller: ${listing.seller} - Token #${listing.tokenId.toString()} - Price: ${ethers.utils.formatUnits(listing.price, 18)} $ADRIAN - Qty: ${listing.quantity.toString()} - Expires: ${new Date(listing.expirationTime * 1000).toLocaleString()}
            </li>`;
          });
          contentHtml += "</ul>";
        }
        document.getElementById("recentActivityContent").innerHTML = contentHtml;
        let modal = new bootstrap.Modal(document.getElementById('recentActivityModal'));
        modal.show();
      } catch (e) {
        console.error(e);
        alert("Error loading recent activity: " + e.message);
      }
    }
    
    // Function to open the "My Offers" modal (combining listing and token offers)
    async function openMyOffersModal() {
      if (!marketplaceContract || !userAccount) {
        alert("Please connect your wallet first.");
        return;
      }

      const modal = new bootstrap.Modal(document.getElementById('myOffersModal'));
      modal.show();

      // Cargar datos cuando se muestra el modal
      loadMyOffers();

      // Agregar event listeners para los tabs
      document.querySelectorAll('#offersTab button').forEach(button => {
        button.addEventListener('click', (e) => {
          const tabId = e.target.getAttribute('data-bs-target').substring(1);
          if (tabId === 'listing-offers') loadListingOffers();
          else if (tabId === 'token-offers') loadTokenOffers();
          else if (tabId === 'floor-offers') loadFloorOffers();
          else if (tabId === 'trait-offers') loadTraitOffers();
        });
      });
    }

    // Funci√≥n para cargar todas las ofertas
    async function loadMyOffers() {
      loadListingOffers();
      loadTokenOffers();
      loadFloorOffers();
      loadTraitOffers();
    }

    // Funci√≥n para cargar ofertas de listings
    async function loadListingOffers() {
      const container = document.getElementById('listingOffersContent');
      try {
        const offers = await marketplaceContract.getMyListingOffers(userAccount);
        
        if (offers.length === 0) {
          container.innerHTML = '<p class="text-center text-muted">No active listing offers found</p>';
          return;
        }

        let html = '<div class="list-group">';
        for (const offer of offers) {
          if (!offer.exists) continue;
          
          const offerAmount = ethers.utils.formatUnits(offer.offerAmount, 18);
          html += `
            <div class="list-group-item">
              <div class="d-flex justify-content-between align-items-center">
                <div>
                  <h6 class="mb-1">Offer on Listing #${offer.listingId.toString()}</h6>
                  <p class="mb-1">Token #${offer.tokenId.toString()} - ${offerAmount} $ADRIAN</p>
                  <small class="text-muted">Quantity: ${offer.quantity.toString()}</small>
                </div>
                <button class="btn btn-danger btn-sm" onclick="cancelListingOffer(${offer.listingId})">
                  Cancel Offer
                </button>
              </div>
            </div>
          `;
        }
        html += '</div>';
        container.innerHTML = html;
      } catch (error) {
        console.error("Error loading listing offers:", error);
        container.innerHTML = '<div class="alert alert-danger">Error loading listing offers</div>';
      }
    }

    // Funci√≥n para cargar ofertas de tokens
    async function loadTokenOffers() {
      const container = document.getElementById('tokenOffersContent');
      try {
        const offers = await marketplaceContract.getMyTokenOffers(userAccount);
        
        if (offers.length === 0) {
          container.innerHTML = '<p class="text-center text-muted">No active token offers found</p>';
          return;
        }

        let html = '<div class="list-group">';
        for (const offer of offers) {
          if (!offer.exists) continue;
          
          const offerAmount = ethers.utils.formatUnits(offer.offerAmount, 18);
          html += `
            <div class="list-group-item">
              <div class="d-flex justify-content-between align-items-center">
                <div>
                  <h6 class="mb-1">Offer on Token #${offer.tokenId.toString()}</h6>
                  <p class="mb-1">${offerAmount} $ADRIAN</p>
                  <small class="text-muted">Quantity: ${offer.quantity.toString()}</small>
                </div>
                <button class="btn btn-danger btn-sm" onclick="cancelTokenOffer('${offer.collection}', ${offer.tokenId})">
                  Cancel Offer
                </button>
              </div>
            </div>
          `;
        }
        html += '</div>';
        container.innerHTML = html;
      } catch (error) {
        console.error("Error loading token offers:", error);
        container.innerHTML = '<div class="alert alert-danger">Error loading token offers</div>';
      }
    }

    // Funci√≥n para cargar ofertas de traits
    async function loadTraitOffers() {
      const container = document.getElementById('traitOffersContent');
      // Por ahora mostraremos un mensaje ya que necesitamos implementar la funci√≥n en el contrato
      container.innerHTML = '<p class="text-center text-muted">Trait offers coming soon...</p>';
    }

    // Funci√≥n para cancelar una oferta de listing
    async function cancelListingOffer(listingId) {
      try {
        const tx = await marketplaceContract.withdrawOffer(listingId, { gasLimit: 1000000 });
        await tx.wait();
        alert("Offer cancelled successfully!");
        loadListingOffers(); // Recargar las ofertas
      } catch (error) {
        console.error("Error cancelling listing offer:", error);
        alert("Error cancelling offer: " + error.message);
      }
    }

    // Funci√≥n para cancelar una oferta de token
    async function cancelTokenOffer(collection, tokenId) {
      try {
        const tx = await marketplaceContract.withdrawTokenOffer(collection, tokenId, { gasLimit: 1000000 });
        await tx.wait();
        alert("Token offer cancelled successfully!");
        loadTokenOffers(); // Recargar las ofertas
      } catch (error) {
        console.error("Error cancelling token offer:", error);
        alert("Error cancelling token offer: " + error.message);
      }
    }
    
    // Floor Offer Popup function remains as before
    async function openFloorOfferPopup() {
      const modal = new bootstrap.Modal(document.getElementById('floorOfferPopupModal'));
      modal.show();
    }
    
    async function makeFloorOfferPopup() {
      const offerAmount = document.getElementById("popupOfferAmount").value;
      const offerAmountWei = ethers.utils.parseUnits(offerAmount, 18);
      try {
        const allowance = await tokenContract.allowance(userAccount, MARKET_ADDRESS);
        if (allowance.lt(offerAmountWei)) {
          const txApprove = await tokenContract.approve(MARKET_ADDRESS, offerAmountWei);
          await txApprove.wait();
          alert("Approved " + ethers.utils.formatUnits(offerAmountWei, 18) + " $ADRIAN tokens.");
        }
        const tx = await marketplaceContract.setFloorOffer(NFT_ADDRESS, offerAmountWei);
        await tx.wait();
        alert("Floor offer created successfully!");
        loadFloorOffer();
      } catch (error) {
        console.error("Error creating floor offer:", error);
        alert("Error creating floor offer: " + error.message);
      }
    }

    // Funci√≥n para cargar floor offers
    async function loadFloorOffers() {
      const container = document.getElementById('floorOffersContent');
      try {
        console.log("Checking floor offers for address:", userAccount);
        const floorOffer = await marketplaceContract.floorOffers(NFT_ADDRESS);
        console.log("Floor offer data:", {
          amount: floorOffer.offerAmount.toString(),
          buyer: floorOffer.buyer,
          active: floorOffer.active,
          userAccount: userAccount
        });
        
        // Convertir las direcciones a min√∫sculas para comparaci√≥n
        const buyerAddress = floorOffer.buyer.toLowerCase();
        const userAddress = userAccount.toLowerCase();
        
        if (!floorOffer.active) {
          container.innerHTML = '<p class="text-center text-muted">No active floor offers found</p>';
          return;
        }

        // Si hay una oferta activa, mostrarla incluso si no es del usuario actual
        const offerAmount = ethers.utils.formatUnits(floorOffer.offerAmount, 18);
        let html = `
          <div class="list-group">
            <div class="list-group-item">
              <div class="d-flex justify-content-between align-items-center">
                <div>
                  <h6 class="mb-1">Collection Floor Offer</h6>
                  <p class="mb-1">${offerAmount} $ADRIAN</p>
                  <small class="text-muted">
                    ${buyerAddress === userAddress ? 
                      'Your offer - Valid for any token in the collection' : 
                      `Offer by: ${floorOffer.buyer.substring(0, 6)}...${floorOffer.buyer.substring(38)}`}
                  </small>
                </div>
                ${buyerAddress === userAddress ? `
                  <button class="btn btn-danger btn-sm" onclick="cancelFloorOffer()">
                    Cancel Floor Offer
                  </button>
                ` : ''}
              </div>
            </div>
          </div>
        `;
        container.innerHTML = html;
      } catch (error) {
        console.error("Error loading floor offers:", error);
        container.innerHTML = `<div class="alert alert-danger">Error loading floor offers: ${error.message}</div>`;
      }
    }

    // Funci√≥n para cancelar floor offer
    async function cancelFloorOffer() {
      try {
        const tx = await marketplaceContract.setFloorOffer(NFT_ADDRESS, 0, { gasLimit: 1000000 });
        await tx.wait();
        alert("Floor offer cancelled successfully!");
        loadFloorOffers(); // Recargar las floor offers
      } catch (error) {
        console.error("Error cancelling floor offer:", error);
        alert("Error cancelling floor offer: " + error.message);
      }
    }

    // Funci√≥n para abrir el formulario de trait offer
    function openTraitOfferForm(traitType, traitValue) {
      const modalBody = document.querySelector('.modal-body');
      const existingForm = document.querySelector('.trait-offer-form');
      if (existingForm) existingForm.remove();

      const offerForm = document.createElement('div');
      offerForm.className = 'trait-offer-form mt-4 border-top pt-3';
      offerForm.innerHTML = `
        <h5 class="mb-3">Make Trait Offer</h5>
        <div class="form-group mb-3">
          <div class="trait-info mb-3">
            <span class="badge bg-primary me-2">${traitType}</span>
            <span class="badge bg-secondary">${traitValue}</span>
          </div>
          <label class="mb-2">Offer Amount (in $ADRIAN):</label>
          <input type="text" id="traitOfferAmount_${traitType}_${traitValue}" value="5000" class="form-control">
        </div>
        <div class="d-flex justify-content-between">
          <button class="btn btn-primary" onclick="makeTraitOffer('${traitType}', '${traitValue}')">
            Submit Trait Offer
          </button>
          <button class="btn btn-outline-secondary" onclick="closeTraitOfferForm()">
            Cancel
          </button>
        </div>
      `;
      modalBody.appendChild(offerForm);
      
      // Hacer scroll al formulario
      offerForm.scrollIntoView({ behavior: 'smooth', block: 'center' });
    }

    // Funci√≥n para cerrar el formulario de trait offer
    function closeTraitOfferForm() {
      const form = document.querySelector('.trait-offer-form');
      if (form) form.remove();
    }

    // Funci√≥n para hacer una trait offer
    async function makeTraitOffer(traitType, traitValue) {
      try {
        const offerAmount = document.getElementById(`traitOfferAmount_${traitType}_${traitValue}`).value;
        const offerAmountWei = ethers.utils.parseUnits(offerAmount, 18);

        // Verificar y aprobar tokens si es necesario
        const allowance = await tokenContract.allowance(userAccount, MARKET_ADDRESS);
        if (allowance.lt(offerAmountWei)) {
          const txApprove = await tokenContract.approve(MARKET_ADDRESS, offerAmountWei);
          await txApprove.wait();
          console.log("Approved tokens for trait offer");
        }

        const tx = await marketplaceContract.setTraitOffer(traitType, traitValue, offerAmountWei, { gasLimit: 1000000 });
        await tx.wait();
        alert("Trait offer created successfully!");
        closeTraitOfferForm();
      } catch (error) {
        console.error("Error creating trait offer:", error);
        alert("Error creating trait offer: " + error.message);
      }
    }

    // Funci√≥n para abrir el formulario de token offer
    function openMakeTokenOfferForm(tokenId) {
      const modalBody = document.querySelector('.modal-body');
      const existingForm = document.querySelector('.token-offer-form');
      if (existingForm) existingForm.remove();

      const offerForm = document.createElement('div');
      offerForm.className = 'token-offer-form mt-4 border-top pt-3';
      offerForm.innerHTML = `
        <h5 class="mb-3">Make Token Offer</h5>
        <div class="form-group mb-3">
          <div class="token-info mb-3">
            <span class="badge bg-primary">Token #${tokenId}</span>
          </div>
          <label class="mb-2">Offer Amount (in $ADRIAN):</label>
          <input type="text" id="tokenOfferAmount_${tokenId}" value="5000" class="form-control">
        </div>
        <div class="d-flex justify-content-between">
          <button class="btn btn-primary" onclick="makeTokenOffer('${tokenId}')">
            Submit Token Offer
          </button>
          <button class="btn btn-outline-secondary" onclick="closeTokenOfferForm()">
            Cancel
          </button>
        </div>
      `;
      modalBody.appendChild(offerForm);
      
      // Hacer scroll al formulario
      offerForm.scrollIntoView({ behavior: 'smooth', block: 'center' });
    }

    // Funci√≥n para cerrar el formulario de token offer
    function closeTokenOfferForm() {
      const form = document.querySelector('.token-offer-form');
      if (form) form.remove();
    }

    // Funci√≥n para hacer una token offer
    async function makeTokenOffer(tokenId) {
      try {
        const offerAmount = document.getElementById(`tokenOfferAmount_${tokenId}`).value;
        const offerAmountWei = ethers.utils.parseUnits(offerAmount, 18);

        // Verificar y aprobar tokens si es necesario
        const allowance = await tokenContract.allowance(userAccount, MARKET_ADDRESS);
        if (allowance.lt(offerAmountWei)) {
          const txApprove = await tokenContract.approve(MARKET_ADDRESS, offerAmountWei);
          await txApprove.wait();
          console.log("Approved tokens for token offer");
        }

        const tx = await marketplaceContract.makeTokenOffer(
          NFT_ADDRESS,
          tokenId,
          1, // quantity
          offerAmountWei,
          { gasLimit: 1000000 }
        );
        await tx.wait();
        alert("Token offer created successfully!");
        closeTokenOfferForm();
        loadTokenOffers(); // Recargar las ofertas
      } catch (error) {
        console.error("Error creating token offer:", error);
        alert("Error creating token offer: " + error.message);
      }
    }

    // Funci√≥n para aceptar una floor offer
    async function acceptFloorOffer(tokenId) {
      try {
        // Verificar si hay una floor offer activa
        const floorOffer = await marketplaceContract.floorOffers(NFT_ADDRESS);
        if (!floorOffer.active) {
          alert("No hay una floor offer activa para esta colecci√≥n");
          return;
        }

        // Verificar si el usuario es el propietario del token
        const owner = await nftContract.ownerOf(tokenId);
        if (owner.toLowerCase() !== userAccount.toLowerCase()) {
          alert("No eres el propietario de este token");
          return;
        }

        // Verificar y aprobar el NFT espec√≠fico si es necesario
        const approvedAddress = await nftContract.getApproved(tokenId);
        if (approvedAddress.toLowerCase() !== MARKET_ADDRESS.toLowerCase()) {
          const txApprove = await nftContract.approve(MARKET_ADDRESS, tokenId);
          await txApprove.wait();
          console.log("NFT espec√≠fico aprobado para el marketplace");
        }

        // Aceptar la floor offer
        console.log("Aceptando floor offer para token:", tokenId);
        const tx = await marketplaceContract.acceptFloorOffer(
          NFT_ADDRESS,
          tokenId,
          1, // nftType = 1 para ERC721
          { gasLimit: 1000000 }
        );
        await tx.wait();
        alert("¬°Floor offer aceptada exitosamente!");
        
        // Cerrar el modal y recargar la vista
        const modal = bootstrap.Modal.getInstance(document.getElementById('nftModal'));
        modal.hide();
        loadNFTs();
      } catch (error) {
        console.error("Error aceptando floor offer:", error);
        if (error.message.includes("revert")) {
          alert("Error: La transacci√≥n fue revertida. Verifica que el token est√© aprobado y que seas el propietario.");
        } else {
          alert("Error aceptando floor offer: " + error.message);
        }
      }
    }

    // Initialize contracts and load NFTs on page load
    document.addEventListener('DOMContentLoaded', async () => {
      await initContracts();
      loadNFTs();
    });
  </script>
</body>
</html>