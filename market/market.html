<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AdrianPunks Market v3.3</title>
  <link rel="icon" type="image/x-icon" href="favicon.ico">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
  <link rel="stylesheet" href="/market/styles.css">
  <style>
    #tokenBalance {
      margin-top: 10px;
    }
    @media (max-width: 768px) {
      #tokenBalance {
        margin-top: 70px;
      }
    }
    .modal-dialog {
      max-width: 500px;
    }
    .modal-body img {
      max-width: 300px;
      margin: 0 auto;
      display: block;
    }
    /* Asegurar que el backdrop se elimine correctamente */
    .modal-backdrop {
      opacity: 0.5;
    }
    body.modal-open {
      overflow: auto !important;
      padding-right: 0 !important;
    }
    .offer-form {
      transition: all 0.3s ease;
      opacity: 1;
      transform: translateY(0);
    }
    .offer-form.hiding {
      opacity: 0;
      transform: translateY(-10px);
    }
    .modal-body {
      max-height: 80vh;
      overflow-y: auto;
      scroll-behavior: smooth;
    }
    .trait-info {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .badge {
      font-size: 0.9em;
      padding: 8px 12px;
    }
  </style>
  <!-- Load ethers.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/5.7.2/ethers.umd.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
</head>
<body>
  <!-- Include the menu -->
  <div id="menu-container"></div>
  <script>
    // Load the menu
    fetch('components/menu.html')
      .then(response => response.text())
      .then(html => {
        document.getElementById('menu-container').innerHTML = html;
        // Load menu.js after menu HTML is loaded
        const script = document.createElement('script');
        script.src = 'components/menu.js';
        document.head.appendChild(script);
      })
      .catch(error => console.error('Error loading menu:', error));
  </script>

  <!-- Main Container -->
  <div class="container">
    <h2 id="tokenBalance">Balance: Loading...</h2>
    
    <!-- Trait Filter Dropdown -->
    <div class="trait-filters mb-4">
      <div class="dropdown d-inline-block me-2 mb-2">
        <button class="btn btn-secondary dropdown-toggle" type="button" id="traitFilterButton" data-bs-toggle="dropdown" aria-expanded="false">
          Filter by Traits üé≠
        </button>
        <div class="dropdown-menu p-3" id="traitFilterMenu" style="width: 300px;">
          <div id="activeFilters" class="mb-2"></div>
          <div class="trait-categories" id="traitCategories">
            <!-- Categor√≠as de traits se cargar√°n din√°micamente -->
          </div>
          <div class="d-flex justify-content-between mt-2">
            <button class="btn btn-sm btn-danger" onclick="clearTraitFilters()">Clear Filters</button>
            <span class="text-muted" id="filteredCount"></span>
          </div>
        </div>
      </div>
    </div>

    <!-- Botones para funciones adicionales -->
    <div class="mt-3 text-center mb-4">
      <div class="btn-group">
        <button class="btn btn-warning" onclick="openFloorOfferPopup()">Make Floor Offer üí∞</button>
        <button class="btn btn-info" onclick="openMyOffersModal()">My Offers üìù</button>
        <button class="btn btn-secondary" onclick="openMyListingsModal()">My Listings üìÉ</button>
        <button class="btn btn-dark" onclick="openRecentActivityModal()">Recent Activity üîÑ</button>
      </div>
    </div>

    <div id="floorOfferSection" style="cursor:pointer; margin-bottom:20px;">
      <span id="floorOfferText">Highest floor offer: -- $ADRIAN</span>
    </div>
    <div class="nft-grid" id="nftGrid"></div>
  </div>

  <!-- Modal para NFT Details -->
  <div class="modal fade" id="nftModal" tabindex="-1" aria-labelledby="nftModalLabel" aria-hidden="true" data-bs-backdrop="static">
    <div class="modal-dialog modal-dialog-centered">
      <div class="modal-content" id="nftModalContent">
        <!-- Contenido cargado din√°micamente -->
      </div>
    </div>
  </div>

  <!-- Modal for My Offers -->
  <div class="modal fade" id="myOffersModal" tabindex="-1" aria-labelledby="myOffersModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered modal-lg">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title" id="myOffersModalLabel">My Active Offers</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body">
          <!-- Tabs para diferentes tipos de ofertas -->
          <ul class="nav nav-tabs mb-3" id="offersTab" role="tablist">
            <li class="nav-item" role="presentation">
              <button class="nav-link active" id="listing-offers-tab" data-bs-toggle="tab" data-bs-target="#listing-offers" type="button" role="tab">
                Listing Offers üìù
              </button>
            </li>
            <li class="nav-item" role="presentation">
              <button class="nav-link" id="token-offers-tab" data-bs-toggle="tab" data-bs-target="#token-offers" type="button" role="tab">
                Token Offers üéØ
              </button>
            </li>
            <li class="nav-item" role="presentation">
              <button class="nav-link" id="trait-offers-tab" data-bs-toggle="tab" data-bs-target="#trait-offers" type="button" role="tab">
                Trait Offers üé®
              </button>
            </li>
          </ul>
          
          <!-- Contenido de los tabs -->
          <div class="tab-content" id="offersTabContent">
            <!-- Listing Offers -->
            <div class="tab-pane fade show active" id="listing-offers" role="tabpanel">
              <div id="listingOffersContent">
                <div class="text-center">
                  <div class="spinner-border text-primary" role="status">
                    <span class="visually-hidden">Loading...</span>
                  </div>
                </div>
              </div>
            </div>
            
            <!-- Token Offers -->
            <div class="tab-pane fade" id="token-offers" role="tabpanel">
              <div id="tokenOffersContent">
                <div class="text-center">
                  <div class="spinner-border text-primary" role="status">
                    <span class="visually-hidden">Loading...</span>
                  </div>
                </div>
              </div>
            </div>
            
            <!-- Trait Offers -->
            <div class="tab-pane fade" id="trait-offers" role="tabpanel">
              <div id="traitOffersContent">
                <div class="text-center">
                  <div class="spinner-border text-primary" role="status">
                    <span class="visually-hidden">Loading...</span>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Modal for My Listings -->
  <div class="modal fade" id="myListingsModal" tabindex="-1" aria-labelledby="myListingsModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title" id="myListingsModalLabel">My Listings</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body" id="myListingsContent">
          <!-- Listado de mis listados -->
        </div>
      </div>
    </div>
  </div>

  <!-- Modal for Recent Activity -->
  <div class="modal fade" id="recentActivityModal" tabindex="-1" aria-labelledby="recentActivityModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered modal-lg">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title" id="recentActivityModalLabel">Recent Activity</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body" id="recentActivityContent">
          <!-- Datos de actividad reciente se inyectan aqu√≠ -->
        </div>
      </div>
    </div>
  </div>

  <!-- Modal for Floor Offer Popup -->
  <div class="modal fade" id="floorOfferPopupModal" tabindex="-1" aria-labelledby="floorOfferPopupModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title" id="floorOfferPopupModalLabel">Make Floor Offer for the Collection</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body" id="floorOfferPopupContent">
          <div id="floorOfferForm">
            <label>Offer Amount (in $ADRIAN): 
              <input type="text" id="popupOfferAmount" value="10000" class="form-control">
            </label>
            <button class="btn btn-primary mt-2" onclick="makeFloorOfferPopup()">Submit Floor Offer</button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Bootstrap JS -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
  
  <!-- Main Script: NFT loading and Contract Interactions -->
  <script>
    /*********** Global Variables and Contract Setup ***********/
    let nftData = [];
    let provider, signer, userAccount;
    let tokenContract, nftContract, marketplaceContract;
    
    // Direcciones de contratos y ABIs
    const TOKEN_ADDRESS  = "0x7E99075Ce287F1cF8cBCAaa6A1C7894e404fD7Ea";
    const NFT_ADDRESS    = "0x4b9afc775d3D1969F727e81BA970B19b9e8054EF";
    // Nueva direcci√≥n de AdrianMarket
    const MARKET_ADDRESS = "0xe746999546e65c44543a443cc1e9b5fe168ede5d";

    // ABI actualizado del contrato AdrianMarket (se incluyen las funciones nuevas)
    const MARKET_ABI = [
      // Funciones de listings
      "function createListing(address collection, uint256 tokenId, uint256 quantity, uint256 price, uint256 duration, uint8 nftTypeParam) external",
      "function cancelListing(uint256 listingId) external",
      "function buyListing(uint256 listingId, uint256 purchaseQuantity) external",
      "function editListing(uint256 listingId, uint256 newPrice, uint256 newDuration) external",
      "function getActiveListingsDetailed() external view returns (tuple(uint256 id, address seller, address collection, uint256 tokenId, uint256 quantity, uint256 price, uint256 expirationTime, uint8 nftType)[])",
      "function getMyListings(address seller) external view returns (tuple(uint256 id, address seller, address collection, uint256 tokenId, uint256 quantity, uint256 price, uint256 expirationTime, uint8 nftType)[])",
      // Floor offers
      "function floorOffers(address) external view returns (uint256 offerAmount, address buyer, bool active)",
      "function setFloorOffer(address collection, uint256 offerAmount) external",
      "function acceptFloorOffer(address collection, uint256 tokenId, uint8 nftTypeParam) external",
      // Listing Offers
      "function makeOffer(uint256 listingId, uint256 quantity, uint256 offerAmount) external",
      "function withdrawOffer(uint256 listingId) external",
      "function acceptOffer(uint256 listingId, address buyer) external",
      "function getMyListingOffers(address buyer) external view returns (tuple(uint256 id, uint256 listingId, address buyer, uint256 tokenId, uint256 quantity, uint256 offerAmount, bool exists)[])",
      // Token offers (para tokens no listados)
      "function makeTokenOffer(address collection, uint256 tokenId, uint256 quantity, uint256 offerAmount) external",
      "function withdrawTokenOffer(address collection, uint256 tokenId) external",
      "function acceptTokenOffer(address collection, uint256 tokenId, uint256 offerId, uint8 nftTypeParam) external",
      "function getMyTokenOffers(address buyer) external view returns (tuple(uint256 id, address collection, uint256 tokenId, uint256 quantity, uint256 offerAmount, address buyer, bool exists)[])",
      // Trait offers (ya expuestas p√∫blicamente)
      "function setTraitOffer(string traitType, string traitValue, uint256 offerAmount) external",
      "function cancelTraitOffer(string traitType, string traitValue) external",
      "function acceptTraitOffer(string traitType, string traitValue, uint256 tokenId, address collection, uint8 nftTypeParam) external",
      // Read admin values
      "function commissionPercentage() external view returns (uint256)",
      "function commissionWallet() external view returns (address)",
      "function paymentToken() external view returns (address)"
    ];

    // ABI de los tokens y NFTs (no modificadas)
    const TOKEN_ABI = [
      "function balanceOf(address account) view returns (uint256)",
      "function approve(address spender, uint256 amount) external returns (bool)",
      "function allowance(address owner, address spender) view returns (uint256)"
    ];
    const NFT_ABI = [
      "function tokenURI(uint256 tokenId) view returns (string)"
    ];
    
    async function initContracts() {
      if (window.ethereum) {
        provider = new ethers.providers.Web3Provider(window.ethereum);
        signer = provider.getSigner();
        userAccount = await signer.getAddress();
        tokenContract = new ethers.Contract(TOKEN_ADDRESS, TOKEN_ABI, signer);
        nftContract = new ethers.Contract(NFT_ADDRESS, NFT_ABI, signer);
        marketplaceContract = new ethers.Contract(MARKET_ADDRESS, MARKET_ABI, signer);
        updateTokenBalance();
        loadFloorOffer();
      } else {
        console.error("Ethereum provider not found.");
      }
    }
    
    /*********** NFT Data Loading and Display ***********/
    // Variables para el filtrado
    let activeFilters = new Map(); // Map de trait_type -> value
    let allTraits = new Map(); // Map de trait_type -> Set de valores

    // Funci√≥n para extraer todos los traits √∫nicos
    function extractTraits(nfts) {
      allTraits.clear();
      nfts.forEach(nft => {
        if (nft.attributes) {
          nft.attributes.forEach(attr => {
            if (!allTraits.has(attr.trait_type)) {
              allTraits.set(attr.trait_type, new Set());
            }
            allTraits.get(attr.trait_type).add(attr.value);
          });
        }
      });
      return allTraits;
    }

    // Funci√≥n para renderizar el men√∫ de filtros
    function renderTraitFilters() {
      const container = document.getElementById('traitCategories');
      container.innerHTML = '';
      
      allTraits.forEach((values, traitType) => {
        const categoryDiv = document.createElement('div');
        categoryDiv.className = 'trait-category mb-2';
        categoryDiv.innerHTML = `
          <h6 class="trait-category-title mb-2">${traitType}</h6>
          <div class="trait-values" style="max-height: 150px; overflow-y: auto;">
            ${Array.from(values).map(value => `
              <div class="trait-value-item">
                <button class="btn btn-sm ${activeFilters.get(traitType) === value ? 'btn-primary' : 'btn-outline-secondary'} w-100 text-start mb-1"
                  onclick="toggleTraitFilter('${traitType}', '${value}')">
                  ${value}
                </button>
              </div>
            `).join('')}
          </div>
        `;
        container.appendChild(categoryDiv);
      });
      
      updateActiveFiltersDisplay();
    }

    // Funci√≥n para actualizar la visualizaci√≥n de filtros activos
    function updateActiveFiltersDisplay() {
      const container = document.getElementById('activeFilters');
      if (activeFilters.size === 0) {
        container.innerHTML = '<small class="text-muted">No active filters</small>';
        return;
      }
      
      container.innerHTML = Array.from(activeFilters.entries()).map(([type, value]) => `
        <span class="badge bg-primary me-1 mb-1">
          ${type}: ${value}
          <button type="button" class="btn-close btn-close-white" style="font-size: 0.5em;" 
            onclick="removeTraitFilter('${type}')"></button>
        </span>
      `).join('');
    }

    // Funci√≥n para alternar un filtro
    function toggleTraitFilter(traitType, value) {
      if (activeFilters.get(traitType) === value) {
        activeFilters.delete(traitType);
      } else {
        activeFilters.set(traitType, value);
      }
      renderTraitFilters();
      filterAndDisplayNFTs();
    }

    // Funci√≥n para eliminar un filtro espec√≠fico
    function removeTraitFilter(traitType) {
      activeFilters.delete(traitType);
      renderTraitFilters();
      filterAndDisplayNFTs();
    }

    // Funci√≥n para limpiar todos los filtros
    function clearTraitFilters() {
      activeFilters.clear();
      renderTraitFilters();
      filterAndDisplayNFTs();
    }

    // Funci√≥n para filtrar y mostrar NFTs
    function filterAndDisplayNFTs() {
      if (!nftData) return;
      
      let filteredNFTs = nftData;
      if (activeFilters.size > 0) {
        filteredNFTs = nftData.filter(nft => {
          return Array.from(activeFilters.entries()).every(([type, value]) => {
            return nft.attributes.some(attr => 
              attr.trait_type === type && attr.value === value
            );
          });
        });
      }
      
      document.getElementById('filteredCount').textContent = 
        `Showing ${filteredNFTs.length} of ${nftData.length}`;
      
      displayNFTs(filteredNFTs);
    }

    async function loadNFTs() {
      try {
        const response = await fetch('adrianpunks.json');
        if (!response.ok) {
          throw new Error('Error loading NFTs');
        }
        const data = await response.json();
        nftData = data.collection || [];
        
        // Extraer y renderizar los filtros
        extractTraits(nftData);
        renderTraitFilters();
        
        // Mostrar los NFTs
        filterAndDisplayNFTs();
      } catch (error) {
        console.error('Error:', error);
        document.getElementById('nftGrid').innerHTML = 
          `<div class="alert alert-danger">Error loading NFTs: ${error.message}</div>`;
      }
    }
    
    function displayNFTs(nfts) {
      const grid = document.getElementById('nftGrid');
      grid.innerHTML = '';
    
      if (!nfts || nfts.length === 0) {
        grid.innerHTML = '<div class="alert alert-info">No NFTs found</div>';
        return;
      }
    
      nfts.forEach(nft => {
        const card = document.createElement('div');
        card.className = 'card nft-card';
        card.innerHTML = `
          <img src="${nft.image}" class="card-img-top" alt="${nft.name}" onerror="this.src='placeholder.png'">
          <div class="card-body">
              <h5 class="card-title">${nft.name}</h5>
              <p class="card-text">Rarity: ${nft.rarity.toFixed(2)}</p>
              <button class="btn btn-primary" onclick="showNFTDetails('${nft.name}')">View Details</button>
          </div>
        `;
        grid.appendChild(card);
      });
    }
    
    function showNFTDetails(nftName) {
      fetch('adrianpunks.json')
        .then(response => response.json())
        .then(data => {
          const nft = data.collection.find(n => n.name === nftName);
          if (nft) {
            const modalContent = document.getElementById('nftModalContent');
            modalContent.innerHTML = `
              <div class="modal-header">
                <h5 class="modal-title">${nft.name}</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
              </div>
              <div class="modal-body text-center">
                <img src="${nft.image}" class="img-fluid rounded mb-3" alt="${nft.name}" onerror="this.src='placeholder.png'">
                <div class="nft-details text-start">
                  <p><strong>Description:</strong> ${nft.description}</p>
                  <p><strong>Compiler:</strong> ${nft.compiler}</p>
                  <p><strong>Masterminds:</strong> ${nft.masterminds.join(', ')}</p>
                  <p><strong>Rarity:</strong> ${nft.rarity.toFixed(2)}</p>
                  <h6>Attributes:</h6>
                  <ul class="list-group">
                    ${nft.attributes.map(attr => 
                      `<li class="list-group-item">
                        <strong>${attr.trait_type}:</strong> ${attr.value}
                        <button class="btn btn-sm btn-outline-primary" onclick="openTraitOfferForm('${attr.trait_type}', '${attr.value}')" title="Make Trait Offer">üí∞</button>
                      </li>`
                    ).join('')}
                  </ul>
                  <div class="text-center mt-3">
                    <button class="btn btn-success" onclick="buyNFT('${nft.name}')">Buy NFT</button>
                    <button class="btn btn-secondary" onclick="openMakeTokenOfferForm('${nft.name.split('#')[1]}')">Make Token Offer</button>
                  </div>
                </div>
              </div>
            `;
            const modal = new bootstrap.Modal(document.getElementById('nftModal'));
            const modalElement = document.getElementById('nftModal');
            modalElement.addEventListener('hidden.bs.modal', function () {
              document.body.classList.remove('modal-open');
              const backdrop = document.querySelector('.modal-backdrop');
              if (backdrop) { backdrop.remove(); }
              modalContent.innerHTML = '';
            });
            modal.show();
          }
        })
        .catch(error => {
          console.error('Error:', error);
          alert('Error loading NFT details');
        });
    }
    
    /*********** Contract Interaction Functions ***********/
    
    async function buyNFT(nftName) {
      try {
        if (!marketplaceContract || !tokenContract) {
          alert("Please connect your wallet to continue.");
          return;
        }
        const response = await fetch('adrianpunks.json');
        const data = await response.json();
        const nft = data.collection.find(n => n.name === nftName);
        if (!nft) { alert("NFT not found."); return; }
        const tokenId = parseInt(nft.name.split("#")[1]);
        const price = await marketplaceContract.buyListing(tokenId, 1);
        console.log("NFT Price:", price.toString());
        const currentAllowance = await tokenContract.allowance(userAccount, MARKET_ADDRESS);
        if (currentAllowance.lt(price)) {
          const txApprove = await tokenContract.approve(MARKET_ADDRESS, price);
          await txApprove.wait();
        }
        const txPurchase = await marketplaceContract.buyListing(tokenId, 1);
        await txPurchase.wait();
        alert("Purchase successful!");
      } catch (error) {
        console.error("Error purchasing NFT:", error);
        alert("Error purchasing NFT: " + error.message);
      }
    }
    
    async function updateTokenBalance() {
      try {
        const balanceRaw = await tokenContract.balanceOf(userAccount);
        const balance = parseFloat(ethers.utils.formatUnits(balanceRaw, 18));
        let formattedBalance = balance >= 1000000 ? (balance / 1000000).toFixed(1) + 'M' :
                              balance >= 1000 ? (balance / 1000).toFixed(1) + 'K' :
                              balance.toFixed(1);
        document.getElementById("tokenBalance").innerText = `Balance: ${formattedBalance} $ADRIAN`;
      } catch (error) {
        console.error("Error fetching token balance:", error);
        document.getElementById("tokenBalance").innerText = "Balance: Error";
      }
    }
    
    async function loadFloorOffer() {
      try {
        const floorOffer = await marketplaceContract.floorOffers(NFT_ADDRESS);
        const offerAmount = floorOffer.offerAmount;
        const floorSection = document.getElementById("floorOfferSection");
        if (floorOffer.active && offerAmount.gt(0)) {
          document.getElementById("floorOfferText").innerText = 
            `Highest floor offer: ${ethers.utils.formatUnits(offerAmount, 18)} $ADRIAN`;
          floorSection.classList.remove("no-offer");
        } else {
          document.getElementById("floorOfferText").innerText = "No floor offer set";
          floorSection.classList.add("no-offer");
        }
      } catch (error) {
        console.error("Error loading floor offer:", error);
      }
    }
    
    async function sweepFloor() {
      if (!marketplaceContract) {
        alert("Please connect your wallet first.");
        return;
      }
      const countStr = prompt("How many tokens do you want to purchase from the floor?");
      const numTokens = parseInt(countStr);
      if (isNaN(numTokens) || numTokens <= 0) {
        alert("Invalid number. Please try again.");
        return;
      }
      try {
        const activeListings = await marketplaceContract.getActiveListingsDetailed();
        let listingsArr = activeListings.filter(listing => listing.expirationTime > Math.floor(Date.now() / 1000));
        listingsArr.sort((a, b) => Number(a.price) - Number(b.price));
        let tokensBought = 0;
        for (let listing of listingsArr) {
          if (tokensBought >= numTokens) break;
          try {
            const requiredAmount = listing.price.div(listing.quantity);
            const currentAllowance = await tokenContract.allowance(userAccount, MARKET_ADDRESS);
            if (currentAllowance.lt(requiredAmount)) {
              const txApprove = await tokenContract.approve(MARKET_ADDRESS, requiredAmount);
              await txApprove.wait();
            }
            const txBuy = await marketplaceContract.buyListing(listing.id, 1, { gasLimit: 1000000 });
            await txBuy.wait();
            tokensBought++;
            console.log(`Token purchased from listing ${listing.id}`);
          } catch (err) {
            console.error("Error purchasing listing " + listing.id, err);
          }
        }
        alert(`Sweep Floor complete! You purchased ${tokensBought} token(s).`);
      } catch (error) {
        console.error("Error during Sweep Floor:", error);
        alert("Error during Sweep Floor: " + error.message);
      }
    }
    
    /*********** New Functions for Frontend Reads and Offers ***********/
    
    // Function to open the "My Listings" modal and load user's listings
    async function openMyListingsModal() {
      if (!marketplaceContract) {
        alert("Please connect your wallet first.");
        return;
      }
      try {
        const myListings = await marketplaceContract.getMyListings(userAccount);
        let contentHtml = "";
        if (myListings.length === 0) {
          contentHtml = "<p class='text-center'>No listings found.</p>";
        } else {
          contentHtml = "<ul class='list-group'>";
          myListings.forEach(listing => {
            contentHtml += `<li class="list-group-item">
              Listing #${listing.id.toString()} - Token #${listing.tokenId.toString()} - Price: ${ethers.utils.formatUnits(listing.price, 18)} $ADRIAN - Qty: ${listing.quantity.toString()}
            </li>`;
          });
          contentHtml += "</ul>";
        }
        document.getElementById("myListingsContent").innerHTML = contentHtml;
        let modal = new bootstrap.Modal(document.getElementById('myListingsModal'));
        modal.show();
      } catch (e) {
        console.error(e);
        alert("Error loading my listings: " + e.message);
      }
    }
    
    // Function to open the "Recent Activity" modal loading active listings
    async function openRecentActivityModal() {
      if (!marketplaceContract) {
        alert("Please connect your wallet first.");
        return;
      }
      try {
        const activeListings = await marketplaceContract.getActiveListingsDetailed();
        let contentHtml = "";
        if (activeListings.length === 0) {
          contentHtml = "<p class='text-center'>No active listings.</p>";
        } else {
          contentHtml = "<ul class='list-group'>";
          activeListings.forEach(listing => {
            contentHtml += `<li class="list-group-item">
              Listing #${listing.id.toString()} - Seller: ${listing.seller} - Token #${listing.tokenId.toString()} - Price: ${ethers.utils.formatUnits(listing.price, 18)} $ADRIAN - Qty: ${listing.quantity.toString()} - Expires: ${new Date(listing.expirationTime * 1000).toLocaleString()}
            </li>`;
          });
          contentHtml += "</ul>";
        }
        document.getElementById("recentActivityContent").innerHTML = contentHtml;
        let modal = new bootstrap.Modal(document.getElementById('recentActivityModal'));
        modal.show();
      } catch (e) {
        console.error(e);
        alert("Error loading recent activity: " + e.message);
      }
    }
    
    // Function to open the "My Offers" modal (combining listing and token offers)
    async function openMyOffersModal() {
      if (!marketplaceContract || !userAccount) {
        alert("Please connect your wallet first.");
        return;
      }

      const modal = new bootstrap.Modal(document.getElementById('myOffersModal'));
      modal.show();

      // Cargar datos cuando se muestra el modal
      loadMyOffers();

      // Agregar event listeners para los tabs
      document.querySelectorAll('#offersTab button').forEach(button => {
        button.addEventListener('click', (e) => {
          const tabId = e.target.getAttribute('data-bs-target').substring(1);
          if (tabId === 'listing-offers') loadListingOffers();
          else if (tabId === 'token-offers') loadTokenOffers();
          else if (tabId === 'trait-offers') loadTraitOffers();
        });
      });
    }

    // Funci√≥n para cargar todas las ofertas
    async function loadMyOffers() {
      loadListingOffers();
      loadTokenOffers();
      loadTraitOffers();
    }

    // Funci√≥n para cargar ofertas de listings
    async function loadListingOffers() {
      const container = document.getElementById('listingOffersContent');
      try {
        const offers = await marketplaceContract.getMyListingOffers(userAccount);
        
        if (offers.length === 0) {
          container.innerHTML = '<p class="text-center text-muted">No active listing offers found</p>';
          return;
        }

        let html = '<div class="list-group">';
        for (const offer of offers) {
          if (!offer.exists) continue;
          
          const offerAmount = ethers.utils.formatUnits(offer.offerAmount, 18);
          html += `
            <div class="list-group-item">
              <div class="d-flex justify-content-between align-items-center">
                <div>
                  <h6 class="mb-1">Offer on Listing #${offer.listingId.toString()}</h6>
                  <p class="mb-1">Token #${offer.tokenId.toString()} - ${offerAmount} $ADRIAN</p>
                  <small class="text-muted">Quantity: ${offer.quantity.toString()}</small>
                </div>
                <button class="btn btn-danger btn-sm" onclick="cancelListingOffer(${offer.listingId})">
                  Cancel Offer
                </button>
              </div>
            </div>
          `;
        }
        html += '</div>';
        container.innerHTML = html;
      } catch (error) {
        console.error("Error loading listing offers:", error);
        container.innerHTML = '<div class="alert alert-danger">Error loading listing offers</div>';
      }
    }

    // Funci√≥n para cargar ofertas de tokens
    async function loadTokenOffers() {
      const container = document.getElementById('tokenOffersContent');
      try {
        const offers = await marketplaceContract.getMyTokenOffers(userAccount);
        
        if (offers.length === 0) {
          container.innerHTML = '<p class="text-center text-muted">No active token offers found</p>';
          return;
        }

        let html = '<div class="list-group">';
        for (const offer of offers) {
          if (!offer.exists) continue;
          
          const offerAmount = ethers.utils.formatUnits(offer.offerAmount, 18);
          html += `
            <div class="list-group-item">
              <div class="d-flex justify-content-between align-items-center">
                <div>
                  <h6 class="mb-1">Offer on Token #${offer.tokenId.toString()}</h6>
                  <p class="mb-1">${offerAmount} $ADRIAN</p>
                  <small class="text-muted">Quantity: ${offer.quantity.toString()}</small>
                </div>
                <button class="btn btn-danger btn-sm" onclick="cancelTokenOffer('${offer.collection}', ${offer.tokenId})">
                  Cancel Offer
                </button>
              </div>
            </div>
          `;
        }
        html += '</div>';
        container.innerHTML = html;
      } catch (error) {
        console.error("Error loading token offers:", error);
        container.innerHTML = '<div class="alert alert-danger">Error loading token offers</div>';
      }
    }

    // Funci√≥n para cargar ofertas de traits
    async function loadTraitOffers() {
      const container = document.getElementById('traitOffersContent');
      // Por ahora mostraremos un mensaje ya que necesitamos implementar la funci√≥n en el contrato
      container.innerHTML = '<p class="text-center text-muted">Trait offers coming soon...</p>';
    }

    // Funci√≥n para cancelar una oferta de listing
    async function cancelListingOffer(listingId) {
      try {
        const tx = await marketplaceContract.withdrawOffer(listingId, { gasLimit: 1000000 });
        await tx.wait();
        alert("Offer cancelled successfully!");
        loadListingOffers(); // Recargar las ofertas
      } catch (error) {
        console.error("Error cancelling listing offer:", error);
        alert("Error cancelling offer: " + error.message);
      }
    }

    // Funci√≥n para cancelar una oferta de token
    async function cancelTokenOffer(collection, tokenId) {
      try {
        const tx = await marketplaceContract.withdrawTokenOffer(collection, tokenId, { gasLimit: 1000000 });
        await tx.wait();
        alert("Token offer cancelled successfully!");
        loadTokenOffers(); // Recargar las ofertas
      } catch (error) {
        console.error("Error cancelling token offer:", error);
        alert("Error cancelling token offer: " + error.message);
      }
    }
    
    // Floor Offer Popup function remains as before
    async function openFloorOfferPopup() {
      const modal = new bootstrap.Modal(document.getElementById('floorOfferPopupModal'));
      modal.show();
    }
    
    async function makeFloorOfferPopup() {
      const offerAmount = document.getElementById("popupOfferAmount").value;
      const offerAmountWei = ethers.utils.parseUnits(offerAmount, 18);
      try {
        const allowance = await tokenContract.allowance(userAccount, MARKET_ADDRESS);
        if (allowance.lt(offerAmountWei)) {
          const txApprove = await tokenContract.approve(MARKET_ADDRESS, offerAmountWei);
          await txApprove.wait();
          alert("Approved " + ethers.utils.formatUnits(offerAmountWei, 18) + " $ADRIAN tokens.");
        }
        const tx = await marketplaceContract.setFloorOffer(NFT_ADDRESS, offerAmountWei);
        await tx.wait();
        alert("Floor offer created successfully!");
        loadFloorOffer();
      } catch (error) {
        console.error("Error creating floor offer:", error);
        alert("Error creating floor offer: " + error.message);
      }
    }
    
    // Initialize contracts and load NFTs on page load
    document.addEventListener('DOMContentLoaded', async () => {
      await initContracts();
      loadNFTs();
    });
  </script>
</body>
</html>