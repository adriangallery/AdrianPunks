<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>$ADRIAN Ecosystem Activity</title>
  <link rel="icon" type="image/x-icon" href="../favicon.ico">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css">
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/5.7.2/ethers.umd.min.js"></script>
  <script src="./supabase-config.js"></script>
  <style>
    :root {
      --bg-color: #ffffff;
      --text-color: #333333;
      --card-bg: #ffffff;
      --border-color: #dee2e6;
    }

    [data-theme="dark"] {
      --bg-color: #1a1a1a;
      --text-color: #ffffff;
      --card-bg: #2d2d2d;
      --border-color: #404040;
    }

    .bg-purple {
      background-color: #9c27b0 !important;
    }

    body {
      background-color: var(--bg-color);
      color: var(--text-color);
      margin: 0;
      padding: 0;
    }

    #menu-container {
      margin: 0;
      padding: 0;
    }

    #menu-container .navbar {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      width: 100%;
      z-index: 1000;
    }

    .main-container {
      padding-top: 80px;
      min-height: 100vh;
    }

    @media (max-width: 768px) {
      .main-container {
        padding-top: 60px;
      }
    }

    /* Contenedor de lista de actividades - completamente plano, sin anidados */
    .activity-list-container {
      width: 100%;
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    /* Cada evento es completamente independiente - sin anidamiento */
    .activity-item {
      border: 1px solid var(--border-color);
      border-radius: 8px;
      padding: 1rem;
      background-color: var(--card-bg);
      /* Cada evento es un contenedor independiente */
      display: block;
      width: 100%;
      box-sizing: border-box;
      margin: 0;
      /* Sin dependencias de contenedores padre */
      position: relative;
    }

    .activity-item:hover {
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }

    .activity-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 0.5rem;
      flex-wrap: wrap;
      gap: 0.5rem;
    }

    .activity-badge {
      font-size: 0.75rem;
      padding: 0.25rem 0.5rem;
    }

    .activity-date {
      font-size: 0.85rem;
      color: #6c757d;
    }

    .activity-details {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      flex-wrap: wrap;
    }

    .nft-thumbnail {
      width: 48px;
      height: 48px;
      object-fit: contain;
      border-radius: 4px;
      border: 1px solid var(--border-color);
      background: var(--card-bg);
      flex-shrink: 0;
    }

    .activity-link {
      font-size: 0.85rem;
      text-decoration: none;
    }

    .load-more-container {
      text-align: center;
      padding: 2rem 1rem;
    }

    .loading-spinner {
      text-align: center;
      padding: 2rem;
    }

    /* Simple Tabs (sin Bootstrap) */
    .tabs-container {
      display: flex;
      gap: 0.5rem;
      margin-bottom: 1rem;
    }

    .tab-button {
      padding: 0.75rem 1.5rem;
      border: none;
      background: transparent;
      color: var(--text-color);
      cursor: pointer;
      border-bottom: 3px solid transparent;
      transition: all 0.2s;
      font-size: 1rem;
      opacity: 0.6;
    }

    .tab-button:hover {
      opacity: 0.8;
    }

    .tab-button.active {
      opacity: 1;
      border-bottom-color: #007bff;
      font-weight: 600;
    }

    .tab-content {
      display: none;
    }

    .tab-content.active {
      display: block;
    }

    @media (max-width: 768px) {
      .activity-item {
        padding: 0.75rem;
      }
      
      .activity-header {
        font-size: 0.9rem;
      }
      
      .activity-details {
        font-size: 0.85rem;
      }
      
      .nft-thumbnail {
        width: 40px;
        height: 40px;
      }
    }
  </style>
</head>
<body>
  <!-- Menu -->
  <div id="menu-container">
    <object data="../market/components/menu.html" type="text/html" style="width: 100%; height: auto;">
      <nav class="navbar navbar-expand-lg bg-light">
    <div class="container-fluid">
          <a class="navbar-brand" href="/">$ADRIAN</a>
    </div>
  </nav>
    </object>
    </div>

  <!-- Main Content -->
  <div class="main-container">
    <div class="container py-4">
      <h1 class="mb-4">$ADRIAN Ecosystem Activity</h1>

      <!-- Simple Tabs (sin Bootstrap) -->
      <div class="tabs-container mb-4" style="border-bottom: 2px solid var(--border-color);">
        <button class="tab-button active" onclick="showActivityTab()" id="tab-activity-btn">
          <i class="bi bi-list-ul"></i> Activity
        </button>
        <button class="tab-button" onclick="showStatisticsTab()" id="tab-statistics-btn">
          <i class="bi bi-graph-up"></i> Statistics
        </button>
    </div>

      <!-- Activity Tab Content -->
      <div id="activity-tab-content" class="tab-content active">
        <!-- Filters -->
        <div class="card mb-4">
          <div class="card-body">
            <div class="row g-3">
              <div class="col-md-3">
              <label class="form-label">Contract</label>
              <select id="filterContract" class="form-select">
                  <option value="all">All Contracts</option>
                  <option value="floorengine">FloorEngine</option>
                <option value="erc20">ERC20</option>
                <option value="adrianlabcore">AdrianZERO</option>
                <option value="erc1155">AdrianLAB</option>
                <option value="traitsextensions">Traits</option>
                <option value="adrianshop">Shop</option>
                <option value="adriannameregistry">AdrianNameRegistry</option>
                <option value="adrianserummodule">AdrianSerumModule</option>
                <option value="punkquest">PunkQuest</option>
                </select>
              </div>
              <div class="col-md-3">
              <label class="form-label">Event Type</label>
              <select id="filterEventType" class="form-select">
                  <option value="all">All Events</option>
                </select>
              </div>
              <div class="col-md-2">
              <label class="form-label">Date From</label>
              <input type="date" id="filterDateFrom" class="form-control">
              </div>
              <div class="col-md-2">
              <label class="form-label">Date To</label>
              <input type="date" id="filterDateTo" class="form-control">
              </div>
              <div class="col-md-2">
              <label class="form-label">Address</label>
              <input type="text" id="filterAddress" class="form-control" placeholder="0x...">
              </div>
            </div>
            <div class="row mt-3">
              <div class="col-12">
              <button class="btn btn-primary" onclick="applyFilters()">Apply Filters</button>
              <button class="btn btn-secondary ms-2" onclick="clearFilters()">Clear</button>
              </div>
            </div>
          </div>
        </div>

        <!-- Activity List - Fuera de contenedores anidados para mejor rendimiento -->
        <div id="activityListContainer" class="activity-list-container">
          <div class="loading-spinner">
            <div class="spinner-border" role="status">
              <span class="visually-hidden">Loading...</span>
            </div>
          </div>
        </div>

        <!-- Load More Button -->
        <div id="loadMoreContainer" class="load-more-container" style="display: none;">
          <button class="btn btn-primary btn-lg" onclick="loadMore()">
            <i class="bi bi-arrow-down-circle"></i> Load More
          </button>
        </div>
      </div> <!-- End Activity Tab -->

      <!-- Statistics Tab Content -->
      <div id="statistics-tab-content" class="tab-content" style="display: none;">
        <div class="text-center py-5">
          <p>Statistics tab - Coming soon</p>
            </div>
      </div> <!-- End Statistics Tab -->
          </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
  <script>
    // ============================================
    // CONFIGURATION
    // ============================================
    const SUPABASE_URL = window.SUPABASE_URL || 'YOUR_SUPABASE_URL';
    const SUPABASE_ANON_KEY = window.SUPABASE_ANON_KEY || 'YOUR_SUPABASE_ANON_KEY';

    const PAGE_SIZE = 10; // Items por pÃ¡gina
    const MAX_ITEMS_IN_DOM = 50; // MÃ¡ximo de items en el DOM
    const LOAD_IMAGES = true; // Activar carga de imÃ¡genes
    
    // Contract addresses
    const FLOOR_ENGINE_ADDRESS = '0x0351F7cBA83277E891D4a85Da498A7eACD764D58';
    const ERC20_ADDRESS = '0x7E99075Ce287F1cF8cBCAaa6A1C7894e404fD7Ea';
    const BURN_ADDRESS = '0x0000000000000000000000000000000000000000';
    const ADRIANLABCORE_ADDRESS = '0x6e369bf0e4e0c106192d606fb6d85836d684da75';
    const ERC1155_ADDRESS = '0x90546848474fb3c9fda3fdad887969bb244e7e58';
    const TRAITS_EXTENSIONS_ADDRESS = '0x0995c0dA1ca071b792E852b6Ec531b7cD7d1F8D6';
    const ADRIAN_SHOP_ADDRESS = '0x4b265927b1521995ce416bba3bed98231d2e946b';
    const ADRIAN_NAME_REGISTRY_ADDRESS = '0xaeC5ED33c88c1943BB7452aC4B571ad0b4c4068C';
    const ADRIAN_SERUM_MODULE_ADDRESS = '0x0000000000000000000000000000000000000000'; // Placeholder
    const PUNK_QUEST_ADDRESS = '0x0000000000000000000000000000000000000000'; // Placeholder

    // ============================================
    // STATE
    // ============================================
    let supabaseClient = null;
    let currentPage = 0;
    let hasMore = true;
    let isLoading = false;
    let allLoadedEvents = []; // Todos los eventos cargados
    let displayedEvents = []; // Eventos mostrados actualmente
    let addressTagsRules = {};
    let imageRules = {};
    let eventRules = {};
    let intersectionObserver = null;

    // Filters
    const filters = {
      contract: 'all',
      eventType: 'all',
      dateFrom: null,
      dateTo: null,
      address: null
    };

    // ============================================
    // INITIALIZATION
    // ============================================
    async function init() {
      console.log('ðŸš€ Inicializando aplicaciÃ³n...');
      
      // Inicializar Supabase
      if (SUPABASE_URL && SUPABASE_ANON_KEY && SUPABASE_URL !== 'YOUR_SUPABASE_URL') {
        supabaseClient = supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
        console.log('âœ… Supabase inicializado');
      } else {
        console.error('âŒ Credenciales de Supabase no configuradas');
        showError('Error: Credenciales de Supabase no configuradas');
        return;
      }

      // Cargar reglas
      await loadRules();

      // NO configurar Intersection Observer (desactivado para evitar crashes)
      // setupIntersectionObserver();

      // Cargar primera pÃ¡gina
      await loadFirstPage();
    }

    // ============================================
    // RULES LOADING
    // ============================================
    async function loadRules() {
      try {
        // Address tags
        const tagsResponse = await fetch('./rules/address-tags.json');
        if (tagsResponse.ok) {
          const data = await tagsResponse.json();
          addressTagsRules = data.addressTags || {};
        }

        // Image rules
        const imagesResponse = await fetch('./rules/image-rules.json');
        if (imagesResponse.ok) {
          const data = await imagesResponse.json();
          imageRules = data.imageRules || {};
        }

        // Event rules
        const eventsResponse = await fetch('./rules/event-rules.json');
        if (eventsResponse.ok) {
          const data = await eventsResponse.json();
          eventRules = data.eventRules || {};
        }
      } catch (error) {
        console.error('Error cargando reglas:', error);
      }
    }

    // ============================================
    // DATA LOADING
    // ============================================
    async function loadFirstPage() {
      if (isLoading) return;
      
      currentPage = 0;
      hasMore = true;
      allLoadedEvents = [];
      displayedEvents = [];
      
      showLoading();
      await loadMore();
    }

    async function loadMore() {
      if (isLoading || !hasMore) {
        console.log('â¸ï¸ Load More: isLoading=', isLoading, 'hasMore=', hasMore);
        return;
      }
      
      console.log('ðŸ“¥ Load More: Cargando pÃ¡gina', currentPage + 1);
      isLoading = true;
      updateLoadMoreButton();

      try {
        const pageSize = PAGE_SIZE;
        const offset = currentPage * pageSize;
        console.log(`ðŸ“Š Fetching events: offset=${offset}, limit=${pageSize}`);
        
        const newEvents = await fetchEvents(offset, pageSize);
        console.log(`âœ… Fetched ${newEvents.length} eventos`);
        
        if (newEvents.length === 0) {
          console.log('âš ï¸ No hay mÃ¡s eventos');
          hasMore = false;
        } else {
          allLoadedEvents = allLoadedEvents.concat(newEvents);
          currentPage++;
          console.log(`ðŸ“¦ Total eventos cargados: ${allLoadedEvents.length}, pÃ¡gina actual: ${currentPage}`);
          
          // Aplicar filtros y renderizar
          applyFiltersAndRender();
        }
      } catch (error) {
        console.error('âŒ Error cargando eventos:', error);
        showError('Error cargando eventos: ' + error.message);
      } finally {
        isLoading = false;
        hideLoading();
        updateLoadMoreButton();
        console.log('âœ… Load More completado');
      }
    }

    async function fetchEvents(offset, limit) {
      const events = [];
      
      // Para paginaciÃ³n correcta con mÃºltiples tablas, necesitamos:
      // 1. Cargar mÃ¡s eventos de cada tabla (limit * 2 para asegurar suficientes)
      // 2. Combinar todos
      // 3. Ordenar por timestamp
      // 4. Tomar slice(offset, offset + limit)
      const fetchLimit = limit * 2;
      
      // FloorEngine events
      if (filters.contract === 'all' || filters.contract === 'floorengine') {
          // Listing events
            let query = supabaseClient
              .from('listing_events')
              .select('*')
              .order('created_at', { ascending: false })
          .limit(fetchLimit);
        
        if (filters.eventType !== 'all') {
          query = query.eq('event_type', filters.eventType);
        }
        if (filters.dateFrom) {
          query = query.gte('created_at', filters.dateFrom + 'T00:00:00Z');
        }
        if (filters.dateTo) {
          query = query.lte('created_at', filters.dateTo + 'T23:59:59Z');
            }
            
            const { data: listings } = await query;
            if (listings) {
              listings.forEach(event => {
            events.push({
                  type: 'FloorEngine',
                  eventType: event.event_type,
                  data: event,
                  timestamp: event.created_at
                });
              });
          }
          
          // Trade events
        query = supabaseClient
              .from('trade_events')
              .select('*')
              .order('created_at', { ascending: false })
          .limit(fetchLimit);
        
        if (filters.dateFrom) {
          query = query.gte('created_at', filters.dateFrom + 'T00:00:00Z');
        }
        if (filters.dateTo) {
          query = query.lte('created_at', filters.dateTo + 'T23:59:59Z');
            }
            
            const { data: trades } = await query;
            if (trades) {
              trades.forEach(event => {
            events.push({
                  type: 'FloorEngine',
                  eventType: 'Bought',
                  data: event,
                  timestamp: event.created_at
                });
              });
          }
          
        // Sweep events
        query = supabaseClient
              .from('sweep_events')
              .select('*')
              .order('created_at', { ascending: false })
          .limit(fetchLimit);
        
        if (filters.dateFrom) {
          query = query.gte('created_at', filters.dateFrom + 'T00:00:00Z');
        }
        if (filters.dateTo) {
          query = query.lte('created_at', filters.dateTo + 'T23:59:59Z');
            }
            
            const { data: sweeps } = await query;
            if (sweeps) {
              sweeps.forEach(event => {
            events.push({
                  type: 'FloorEngine',
                  eventType: 'FloorSweep',
                  data: event,
                  timestamp: event.created_at
                });
              });
            }
          }
          
      // ERC20 events
      if (filters.contract === 'all' || filters.contract === 'erc20') {
        // Transfers
        if (filters.eventType === 'all' || filters.eventType === 'Transfer') {
          let query = supabaseClient
            .from('erc20_transfers')
            .select('*')
            .eq('contract_address', ERC20_ADDRESS.toLowerCase())
            .order('created_at', { ascending: false })
            .limit(fetchLimit);
          
          if (filters.dateFrom) {
            query = query.gte('created_at', filters.dateFrom + 'T00:00:00Z');
          }
          if (filters.dateTo) {
            query = query.lte('created_at', filters.dateTo + 'T23:59:59Z');
          }
          if (filters.address) {
            query = query.or(`from_address.ilike.%${filters.address}%,to_address.ilike.%${filters.address}%`);
          }
          
          const { data: transfers } = await query;
          if (transfers) {
            transfers.forEach(event => {
              events.push({
                type: 'ERC20',
                eventType: 'Transfer',
                data: event,
                timestamp: event.created_at
              });
            });
          }
        }

        // Approvals
        if (filters.eventType === 'all' || filters.eventType === 'Approval') {
          let query = supabaseClient
            .from('erc20_approvals')
            .select('*')
            .eq('contract_address', ERC20_ADDRESS.toLowerCase())
            .order('created_at', { ascending: false })
            .limit(fetchLimit);
          
          if (filters.dateFrom) {
            query = query.gte('created_at', filters.dateFrom + 'T00:00:00Z');
          }
          if (filters.dateTo) {
            query = query.lte('created_at', filters.dateTo + 'T23:59:59Z');
          }
          if (filters.address) {
            query = query.or(`owner.ilike.%${filters.address}%,spender.ilike.%${filters.address}%`);
          }
          
          const { data: approvals } = await query;
          if (approvals) {
            approvals.forEach(event => {
              events.push({
                type: 'ERC20',
                eventType: 'Approval',
                data: event,
                timestamp: event.created_at
              });
            });
          }
        }

        // Custom events
        if (filters.eventType === 'all') {
            let query = supabaseClient
              .from('erc20_custom_events')
              .select('*')
              .eq('contract_address', ERC20_ADDRESS.toLowerCase())
              .order('created_at', { ascending: false })
              .limit(fetchLimit);
          
          if (filters.dateFrom) {
            query = query.gte('created_at', filters.dateFrom + 'T00:00:00Z');
          }
          if (filters.dateTo) {
            query = query.lte('created_at', filters.dateTo + 'T23:59:59Z');
          }
          
          const { data: customs } = await query;
          if (customs) {
            customs.forEach(event => {
              events.push({
                type: 'ERC20',
                eventType: event.event_name,
                data: event,
                timestamp: event.created_at
              });
            });
          }
        } else {
          const customEventTypes = ['Staked', 'WithdrawnStake', 'TaxFeeUpdated', 'CreatorFeeUpdated', 'BurnFeeUpdated'];
          if (customEventTypes.includes(filters.eventType)) {
            let query = supabaseClient
          .from('erc20_custom_events')
              .select('*')
              .eq('contract_address', ERC20_ADDRESS.toLowerCase())
              .eq('event_name', filters.eventType)
              .order('created_at', { ascending: false })
              .range(offset, offset + limit - 1);
            
            if (filters.dateFrom) {
              query = query.gte('created_at', filters.dateFrom + 'T00:00:00Z');
            }
            if (filters.dateTo) {
              query = query.lte('created_at', filters.dateTo + 'T23:59:59Z');
            }
            
            const { data: customs } = await query;
            if (customs) {
              customs.forEach(event => {
                events.push({
                  type: 'ERC20',
                  eventType: event.event_name,
                  data: event,
                  timestamp: event.created_at
                });
              });
            }
          }
        }
      }

      // AdrianLABCore (ERC721) events
      if (filters.contract === 'all' || filters.contract === 'adrianlabcore') {
        // Transfers
        if (filters.eventType === 'all' || filters.eventType === 'Transfer') {
          let query = supabaseClient
            .from('erc721_transfers')
            .select('*')
            .eq('contract_address', ADRIANLABCORE_ADDRESS)
            .order('created_at', { ascending: false })
            .limit(fetchLimit);
          
          if (filters.dateFrom) {
            query = query.gte('created_at', filters.dateFrom + 'T00:00:00Z');
          }
          if (filters.dateTo) {
            query = query.lte('created_at', filters.dateTo + 'T23:59:59Z');
          }
          if (filters.address) {
            query = query.or(`from_address.ilike.%${filters.address}%,to_address.ilike.%${filters.address}%`);
          }
          
          const { data: transfers } = await query;
          if (transfers) {
            transfers.forEach(event => {
              events.push({
                type: 'AdrianLABCore',
                eventType: 'Transfer',
                data: event,
                timestamp: event.created_at
              });
            });
          }
        }

        // Approvals
        if (filters.eventType === 'all' || filters.eventType === 'Approval') {
          let query = supabaseClient
            .from('erc721_approvals')
            .select('*')
            .eq('contract_address', ADRIANLABCORE_ADDRESS)
            .order('created_at', { ascending: false })
            .limit(fetchLimit);
          
          if (filters.dateFrom) {
            query = query.gte('created_at', filters.dateFrom + 'T00:00:00Z');
          }
          if (filters.dateTo) {
            query = query.lte('created_at', filters.dateTo + 'T23:59:59Z');
          }
          if (filters.address) {
            query = query.or(`owner.ilike.%${filters.address}%,approved.ilike.%${filters.address}%`);
          }
          
          const { data: approvals } = await query;
          if (approvals) {
            approvals.forEach(event => {
              events.push({
                type: 'AdrianLABCore',
                eventType: 'Approval',
                data: event,
                timestamp: event.created_at
              });
            });
          }
        }

        // ApprovalForAll
        if (filters.eventType === 'all' || filters.eventType === 'ApprovalForAll') {
          let query = supabaseClient
            .from('erc721_approvals_for_all')
            .select('*')
            .eq('contract_address', ADRIANLABCORE_ADDRESS)
            .order('created_at', { ascending: false })
            .limit(fetchLimit);
          
          if (filters.dateFrom) {
            query = query.gte('created_at', filters.dateFrom + 'T00:00:00Z');
          }
          if (filters.dateTo) {
            query = query.lte('created_at', filters.dateTo + 'T23:59:59Z');
          }
          if (filters.address) {
            query = query.or(`owner.ilike.%${filters.address}%,operator.ilike.%${filters.address}%`);
          }
          
          const { data: approvalsForAll } = await query;
          if (approvalsForAll) {
            approvalsForAll.forEach(event => {
              events.push({
                type: 'AdrianLABCore',
                eventType: 'ApprovalForAll',
                data: event,
                timestamp: event.created_at
              });
            });
          }
        }

        // Custom events
        if (filters.eventType === 'all') {
          let query = supabaseClient
            .from('erc721_custom_events')
            .select('*')
            .eq('contract_address', ADRIANLABCORE_ADDRESS)
            .order('created_at', { ascending: false })
            .limit(fetchLimit);
          
          if (filters.dateFrom) {
            query = query.gte('created_at', filters.dateFrom + 'T00:00:00Z');
          }
          if (filters.dateTo) {
            query = query.lte('created_at', filters.dateTo + 'T23:59:59Z');
          }
          
          const { data: customs } = await query;
          if (customs) {
            customs.forEach(event => {
              events.push({
                type: 'AdrianLABCore',
                eventType: event.event_name,
                data: event,
                timestamp: event.created_at
              });
            });
          }
        } else {
          const customEventTypes = ['TokenMinted', 'TokenBurnt', 'SkinAssigned', 'SkinCreated', 'MutationNameAssigned', 'SerumApplied', 'SpecialSkinApplied'];
          if (customEventTypes.includes(filters.eventType)) {
            let query = supabaseClient
              .from('erc721_custom_events')
              .select('*')
              .eq('contract_address', ADRIANLABCORE_ADDRESS)
              .eq('event_name', filters.eventType)
              .order('created_at', { ascending: false })
              .limit(fetchLimit);
            
            if (filters.dateFrom) {
              query = query.gte('created_at', filters.dateFrom + 'T00:00:00Z');
            }
            if (filters.dateTo) {
              query = query.lte('created_at', filters.dateTo + 'T23:59:59Z');
            }
            
            const { data: customs } = await query;
            if (customs) {
              customs.forEach(event => {
                events.push({
                  type: 'AdrianLABCore',
                  eventType: event.event_name,
                  data: event,
                  timestamp: event.created_at
                });
              });
            }
          }
        }
      }

      // ERC1155 (AdrianLAB) events
      if (filters.contract === 'all' || filters.contract === 'erc1155') {
        // TransferSingle
        if (filters.eventType === 'all' || filters.eventType === 'TransferSingle') {
          let query = supabaseClient
            .from('erc1155_transfers_single')
            .select('*')
            .eq('contract_address', ERC1155_ADDRESS)
            .order('created_at', { ascending: false })
            .limit(fetchLimit);
          
          if (filters.dateFrom) {
            query = query.gte('created_at', filters.dateFrom + 'T00:00:00Z');
          }
          if (filters.dateTo) {
            query = query.lte('created_at', filters.dateTo + 'T23:59:59Z');
          }
          if (filters.address) {
            query = query.or(`from_address.ilike.%${filters.address}%,to_address.ilike.%${filters.address}%`);
          }
          
          const { data: transfers } = await query;
          if (transfers) {
            transfers.forEach(event => {
              const tokenIdValue = event.token_id || event.tokenId || null;
              events.push({
                type: 'ERC1155',
                eventType: 'TransferSingle',
                data: { ...event, token_id: tokenIdValue },
                timestamp: event.created_at
              });
            });
          }
        }

        // TransferBatch
        if (filters.eventType === 'all' || filters.eventType === 'TransferBatch') {
          let query = supabaseClient
            .from('erc1155_transfers_batch')
            .select('*')
            .eq('contract_address', ERC1155_ADDRESS)
            .order('created_at', { ascending: false })
            .limit(fetchLimit);
          
          if (filters.dateFrom) {
            query = query.gte('created_at', filters.dateFrom + 'T00:00:00Z');
          }
          if (filters.dateTo) {
            query = query.lte('created_at', filters.dateTo + 'T23:59:59Z');
          }
          if (filters.address) {
            query = query.or(`from_address.ilike.%${filters.address}%,to_address.ilike.%${filters.address}%`);
          }
          
          const { data: batchTransfers } = await query;
          if (batchTransfers) {
            batchTransfers.forEach(event => {
              const tokenIds = event.token_ids || [];
              const firstTokenId = Array.isArray(tokenIds) && tokenIds.length > 0 ? tokenIds[0] : null;
              events.push({
                type: 'ERC1155',
                eventType: 'TransferBatch',
                data: { ...event, token_id: firstTokenId, token_ids: tokenIds },
                timestamp: event.created_at
              });
            });
          }
        }

        // ApprovalForAll
        if (filters.eventType === 'all' || filters.eventType === 'ApprovalForAll') {
          let query = supabaseClient
            .from('erc1155_approvals_for_all')
            .select('*')
            .eq('contract_address', ERC1155_ADDRESS)
            .order('created_at', { ascending: false })
            .limit(fetchLimit);
          
          if (filters.dateFrom) {
            query = query.gte('created_at', filters.dateFrom + 'T00:00:00Z');
          }
          if (filters.dateTo) {
            query = query.lte('created_at', filters.dateTo + 'T23:59:59Z');
          }
          if (filters.address) {
            query = query.or(`owner.ilike.%${filters.address}%,operator.ilike.%${filters.address}%`);
          }
          
          const { data: approvalsForAll } = await query;
          if (approvalsForAll) {
            approvalsForAll.forEach(event => {
              events.push({
                type: 'ERC1155',
                eventType: 'ApprovalForAll',
                data: event,
                timestamp: event.created_at
              });
            });
          }
        }

        // URI Updates
        if (filters.eventType === 'all' || filters.eventType === 'URI') {
          let query = supabaseClient
            .from('erc1155_uri_updates')
            .select('*')
            .eq('contract_address', ERC1155_ADDRESS)
            .order('created_at', { ascending: false })
            .limit(fetchLimit);
          
          if (filters.dateFrom) {
            query = query.gte('created_at', filters.dateFrom + 'T00:00:00Z');
          }
          if (filters.dateTo) {
            query = query.lte('created_at', filters.dateTo + 'T23:59:59Z');
          }
          
          const { data: uriUpdates } = await query;
          if (uriUpdates) {
            uriUpdates.forEach(event => {
              events.push({
                type: 'ERC1155',
                eventType: 'URI',
                data: event,
                timestamp: event.created_at
              });
            });
          }
        }

        // Custom events
        if (filters.eventType === 'all') {
          let query = supabaseClient
            .from('erc1155_custom_events')
            .select('*')
            .eq('contract_address', ERC1155_ADDRESS)
            .order('created_at', { ascending: false })
            .range(offset, offset + limit - 1);
          
          if (filters.dateFrom) {
            query = query.gte('created_at', filters.dateFrom + 'T00:00:00Z');
          }
          if (filters.dateTo) {
            query = query.lte('created_at', filters.dateTo + 'T23:59:59Z');
          }
          
          const { data: customs } = await query;
          if (customs) {
            customs.forEach(event => {
              events.push({
                type: 'ERC1155',
                eventType: event.event_name,
                data: event,
                timestamp: event.created_at
              });
            });
          }
        } else {
          const customEventTypes = ['AssetMinted', 'AssetBurned', 'PackOpened', 'SerumUsed'];
          if (customEventTypes.includes(filters.eventType)) {
            let query = supabaseClient
              .from('erc1155_custom_events')
              .select('*')
              .eq('contract_address', ERC1155_ADDRESS)
              .eq('event_name', filters.eventType)
              .order('created_at', { ascending: false })
              .limit(fetchLimit);
            
            if (filters.dateFrom) {
              query = query.gte('created_at', filters.dateFrom + 'T00:00:00Z');
            }
            if (filters.dateTo) {
              query = query.lte('created_at', filters.dateTo + 'T23:59:59Z');
            }
            
            const { data: customs } = await query;
            if (customs) {
              customs.forEach(event => {
                events.push({
                  type: 'ERC1155',
                  eventType: event.event_name,
                  data: event,
                  timestamp: event.created_at
                });
              });
            }
          }
        }
      }

      // TraitsExtensions events
      if (filters.contract === 'all' || filters.contract === 'traitsextensions') {
        if (filters.eventType === 'all') {
          let query = supabaseClient
            .from('traits_extensions_events')
            .select('*')
            .eq('contract_address', TRAITS_EXTENSIONS_ADDRESS.toLowerCase())
              .order('created_at', { ascending: false })
            .limit(fetchLimit);
          
          if (filters.dateFrom) {
            query = query.gte('created_at', filters.dateFrom + 'T00:00:00Z');
          }
          if (filters.dateTo) {
            query = query.lte('created_at', filters.dateTo + 'T23:59:59Z');
          }
          
          const { data: customs } = await query;
          if (customs) {
            customs.forEach(event => {
              events.push({
                type: 'TraitsExtensions',
                eventType: event.event_name,
                  data: event,
                  timestamp: event.created_at
                });
              });
            }
        } else {
          const customEventTypes = ['TraitApplied', 'TraitsAppliedBatch', 'AssetAddedToInventory', 'TraitRemoved'];
          if (customEventTypes.includes(filters.eventType)) {
            let query = supabaseClient
              .from('traits_extensions_events')
              .select('*')
              .eq('contract_address', TRAITS_EXTENSIONS_ADDRESS.toLowerCase())
              .eq('event_name', filters.eventType)
              .order('created_at', { ascending: false })
              .limit(fetchLimit);
            
            if (filters.dateFrom) {
              query = query.gte('created_at', filters.dateFrom + 'T00:00:00Z');
            }
            if (filters.dateTo) {
              query = query.lte('created_at', filters.dateTo + 'T23:59:59Z');
            }
            
            const { data: customs } = await query;
            if (customs) {
              customs.forEach(event => {
                events.push({
                  type: 'TraitsExtensions',
                  eventType: event.event_name,
                  data: event,
                  timestamp: event.created_at
                });
              });
            }
          }
            }
          }
          
      // AdrianShop events
      if (filters.contract === 'all' || filters.contract === 'adrianshop') {
        if (filters.eventType === 'all') {
          let query = supabaseClient
            .from('shop_events')
            .select('*')
            .eq('contract_address', ADRIAN_SHOP_ADDRESS)
              .order('created_at', { ascending: false })
            .limit(fetchLimit);
          
          if (filters.dateFrom) {
            query = query.gte('created_at', filters.dateFrom + 'T00:00:00Z');
          }
          if (filters.dateTo) {
            query = query.lte('created_at', filters.dateTo + 'T23:59:59Z');
          }
          if (filters.address) {
            query = query.ilike('event_data->>buyer', `%${filters.address}%`);
          }
          
          const { data: shopEvents } = await query;
          if (shopEvents) {
            shopEvents.forEach(event => {
              events.push({
                type: 'AdrianShop',
                eventType: event.event_name,
                  data: event,
                  timestamp: event.created_at
                });
              });
            }
        } else {
          const customEventTypes = ['ItemPurchased', 'BatchPurchase', 'ItemListed', 'ItemDelisted'];
          if (customEventTypes.includes(filters.eventType)) {
            let query = supabaseClient
              .from('shop_events')
              .select('*')
              .eq('contract_address', ADRIAN_SHOP_ADDRESS)
              .eq('event_name', filters.eventType)
              .order('created_at', { ascending: false })
              .limit(fetchLimit);
            
            if (filters.dateFrom) {
              query = query.gte('created_at', filters.dateFrom + 'T00:00:00Z');
            }
            if (filters.dateTo) {
              query = query.lte('created_at', filters.dateTo + 'T23:59:59Z');
            }
            if (filters.address) {
              query = query.ilike('event_data->>buyer', `%${filters.address}%`);
            }
            
            const { data: shopEvents } = await query;
            if (shopEvents) {
              shopEvents.forEach(event => {
                events.push({
                  type: 'AdrianShop',
                  eventType: event.event_name,
                  data: event,
                  timestamp: event.created_at
                });
              });
            }
          }
        }
      }

      // AdrianNameRegistry events (NUEVO)
      if (filters.contract === 'all' || filters.contract === 'adriannameregistry') {
        if (filters.eventType === 'all') {
          let query = supabaseClient
            .from('name_registry_events')
            .select('*')
            .eq('contract_address', ADRIAN_NAME_REGISTRY_ADDRESS.toLowerCase())
              .order('created_at', { ascending: false })
            .limit(fetchLimit);
          
          if (filters.dateFrom) {
            query = query.gte('created_at', filters.dateFrom + 'T00:00:00Z');
          }
          if (filters.dateTo) {
            query = query.lte('created_at', filters.dateTo + 'T23:59:59Z');
          }
          if (filters.address) {
            query = query.ilike('setter', `%${filters.address}%`);
          }
          
          const { data: nameEvents } = await query;
          if (nameEvents) {
            nameEvents.forEach(event => {
              events.push({
                type: 'AdrianNameRegistry',
                eventType: event.event_name || 'NameSet',
                  data: event,
                  timestamp: event.created_at
                });
              });
            }
          }
          
        // Config events
        if (filters.eventType === 'all' || filters.eventType === 'PriceUpdated' || filters.eventType === 'TreasuryUpdated') {
          let query = supabaseClient
            .from('name_registry_config_events')
            .select('*')
            .eq('contract_address', ADRIAN_NAME_REGISTRY_ADDRESS.toLowerCase())
              .order('created_at', { ascending: false })
            .limit(fetchLimit);
          
          if (filters.eventType !== 'all') {
            query = query.eq('event_type', filters.eventType);
          }
          if (filters.dateFrom) {
            query = query.gte('created_at', filters.dateFrom + 'T00:00:00Z');
          }
          if (filters.dateTo) {
            query = query.lte('created_at', filters.dateTo + 'T23:59:59Z');
          }
          
          const { data: configEvents } = await query;
          if (configEvents) {
            configEvents.forEach(event => {
              events.push({
                type: 'AdrianNameRegistry',
                eventType: event.event_type,
                  data: event,
                  timestamp: event.created_at
                });
              });
          }
        }
      }

      // AdrianSerumModule events (NUEVO)
      if (filters.contract === 'all' || filters.contract === 'adrianserummodule') {
        if (ADRIAN_SERUM_MODULE_ADDRESS !== '0x0000000000000000000000000000000000000000') {
          let query = supabaseClient
            .from('serum_module_events')
            .select('*')
            .eq('contract_address', ADRIAN_SERUM_MODULE_ADDRESS.toLowerCase())
              .order('created_at', { ascending: false })
            .limit(fetchLimit);
          
          if (filters.dateFrom) {
            query = query.gte('created_at', filters.dateFrom + 'T00:00:00Z');
          }
          if (filters.dateTo) {
            query = query.lte('created_at', filters.dateTo + 'T23:59:59Z');
          }
          if (filters.address) {
            query = query.ilike('user_address', `%${filters.address}%`);
          }
          
          const { data: serumEvents } = await query;
          if (serumEvents) {
            serumEvents.forEach(event => {
              events.push({
                type: 'AdrianSerumModule',
                eventType: event.event_name || 'SerumApplied',
                  data: event,
                  timestamp: event.created_at
                });
              });
            }
          }
        }
        
      // PunkQuest events (NUEVO)
      if (filters.contract === 'all' || filters.contract === 'punkquest') {
        if (PUNK_QUEST_ADDRESS !== '0x0000000000000000000000000000000000000000') {
          // Staking events
          let query = supabaseClient
            .from('punk_quest_staking_events')
            .select('*')
            .eq('contract_address', PUNK_QUEST_ADDRESS.toLowerCase())
              .order('created_at', { ascending: false })
            .limit(fetchLimit);
          
          if (filters.dateFrom) {
            query = query.gte('created_at', filters.dateFrom + 'T00:00:00Z');
          }
          if (filters.dateTo) {
            query = query.lte('created_at', filters.dateTo + 'T23:59:59Z');
          }
          if (filters.address) {
            query = query.ilike('user_address', `%${filters.address}%`);
          }
          
          const { data: stakingEvents } = await query;
          if (stakingEvents) {
            stakingEvents.forEach(event => {
              events.push({
                type: 'PunkQuest',
                eventType: event.event_name || 'Staked',
                  data: event,
                  timestamp: event.created_at
                });
              });
          }

          // Item events
          query = supabaseClient
            .from('punk_quest_item_events')
            .select('*')
            .eq('contract_address', PUNK_QUEST_ADDRESS.toLowerCase())
              .order('created_at', { ascending: false })
            .limit(fetchLimit);
          
          if (filters.dateFrom) {
            query = query.gte('created_at', filters.dateFrom + 'T00:00:00Z');
          }
          if (filters.dateTo) {
            query = query.lte('created_at', filters.dateTo + 'T23:59:59Z');
          }
          if (filters.address) {
            query = query.ilike('user_address', `%${filters.address}%`);
          }
          
          const { data: itemEvents } = await query;
          if (itemEvents) {
            itemEvents.forEach(event => {
              events.push({
                type: 'PunkQuest',
                eventType: event.event_name || 'ItemPurchased',
                  data: event,
                  timestamp: event.created_at
                });
              });
          }

          // Event events
          query = supabaseClient
            .from('punk_quest_event_events')
            .select('*')
            .eq('contract_address', PUNK_QUEST_ADDRESS.toLowerCase())
              .order('created_at', { ascending: false })
            .limit(fetchLimit);
          
          if (filters.dateFrom) {
            query = query.gte('created_at', filters.dateFrom + 'T00:00:00Z');
          }
          if (filters.dateTo) {
            query = query.lte('created_at', filters.dateTo + 'T23:59:59Z');
          }
          
          const { data: questEvents } = await query;
          if (questEvents) {
            questEvents.forEach(event => {
              events.push({
                type: 'PunkQuest',
                eventType: event.event_name || 'EventStarted',
                  data: event,
                  timestamp: event.created_at
                });
              });
            }
          }
        }
        
      // Ordenar por timestamp descendente
      events.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
      
      // Limitar a pageSize
      return events.slice(0, limit);
    }

    // ============================================
    // FILTERING & RENDERING
    // ============================================
    function applyFiltersAndRender() {
      // Aplicar filtros a allLoadedEvents
      let filtered = [...allLoadedEvents];
      
      // Aplicar filtros de fecha y direcciÃ³n si existen
      if (filters.dateFrom) {
        filtered = filtered.filter(e => new Date(e.timestamp) >= new Date(filters.dateFrom + 'T00:00:00Z'));
      }
      if (filters.dateTo) {
        filtered = filtered.filter(e => new Date(e.timestamp) <= new Date(filters.dateTo + 'T23:59:59Z'));
      }
      
      // Aplicar reglas de eventos
      filtered = applyEventFilteringRules(filtered);
      applyContextualTagging(filtered);
      
      // Actualizar displayedEvents
      displayedEvents = filtered;
      
      // Limpiar DOM si hay demasiados items
      cleanupOldItems();
      
      // Renderizar
      renderEvents();
    }

    function renderEvents() {
      const container = document.getElementById('activityListContainer');
      if (!container) return;
      
      // Si no hay eventos, mostrar mensaje
      if (displayedEvents.length === 0) {
        container.innerHTML = '<div class="text-center py-5"><p>No hay eventos para mostrar</p></div>';
        return;
      }
      
      // Renderizar eventos uno por uno, cada uno completamente independiente
      const fragment = document.createDocumentFragment();
      
      displayedEvents.forEach((event) => {
        const item = createEventItem(event);
        fragment.appendChild(item);
      });
      
      // Limpiar y agregar
      container.innerHTML = '';
      container.appendChild(fragment);
      
      console.log(`âœ… Renderizados ${displayedEvents.length} eventos`);
    }

    function createEventItem(event) {
      // Crear contenedor completamente independiente
      const div = document.createElement('div');
      div.className = 'activity-item';
      
      // Badge
      let badgeColor = 'bg-secondary';
      let badgeText = event.type;
      if (event.type === 'FloorEngine') badgeColor = 'bg-primary';
      else if (event.type === 'ERC20') badgeColor = 'bg-success';
      else if (event.type === 'AdrianLABCore') badgeColor = 'bg-purple';
      else if (event.type === 'ERC1155') badgeColor = 'bg-info';
      else if (event.type === 'TraitsExtensions') badgeColor = 'bg-warning';
      else if (event.type === 'AdrianShop') badgeColor = 'bg-danger';
      else if (event.type === 'AdrianNameRegistry') badgeColor = 'bg-primary';
      else if (event.type === 'AdrianSerumModule') badgeColor = 'bg-info';
      else if (event.type === 'PunkQuest') badgeColor = 'bg-warning';
      
      // Date
      const date = new Date(event.timestamp);
      const dateStr = date.toLocaleString('es-ES', { 
        year: 'numeric', 
        month: 'short', 
        day: 'numeric', 
        hour: '2-digit', 
        minute: '2-digit' 
      });
      
      // Details
      const details = formatEventDetails(event);
      const txHash = event.data?.tx_hash || '';
      
      // Imagen solo si estÃ¡ habilitada (desactivada por ahora para debug)
      const image = LOAD_IMAGES ? getEventImage(event) : '';
      
      // HTML simple y plano, sin anidamientos complejos
      div.innerHTML = `
        <div class="activity-header">
          <div>
            <span class="badge ${badgeColor} activity-badge">${badgeText}</span>
            <span class="badge bg-secondary activity-badge ms-2">${event.eventType}</span>
          </div>
          <div class="activity-date">${dateStr}</div>
        </div>
        <div class="activity-details">
          ${image}
          <span>${details}</span>
        </div>
        ${txHash ? `<div class="mt-2"><a href="https://basescan.org/tx/${txHash}" target="_blank" class="activity-link">View on Basescan <i class="bi bi-box-arrow-up-right"></i></a></div>` : ''}
      `;
      
      return div;
    }

    function formatEventDetails(event) {
      if (event.type === 'FloorEngine') {
        if (event.eventType === 'Listed' || event.eventType === 'Cancelled') {
          const tokenId = event.data.token_id;
          const seller = shortAddress(event.data.seller);
          const price = event.data.price_wei ? formatADRIAN(event.data.price_wei) : '';
          return `Token #${tokenId} - ${event.eventType} by ${seller}${price ? ' - Price: ' + price + ' $ADRIAN' : ''}`;
        } else if (event.eventType === 'Bought') {
          const tokenId = event.data.token_id;
          const buyer = shortAddress(event.data.buyer);
          const seller = shortAddress(event.data.seller);
          const price = event.data.price_wei ? formatADRIAN(event.data.price_wei) : '';
          return `Token #${tokenId} - Bought by ${buyer} from ${seller}${price ? ' - Price: ' + price + ' $ADRIAN' : ''}`;
        } else if (event.eventType === 'FloorSweep') {
          const tokenId = event.data.token_id;
          const caller = shortAddress(event.data.caller);
          const buyPrice = event.data.buy_price_wei ? formatADRIAN(event.data.buy_price_wei) : '';
          const reward = event.data.caller_reward_wei ? formatADRIAN(event.data.caller_reward_wei) : '';
          return `Token #${tokenId} - Sweep by ${caller}${buyPrice ? ' - Buy: ' + buyPrice + ' $ADRIAN' : ''}${reward ? ' - Reward: ' + reward + ' $ADRIAN' : ''}`;
        }
      } else if (event.type === 'ERC20') {
        if (event.eventType === 'Transfer') {
          const from = shortAddress(event.data.from_address);
          const to = shortAddress(event.data.to_address);
          const amount = event.data.value_wei ? formatADRIAN(event.data.value_wei) : '';
          const fromTag = getAddressTagBadge(event.data.from_address, event.contextualTag);
          const toTag = getAddressTagBadge(event.data.to_address);
          return `Transfer from ${from}${fromTag} to ${to}${toTag}${amount ? ' - Amount: ' + amount + ' $ADRIAN' : ''}`;
        } else if (event.eventType === 'Approval') {
          const owner = shortAddress(event.data.owner);
          const spender = shortAddress(event.data.spender);
          const amount = event.data.value_wei ? formatADRIAN(event.data.value_wei) : '';
          return `Approval: ${owner} approved ${spender}${amount ? ' - Amount: ' + amount + ' $ADRIAN' : ''}`;
        }
      } else if (event.type === 'AdrianLABCore') {
        if (event.eventType === 'Transfer') {
          const tokenId = event.data.token_id;
          const from = shortAddress(event.data.from_address);
          const to = shortAddress(event.data.to_address);
          return `Token #${tokenId} - Transfer from ${from} to ${to}`;
        } else if (event.eventType === 'TokenMinted') {
          const tokenId = event.data.token_id || event.data.event_data?.tokenId;
          const to = shortAddress(event.data.to_address || event.data.event_data?.to);
          return `Token #${tokenId} - Minted to ${to}`;
        } else if (event.eventType === 'SkinAssigned') {
          const tokenId = event.data.token_id || event.data.event_data?.tokenId;
          const skinName = event.data.event_data?.skinName || 'Unknown';
          return `Token #${tokenId} - Skin "${skinName}" assigned`;
        }
      } else if (event.type === 'ERC1155') {
        if (event.eventType === 'TransferSingle') {
          const tokenId = event.data.token_id || event.data.tokenId;
          const from = shortAddress(event.data.from_address);
          const to = shortAddress(event.data.to_address);
          const amount = event.data.value || event.data.amount || '1';
          return `Token #${tokenId} - Transfer ${amount} from ${from} to ${to}`;
        } else if (event.eventType === 'TransferBatch') {
          const tokenIds = event.data.token_ids || [];
          const from = shortAddress(event.data.from_address);
          const to = shortAddress(event.data.to_address);
          return `Batch Transfer (${tokenIds.length} tokens) from ${from} to ${to}`;
        } else if (event.eventType === 'AssetMinted') {
          const tokenId = event.data.token_id || event.data.event_data?.tokenId;
          const to = shortAddress(event.data.to_address || event.data.event_data?.to);
          const amount = event.data.amount || event.data.event_data?.amount || '1';
          return `Token #${tokenId} - ${amount} minted to ${to}`;
        } else if (event.eventType === 'PackOpened') {
          const opener = shortAddress(event.data.event_data?.opener || event.data.user_address);
          const items = event.data.event_data?.items || [];
          return `Pack opened by ${opener} - ${items.length} items`;
        }
      } else if (event.type === 'TraitsExtensions') {
        if (event.eventType === 'TraitApplied') {
          const tokenId = event.data.token_id || event.data.event_data?.tokenId;
          const traitId = event.data.trait_id || event.data.event_data?.traitId;
          return `Token #${tokenId} - Trait #${traitId} applied`;
        } else if (event.eventType === 'TraitsAppliedBatch') {
          const tokenId = event.data.token_id || event.data.event_data?.tokenId;
          const traitIds = event.data.trait_ids || event.data.event_data?.traitIds || [];
          return `Token #${tokenId} - ${traitIds.length} traits applied: [${traitIds.join(', ')}]`;
        }
      } else if (event.type === 'AdrianShop') {
        if (event.eventType === 'ItemPurchased') {
          const buyer = shortAddress(event.data.event_data?.buyer);
          const itemId = event.data.event_data?.itemId || 'N/A';
          const quantity = event.data.event_data?.quantity || '1';
          return `Item #${itemId} (x${quantity}) purchased by ${buyer}`;
        }
      } else if (event.type === 'AdrianNameRegistry') {
        if (event.eventType === 'NameSet' || event.eventType === 'NameRemoved') {
          const tokenId = event.data.token_id;
          const newName = event.data.new_name || event.data.event_data?.newName;
          const setter = shortAddress(event.data.setter);
          const paid = event.data.paid ? ' (Paid)' : ' (Free)';
          return `Token #${tokenId} - Name "${newName}" ${event.eventType === 'NameSet' ? 'set' : 'removed'} by ${setter}${paid}`;
        }
      } else if (event.type === 'AdrianSerumModule') {
        const tokenId = event.data.token_id || event.data.event_data?.tokenId;
        const serumId = event.data.serum_id || event.data.event_data?.serumId;
        const success = event.data.success !== false;
        return `Token #${tokenId} - Serum #${serumId} ${success ? 'applied successfully' : 'failed'}`;
      } else if (event.type === 'PunkQuest') {
        if (event.eventType === 'Staked' || event.eventType === 'Unstaked') {
          const tokenId = event.data.token_id || event.data.event_data?.tokenId;
          const user = shortAddress(event.data.user_address || event.data.event_data?.user);
          return `Token #${tokenId} - ${event.eventType} by ${user}`;
        } else if (event.eventType === 'ItemPurchased' || event.eventType === 'ItemUsed') {
          const itemId = event.data.item_id || event.data.event_data?.itemId;
          const user = shortAddress(event.data.user_address || event.data.event_data?.user);
          return `Item #${itemId} - ${event.eventType} by ${user}`;
        }
      }
      
      return `${event.eventType}`;
    }

    function getEventImage(event) {
      if (!imageRules || !imageRules.eventImages) return '';
      
      const eventImages = imageRules.eventImages;
      
      // TraitApplied: usar mannequin.svg
      if (event.type === 'TraitsExtensions' && event.eventType === 'TraitApplied') {
        if (eventImages.TraitApplied && eventImages.TraitApplied.imageUrl) {
          return `<img src="${eventImages.TraitApplied.imageUrl}" class="nft-thumbnail" loading="lazy" decoding="async" alt="Mannequin" onerror="this.style.display='none'">`;
        }
      }
      
      // ERC20: usar ADRIAN_Coin.gif
      if (event.type === 'ERC20' && eventImages.ERC20 && eventImages.ERC20.imageUrl) {
        return `<img src="${eventImages.ERC20.imageUrl}" class="nft-thumbnail" loading="lazy" decoding="async" alt="ADRIAN Coin" onerror="this.style.display='none'">`;
      }
      
      // TraitsAppliedBatch: imagen dinÃ¡mica
      if (event.type === 'TraitsExtensions' && event.eventType === 'TraitsAppliedBatch') {
        if (eventImages.TraitsAppliedBatch && eventImages.TraitsAppliedBatch.dynamic) {
          const tokenId = event.data?.token_id || event.data?.tokenId || '0';
          const traitIds = event.data?.trait_ids || event.data?.traitIds || [];
          if (Array.isArray(traitIds) && traitIds.length > 0) {
            const traitParams = traitIds.map(id => `trait=${id}`).join('&');
            const imageUrl = `${eventImages.TraitsAppliedBatch.baseUrl}${tokenId}?${traitParams}`;
            return `<img src="${imageUrl}" class="nft-thumbnail" loading="lazy" decoding="async" alt="Custom Trait" onerror="this.style.display='none'">`;
          }
        }
      }
      
      // FloorEngine: imagen del NFT
      if (event.type === 'FloorEngine' && event.data?.token_id) {
        const tokenId = event.data.token_id;
        const imageUrl = getNFTImageUrl(tokenId);
        if (imageUrl) {
          return `<img src="${imageUrl}" class="nft-thumbnail" loading="lazy" decoding="async" alt="Token #${tokenId}" onerror="this.style.display='none'" onclick="window.open('${imageUrl}', '_blank')">`;
        }
      }
      
      // AdrianLABCore (ERC721): imagen del NFT
      if (event.type === 'AdrianLABCore' && event.data?.token_id) {
        const tokenId = event.data.token_id;
        const imageUrl = getNFTImageUrl(tokenId);
        if (imageUrl) {
          return `<img src="${imageUrl}" class="nft-thumbnail" loading="lazy" decoding="async" alt="Token #${tokenId}" onerror="this.style.display='none'" onclick="window.open('${imageUrl}', '_blank')">`;
        }
      }
      
      // ERC1155: imagen de AdrianLAB con fallbacks
      if (event.type === 'ERC1155' && (event.data?.token_id || event.data?.tokenId)) {
        const tokenId = event.data.token_id || event.data.tokenId;
        return createAdrianLABImage(tokenId);
      }
      
      return '';
    }
    
    function getNFTImageUrl(tokenId) {
      if (!tokenId || tokenId === 'N/A') return null;
      if (imageRules && imageRules.adrianPunks) {
        return `${imageRules.adrianPunks.baseUrl}${tokenId}${imageRules.adrianPunks.extension}`;
      }
      return `../market/adrianpunksimages/${tokenId}.png`;
    }
    
    function createAdrianLABImage(tokenId) {
      if (!tokenId || tokenId === 'N/A') return '';
      
      const urls = [];
      if (imageRules && imageRules.adrianLAB) {
        const baseUrl = imageRules.adrianLAB.baseUrl;
        const primaryExtension = imageRules.adrianLAB.extension;
        const fallbackExtensions = imageRules.adrianLAB.fallbackExtensions || [];
        
        urls.push(`${baseUrl}${tokenId}${primaryExtension}`);
        fallbackExtensions.forEach(ext => {
          urls.push(`${baseUrl}${tokenId}${ext}`);
        });
      } else {
        // Fallback hardcodeado
        urls.push(`https://adrianzero.com/traitlab/assets/traits/${tokenId}.svg`);
        urls.push(`https://adrianzero.com/traitlab/assets/traits/${tokenId}.png`);
        urls.push(`https://adrianzero.com/traitlab/assets/traits/${tokenId}.gif`);
      }
      
      // Retornar HTML string en lugar de elemento DOM para mejor rendimiento
      const urlsAttr = urls.map(url => url.replace(/"/g, '&quot;')).join(',');
      return `<img src="${urls[0]}" class="nft-thumbnail" loading="lazy" decoding="async" alt="Trait #${tokenId}" data-fallback-urls="${urlsAttr}" data-current-index="0" onerror="tryNextAdrianLABImage(this)" onclick="window.open(this.src, '_blank')" style="display: block;">`;
    }
    
    function tryNextAdrianLABImage(img) {
      try {
        const urlsStr = img.getAttribute('data-fallback-urls') || '';
        const urls = urlsStr.split(',').map(url => url.trim());
        const currentIndex = parseInt(img.getAttribute('data-current-index') || '0');
        
        if (currentIndex < urls.length - 1) {
          const nextIndex = currentIndex + 1;
          img.setAttribute('data-current-index', nextIndex.toString());
          img.src = urls[nextIndex];
        } else {
          // Si no hay mÃ¡s fallbacks, ocultar la imagen
          img.style.display = 'none';
        }
      } catch (error) {
        console.warn('Error en tryNextAdrianLABImage:', error);
        img.style.display = 'none';
      }
    }
    
    // Hacer funciÃ³n global para que funcione desde onerror
    window.tryNextAdrianLABImage = tryNextAdrianLABImage;

    // ============================================
    // UTILITY FUNCTIONS
    // ============================================
    function formatADRIAN(weiString) {
      try {
        let weiStr = String(weiString);
        if (weiStr.includes('e') || weiStr.includes('E')) {
          const num = parseFloat(weiStr);
          weiStr = num.toLocaleString('fullwide', { useGrouping: false, maximumFractionDigits: 0 });
        }
        weiStr = weiStr.replace(/,/g, '');
        if (!/^\d+$/.test(weiStr)) return '0.00';
        const wei = ethers.BigNumber.from(weiStr);
        const adrian = parseFloat(ethers.utils.formatUnits(wei, 18));
        return adrian.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
      } catch (error) {
        return '0.00';
      }
    }

    function shortAddress(address) {
      if (!address) return 'N/A';
      return `${address.slice(0, 6)}...${address.slice(-4)}`;
    }

    function getAddressTagBadge(address, contextualTag) {
      if (contextualTag) {
        return `<span class="badge bg-${contextualTag.color} ms-2">${contextualTag.tag}</span>`;
      }
      const tagInfo = addressTagsRules[address?.toLowerCase()];
      if (!tagInfo) return '';
      return `<span class="badge bg-${tagInfo.color} ms-2">${tagInfo.tag}</span>`;
    }

    function applyEventFilteringRules(events) {
      if (!eventRules || !eventRules.filtering) return events;
      
      const filteringRules = eventRules.filtering;
      let filtered = [...events];
      
      // Filtrado de mints redundantes
      if (filteringRules.redundantMints && filteringRules.redundantMints.enabled) {
        const rules = filteringRules.redundantMints.rules || [];
        rules.forEach(rule => {
          if (rule.sourceEvent && rule.conflictEvent) {
            // Buscar TransferSingle que sean mints (from_address = 0x0)
            const transferSingles = filtered.filter(e => 
              e.type === rule.sourceEvent.type &&
              e.eventType === rule.sourceEvent.eventType &&
              e.data.from_address === BURN_ADDRESS.toLowerCase()
            );
            
            // Buscar AssetMinted correspondientes
            const assetMinteds = filtered.filter(e =>
              e.type === rule.conflictEvent.type &&
              e.eventType === rule.conflictEvent.eventType
            );
            
            // Crear mapa de AssetMinted por tokenId y to_address
            const mintedMap = new Map();
            assetMinteds.forEach(mint => {
              const tokenId = mint.data.token_id || mint.data.tokenId;
              const toAddress = mint.data.to_address || mint.data.to_address?.toLowerCase();
              if (tokenId && toAddress) {
                const key = `${tokenId}-${toAddress}`;
                if (!mintedMap.has(key)) {
                  mintedMap.set(key, []);
                }
                mintedMap.get(key).push(mint);
              }
            });
            
            // Remover TransferSingle que tienen AssetMinted correspondiente
            filtered = filtered.filter(e => {
              if (e.type === rule.sourceEvent.type && e.eventType === rule.sourceEvent.eventType) {
                const tokenId = e.data.token_id || e.data.tokenId;
                const toAddress = e.data.to_address?.toLowerCase();
                if (tokenId && toAddress) {
                  const key = `${tokenId}-${toAddress}`;
                  if (mintedMap.has(key)) {
                    // Hay AssetMinted correspondiente, remover este TransferSingle
                    return false;
                  }
                }
              }
              return true;
            });
          }
        });
      }
      
      return filtered;
    }

    function applyContextualTagging(events) {
      if (!eventRules || !eventRules.contextualTagging) return;
      
      const contextualRules = eventRules.contextualTagging;
      
      // Etiquetado contextual para FloorSweep
      if (contextualRules.floorSweep && contextualRules.floorSweep.enabled) {
        const rules = contextualRules.floorSweep.rules || [];
        rules.forEach(rule => {
          if (rule.triggerEvent && rule.targetEvents) {
            // Buscar eventos FloorSweep
            const floorSweeps = events.filter(e =>
              e.type === rule.triggerEvent.type &&
              e.eventType === rule.triggerEvent.eventType
            );
            
            // Para cada FloorSweep, buscar ERC20 transfers relacionados
            floorSweeps.forEach(sweep => {
              const sweepTimestamp = new Date(sweep.timestamp);
              const sweepToAddress = sweep.data.caller?.toLowerCase();
              
              rule.targetEvents.forEach(targetRule => {
                if (targetRule.type === 'ERC20' && targetRule.eventType === 'Transfer') {
                  events.forEach(event => {
                    if (event.type === targetRule.type && event.eventType === targetRule.eventType) {
                      const eventTimestamp = new Date(event.timestamp);
                      const timeDiff = Math.abs(eventTimestamp - sweepTimestamp);
                      
                      // Si el evento estÃ¡ dentro de 5 minutos del sweep y coincide la direcciÃ³n
                      if (timeDiff < 5 * 60 * 1000) {
                        const eventToAddress = event.data.to_address?.toLowerCase();
                        if (eventToAddress === sweepToAddress) {
                          // Verificar si el monto coincide
                          const eventAmount = event.data.value_wei;
                          const matchAmount = targetRule.matchAmount;
                          if (matchAmount === 'caller_reward_wei') {
                            const rewardAmount = sweep.data.caller_reward_wei;
                            if (eventAmount === rewardAmount) {
                              event.contextualTag = targetRule.tag;
                            }
                          } else if (matchAmount === 'buy_price_wei') {
                            const buyAmount = sweep.data.buy_price_wei;
                            if (eventAmount === buyAmount) {
                              event.contextualTag = targetRule.tag;
                            }
                          }
                        }
                      }
                    }
                  });
                }
              });
            });
          }
        });
      }
    }
    
    function setupIntersectionObserver() {
      // DESACTIVADO para evitar crashes en mÃ³viles
      // Usar botÃ³n "Load More" manual en su lugar
      return;
      
      /* CÃ³digo comentado por ahora
      if (!('IntersectionObserver' in window)) {
        console.warn('Intersection Observer no soportado, usando botÃ³n Load More');
        return;
      }
      
      // Limpiar observer anterior si existe
      if (intersectionObserver) {
        intersectionObserver.disconnect();
      }
      
      intersectionObserver = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting && hasMore && !isLoading) {
            loadMore();
          }
        });
      }, {
        root: null,
        rootMargin: '100px',
        threshold: 0.1
      });
      
      // Observar el sentinel cuando se renderice
      const sentinel = document.getElementById('scrollSentinel');
      if (sentinel) {
        intersectionObserver.observe(sentinel);
      }
      */
    }
    
    function showActivityTab() {
      document.getElementById('activity-tab-content').classList.add('active');
      document.getElementById('statistics-tab-content').classList.remove('active');
      document.getElementById('tab-activity-btn').classList.add('active');
      document.getElementById('tab-statistics-btn').classList.remove('active');
    }
    
    function showStatisticsTab() {
      document.getElementById('activity-tab-content').classList.remove('active');
      document.getElementById('statistics-tab-content').classList.add('active');
      document.getElementById('tab-activity-btn').classList.remove('active');
      document.getElementById('tab-statistics-btn').classList.add('active');
    }

    function cleanupOldItems() {
      // Si hay mÃ¡s de MAX_ITEMS_IN_DOM, mantener solo los Ãºltimos
      if (displayedEvents.length > MAX_ITEMS_IN_DOM) {
        const toRemove = displayedEvents.length - MAX_ITEMS_IN_DOM;
        displayedEvents = displayedEvents.slice(toRemove);
      }
    }

    // ============================================
    // UI HELPERS
    // ============================================
    function showLoading() {
      const container = document.getElementById('activityListContainer');
      if (container) {
        container.innerHTML = '<div class="loading-spinner"><div class="spinner-border" role="status"></div></div>';
      }
    }

    function hideLoading() {
      // Loading se oculta cuando renderizamos
    }

    function showError(message) {
      const container = document.getElementById('activityListContainer');
      if (container) {
        container.innerHTML = `<div class="alert alert-danger">${message}</div>`;
      }
    }

    function updateLoadMoreButton() {
      const container = document.getElementById('loadMoreContainer');
      if (container) {
        if (hasMore && !isLoading) {
          container.style.display = 'block';
          console.log('âœ… BotÃ³n Load More visible');
        } else {
          container.style.display = 'none';
          if (!hasMore) {
            console.log('â„¹ï¸ No hay mÃ¡s eventos, botÃ³n oculto');
          }
        }
      }
    }

    // ============================================
    // FILTER HANDLERS
    // ============================================
    function applyFilters() {
      filters.contract = document.getElementById('filterContract').value;
      filters.eventType = document.getElementById('filterEventType').value;
      filters.dateFrom = document.getElementById('filterDateFrom').value || null;
      filters.dateTo = document.getElementById('filterDateTo').value || null;
      filters.address = document.getElementById('filterAddress').value.trim() || null;
      
      loadFirstPage();
    }

    function clearFilters() {
      document.getElementById('filterContract').value = 'all';
      document.getElementById('filterEventType').value = 'all';
      document.getElementById('filterDateFrom').value = '';
      document.getElementById('filterDateTo').value = '';
      document.getElementById('filterAddress').value = '';
      
      filters.contract = 'all';
      filters.eventType = 'all';
      filters.dateFrom = null;
      filters.dateTo = null;
      filters.address = null;
      
      loadFirstPage();
    }

    // ============================================
    // INITIALIZE ON LOAD
    // ============================================
    document.addEventListener('DOMContentLoaded', init);
  </script>
</body>
</html>

