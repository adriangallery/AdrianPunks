<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>$ADRIAN Ecosystem Stats</title>
  <link rel="icon" type="image/x-icon" href="../favicon.ico">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
  <link rel="stylesheet" href="../market/styles.css">
  <link rel="stylesheet" href="styles.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css">
  <script src="/lib/database.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/5.7.2/ethers.umd.min.js"></script>
  <script src="./statistics.js"></script>
  <style>
    /* Estilos base */
    :root {
      --bg-color: #ffffff;
      --text-color: #333333;
      --card-bg: #ffffff;
      --border-color: #dee2e6;
      --badge-bg: #007bff;
      --badge-text: #ffffff;
    }

    [data-theme="dark"] {
      --bg-color: #1a1a1a;
      --text-color: #ffffff;
      --card-bg: #2d2d2d;
      --border-color: #404040;
      --badge-bg: #0d6efd;
      --badge-text: #ffffff;
    }

    .bg-purple {
      background-color: #9c27b0 !important;
    }

    body {
      background-color: var(--bg-color);
      color: var(--text-color);
      padding-top: calc(60px + 20px); /* navbar height + margin */
    }

    .container {
      background-color: var(--bg-color);
    }

    .card {
      background-color: var(--card-bg);
      border-color: var(--border-color);
      color: var(--text-color);
      margin-bottom: 2rem;
    }

    .card-title {
      color: var(--text-color);
    }

    /* Statistics Cards */
    .stat-card {
      background: var(--card-bg);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      padding: 1.5rem;
      text-align: center;
      transition: transform 0.2s, box-shadow 0.2s;
      height: 100%;
    }

    .stat-card:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 8px rgba(0,0,0,0.1);
    }

    .stat-label {
      font-size: 0.9rem;
      color: var(--text-color);
      opacity: 0.7;
      margin-bottom: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .stat-value {
      font-size: 1.5rem;
      font-weight: bold;
      color: var(--text-color);
    }

    .stat-value.positive {
      color: #28a745;
    }

    .stat-value.negative {
      color: #dc3545;
    }

    .stat-subtitle {
      font-size: 0.85rem;
      color: var(--text-color);
      opacity: 0.6;
      margin-top: 0.5rem;
    }

    /* Chart Container */
    .chart-container {
      position: relative;
      height: 300px;
      margin: 1rem 0;
    }

    .chart-container.large {
      height: 400px;
    }

    /* Section Header */
    .section-header {
      border-bottom: 2px solid var(--border-color);
      padding-bottom: 1rem;
      margin-bottom: 2rem;
    }

    .section-header h2 {
      margin: 0;
      color: var(--text-color);
    }

    /* Loading Spinner */
    .loading-spinner {
      text-align: center;
      padding: 2rem;
    }

    /* Activity List */
    .activity-list {
      max-height: 800px;
      overflow-y: auto;
    }

    .activity-item {
      border: 1px solid var(--border-color);
      border-radius: 8px;
      padding: 1rem;
      margin-bottom: 1rem;
      background-color: var(--card-bg);
      transition: box-shadow 0.2s;
    }

    .activity-item:hover {
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }

    .activity-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 0.5rem;
    }

    .activity-badge {
      padding: 0.25rem 0.75rem;
      border-radius: 12px;
      font-size: 0.85rem;
      font-weight: 500;
    }

    .activity-details {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      flex-wrap: wrap;
      font-size: 0.9rem;
      color: var(--text-color);
      opacity: 0.8;
    }

    .activity-details strong {
      opacity: 1;
    }
    
    .nft-thumbnail {
      width: 80px;
      height: 80px;
      object-fit: cover;
      border-radius: 4px;
      border: 2px solid var(--border-color);
      flex-shrink: 0;
      cursor: pointer;
    }
    
    .nft-thumbnail:hover {
      border-color: #007bff;
    }
    
    @media (max-width: 768px) {
      .nft-thumbnail {
        width: 60px;
        height: 60px;
      }
    }
    
    /* Ensure Bootstrap tabs work correctly */
    .tab-content > .tab-pane {
      display: none;
    }
    
    .tab-content > .tab-pane.active {
      display: block;
    }

    .activity-date {
      font-size: 0.85rem;
      color: var(--text-color);
      opacity: 0.6;
    }

    .activity-link {
      color: #007bff;
      text-decoration: none;
    }

    .activity-link:hover {
      text-decoration: underline;
    }

    @media (max-width: 768px) {
      body {
        padding-top: 60px;
      }
      
      .stat-card {
        margin-bottom: 1rem;
      }
      
      .stat-value {
        font-size: 1.25rem;
      }

      .chart-container {
        height: 250px;
      }

      .chart-container.large {
        height: 300px;
      }
    }
  </style>
</head>
<body>
  <!-- Include the menu -->
  <div id="menu-container"></div>
  <script>
    // Load the menu with proper styling - must run before DOMContentLoaded
    (function() {
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', loadMenu);
      } else {
        loadMenu();
      }
      
      function loadMenu() {
        fetch('../components/menu.html')
          .then(response => response.text())
          .then(html => {
            const container = document.getElementById('menu-container');
            if (container) {
              container.innerHTML = html;
              
              // Ensure menu has correct Bootstrap classes and styling
              const menu = container.querySelector('.navbar');
              if (menu) {
                menu.classList.add('navbar-dark', 'bg-dark');
                menu.style.backgroundColor = '#212529';
              }
              
              // Ensure toggler icon is visible
              const togglerIcon = container.querySelector('.navbar-toggler-icon');
              if (togglerIcon) {
                togglerIcon.style.filter = 'invert(100%)';
              }
              
              // Fix script paths in the loaded HTML (menu.js needs relative path from activity/)
              const scripts = container.querySelectorAll('script[src="menu.js"]');
              scripts.forEach(script => {
                script.src = '../components/menu.js';
                // Execute the script after fixing the path
                const newScript = document.createElement('script');
                newScript.src = script.src;
                newScript.async = false;
                document.head.appendChild(newScript);
                script.remove();
              });
              
              // Ensure Bootstrap is available and nav links work
              if (typeof bootstrap !== 'undefined') {
                const navLinks = container.querySelectorAll('.nav-link');
                navLinks.forEach(link => {
                  const newLink = link.cloneNode(true);
                  link.parentNode.replaceChild(newLink, link);
                });
              }
            }
          })
          .catch(error => console.error('Error loading menu:', error));
      }
    })();
  </script>

  <!-- Main Layout: 3 Columns -->
  <div class="main-layout">
    <!-- Sidebar Left: Quick Stats and Summary -->
    <aside class="sidebar">
      <!-- Quick Stats Panel -->
      <div class="collapsible-panel mb-3">
        <div class="panel-header" data-bs-toggle="collapse" data-bs-target="#quickStatsPanel" aria-expanded="true" id="quickStatsPanelHeader">
          <h5 class="mb-0">Quick Stats</h5>
          <i class="bi bi-chevron-down collapse-icon"></i>
        </div>
        <div class="collapse show" id="quickStatsPanel">
          <div class="panel-body">
            <div class="quick-stats" id="quickStatsContent">
              <div class="quick-stat-item">
                <span class="quick-stat-label">Total Supply</span>
                <span class="quick-stat-value" id="quickTotalSupply">Loading...</span>
              </div>
              <div class="quick-stat-item">
                <span class="quick-stat-label">Total Transactions</span>
                <span class="quick-stat-value" id="quickTotalTransactions">Loading...</span>
              </div>
              <div class="quick-stat-item">
                <span class="quick-stat-label">Total Volume</span>
                <span class="quick-stat-value" id="quickTotalVolume">Loading...</span>
              </div>
              <div class="quick-stat-item">
                <span class="quick-stat-label">Total Holders</span>
                <span class="quick-stat-value" id="quickTotalHolders">Loading...</span>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Ecosystem Overview Panel -->
      <div class="collapsible-panel">
        <div class="panel-header" data-bs-toggle="collapse" data-bs-target="#ecosystemOverviewPanel" aria-expanded="true" id="ecosystemOverviewPanelHeader">
          <h5 class="mb-0">Ecosystem Overview</h5>
          <i class="bi bi-chevron-down collapse-icon"></i>
        </div>
        <div class="collapse show" id="ecosystemOverviewPanel">
          <div class="panel-body">
            <div id="ecosystemOverviewContent">
              <p style="font-size: 0.9rem; color: var(--text-color); opacity: 0.8;">
                Comprehensive analytics for the $ADRIAN ecosystem including FloorEngine, Token, AdrianLABCore, TraitsCore, and Shop statistics.
              </p>
            </div>
          </div>
        </div>
      </div>
    </aside>

    <!-- Main Content: Statistics Sections -->
    <main class="main-content">
      <!-- FloorEngine Statistics Panel -->
      <div class="collapsible-panel mb-3">
        <div class="panel-header" data-bs-toggle="collapse" data-bs-target="#floorEnginePanel" aria-expanded="true" id="floorEnginePanelHeader">
          <h5 class="mb-0"><i class="bi bi-graph-up"></i> FloorEngine Statistics</h5>
          <i class="bi bi-chevron-down collapse-icon"></i>
        </div>
        <div class="collapse show" id="floorEnginePanel">
          <div class="panel-body">
            <div id="floorEngineStats" class="row g-3 mb-4">
      <div class="col-md-3">
        <div class="stat-card">
          <div class="stat-label">Total Invested</div>
          <div class="stat-value" id="feTotalInvested">Loading...</div>
        </div>
      </div>
      <div class="col-md-3">
        <div class="stat-card">
          <div class="stat-label">Total Earned</div>
          <div class="stat-value" id="feTotalEarned">Loading...</div>
        </div>
      </div>
      <div class="col-md-3">
        <div class="stat-card">
          <div class="stat-label">Net Profit</div>
          <div class="stat-value" id="feNetProfit">Loading...</div>
        </div>
      </div>
      <div class="col-md-3">
        <div class="stat-card">
          <div class="stat-label">ROI</div>
          <div class="stat-value" id="feROI">Loading...</div>
        </div>
      </div>
      <div class="col-md-3">
        <div class="stat-card">
          <div class="stat-label">Punks Bought</div>
          <div class="stat-value" id="fePunksBought">Loading...</div>
        </div>
      </div>
      <div class="col-md-3">
        <div class="stat-card">
          <div class="stat-label">Punks Sold</div>
          <div class="stat-value" id="fePunksSold">Loading...</div>
        </div>
      </div>
      <div class="col-md-3">
        <div class="stat-card">
          <div class="stat-label">Currently Listed</div>
          <div class="stat-value" id="feCurrentlyListed">Loading...</div>
        </div>
      </div>
      <div class="col-md-3">
        <div class="stat-card">
          <div class="stat-label">Listings Value</div>
          <div class="stat-value" id="feListingsValue">Loading...</div>
        </div>
      </div>
    </div>

            <!-- FloorEngine Charts -->
            <div class="row mb-3">
              <div class="col-md-6">
                <div class="card">
                  <div class="card-body">
                    <h5 class="card-title">FloorEngine Volume Over Time</h5>
                    <div class="chart-container">
                      <canvas id="feVolumeChart"></canvas>
                    </div>
                  </div>
                </div>
              </div>
              <div class="col-md-6">
                <div class="card">
                  <div class="card-body">
                    <h5 class="card-title">FloorEngine Activity Distribution</h5>
                    <div class="chart-container">
                      <canvas id="feActivityChart"></canvas>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- $ADRIAN Token Statistics Panel -->
      <div class="collapsible-panel mb-3">
        <div class="panel-header" data-bs-toggle="collapse" data-bs-target="#tokenStatsPanel" aria-expanded="true" id="tokenStatsPanelHeader">
          <h5 class="mb-0"><i class="bi bi-currency-exchange"></i> $ADRIAN Token Statistics</h5>
          <i class="bi bi-chevron-down collapse-icon"></i>
        </div>
        <div class="collapse show" id="tokenStatsPanel">
          <div class="panel-body">
            <div id="tokenStats" class="row g-3 mb-4">
      <div class="col-md-3">
        <div class="stat-card">
          <div class="stat-label">Total Supply</div>
          <div class="stat-value" id="tokenTotalSupply">Loading...</div>
          <div class="stat-subtitle">Minted - Burned</div>
        </div>
      </div>
      <div class="col-md-3">
        <div class="stat-card">
          <div class="stat-label">Circulating Supply</div>
          <div class="stat-value" id="tokenCirculatingSupply">Loading...</div>
          <div class="stat-subtitle">In wallets</div>
        </div>
      </div>
      <div class="col-md-3">
        <div class="stat-card">
          <div class="stat-label">Total Holders</div>
          <div class="stat-value" id="tokenTotalHolders">Loading...</div>
          <div class="stat-subtitle">Unique addresses</div>
        </div>
      </div>
      <div class="col-md-3">
        <div class="stat-card">
          <div class="stat-label">24h Volume</div>
          <div class="stat-value" id="token24hVolume">Loading...</div>
          <div class="stat-subtitle">Last 24 hours</div>
        </div>
      </div>
      <div class="col-md-3">
        <div class="stat-card">
          <div class="stat-label">24h Transactions</div>
          <div class="stat-value" id="token24hTransactions">Loading...</div>
          <div class="stat-subtitle">Last 24 hours</div>
        </div>
      </div>
      <div class="col-md-3">
        <div class="stat-card">
          <div class="stat-label">Total Staked</div>
          <div class="stat-value" id="tokenTotalStaked">Loading...</div>
          <div class="stat-subtitle">Active stakes</div>
        </div>
      </div>
      <div class="col-md-3">
        <div class="stat-card">
          <div class="stat-label">Total Rewards</div>
          <div class="stat-value" id="tokenTotalRewards">Loading...</div>
          <div class="stat-subtitle">Distributed</div>
        </div>
      </div>
      <div class="col-md-3">
        <div class="stat-card">
          <div class="stat-label">Total Transfers</div>
          <div class="stat-value" id="tokenTotalTransfers">Loading...</div>
          <div class="stat-subtitle">All time</div>
        </div>
      </div>
    </div>

            <!-- Token Charts -->
            <div class="row mb-3">
              <div class="col-md-6">
                <div class="card">
                  <div class="card-body">
                    <h5 class="card-title">Token Volume Over Time</h5>
                    <div class="chart-container">
                      <canvas id="tokenVolumeChart"></canvas>
                    </div>
                  </div>
                </div>
              </div>
              <div class="col-md-6">
                <div class="card">
                  <div class="card-body">
                    <h5 class="card-title">Transaction Count Over Time</h5>
                    <div class="chart-container">
                      <canvas id="tokenTransactionsChart"></canvas>
                    </div>
                  </div>
                </div>
              </div>
              <div class="col-md-6">
                <div class="card">
                  <div class="card-body">
                    <h5 class="card-title">Supply Distribution</h5>
                    <div class="chart-container">
                      <canvas id="tokenSupplyChart"></canvas>
                    </div>
                  </div>
                </div>
              </div>
              <div class="col-md-6">
                <div class="card">
                  <div class="card-body">
                    <h5 class="card-title">Staking Activity</h5>
                    <div class="chart-container">
                      <canvas id="tokenStakingChart"></canvas>
                    </div>
                  </div>
                </div>
              </div>
            </div>

            <!-- Top Holders -->
            <div class="card mb-3">
              <div class="card-body">
                <h5 class="card-title"><i class="bi bi-trophy"></i> Top Holders</h5>
                <div id="topHoldersTable" class="loading-spinner">
                  <div class="spinner-border" role="status">
                    <span class="visually-hidden">Loading...</span>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- AdrianLABCore Statistics Panel -->
      <div class="collapsible-panel mb-3">
        <div class="panel-header" data-bs-toggle="collapse" data-bs-target="#adrianlabcorePanel" aria-expanded="false" id="adrianlabcorePanelHeader">
          <h5 class="mb-0"><i class="bi bi-palette"></i> AdrianLABCore Statistics</h5>
          <i class="bi bi-chevron-down collapse-icon"></i>
        </div>
        <div class="collapse" id="adrianlabcorePanel">
          <div class="panel-body">
            <div id="adrianlabcoreStats" class="row g-3 mb-4">
      <div class="col-md-3">
        <div class="stat-card">
          <div class="stat-label">Total Supply</div>
          <div class="stat-value" id="alcTotalSupply">Loading...</div>
          <div class="stat-subtitle">Minted - Burned</div>
        </div>
      </div>
      <div class="col-md-3">
        <div class="stat-card">
          <div class="stat-label">Total Minted</div>
          <div class="stat-value" id="alcTotalMinted">Loading...</div>
          <div class="stat-subtitle">All time</div>
        </div>
      </div>
      <div class="col-md-3">
        <div class="stat-card">
          <div class="stat-label">Total Burned</div>
          <div class="stat-value" id="alcTotalBurned">Loading...</div>
          <div class="stat-subtitle">All time</div>
        </div>
      </div>
      <div class="col-md-3">
        <div class="stat-card">
          <div class="stat-label">Unique Holders</div>
          <div class="stat-value" id="alcUniqueHolders">Loading...</div>
          <div class="stat-subtitle">Addresses</div>
        </div>
      </div>
      <div class="col-md-3">
        <div class="stat-card">
          <div class="stat-label">Total Transfers</div>
          <div class="stat-value" id="alcTotalTransfers">Loading...</div>
          <div class="stat-subtitle">All time</div>
        </div>
      </div>
      <div class="col-md-3">
        <div class="stat-card">
          <div class="stat-label">Skins Assigned</div>
          <div class="stat-value" id="alcSkinsAssigned">Loading...</div>
          <div class="stat-subtitle">Total assignments</div>
        </div>
      </div>
      <div class="col-md-3">
        <div class="stat-card">
          <div class="stat-label">Tokens Mutated</div>
          <div class="stat-value" id="alcTokensMutated">Loading...</div>
          <div class="stat-subtitle">With mutations</div>
        </div>
      </div>
      <div class="col-md-3">
        <div class="stat-card">
          <div class="stat-label">Serums Applied</div>
          <div class="stat-value" id="alcSerumsApplied">Loading...</div>
          <div class="stat-subtitle">Total serums</div>
        </div>
      </div>
    </div>

            <!-- AdrianLABCore Charts -->
            <div class="row mb-3">
              <div class="col-md-6">
                <div class="card">
                  <div class="card-body">
                    <h5 class="card-title">Minting Activity Over Time</h5>
                    <div class="chart-container">
                      <canvas id="alcMintingChart"></canvas>
                    </div>
                  </div>
                </div>
              </div>
              <div class="col-md-6">
                <div class="card">
                  <div class="card-body">
                    <h5 class="card-title">Skin Distribution</h5>
                    <div class="chart-container">
                      <canvas id="alcSkinChart"></canvas>
                    </div>
                  </div>
                </div>
              </div>
              <div class="col-md-6">
                <div class="card">
                  <div class="card-body">
                    <h5 class="card-title">Mutation Distribution</h5>
                    <div class="chart-container">
                      <canvas id="alcMutationChart"></canvas>
                    </div>
                  </div>
                </div>
              </div>
              <div class="col-md-6">
                <div class="card">
                  <div class="card-body">
                    <h5 class="card-title">Transfer Activity</h5>
                    <div class="chart-container">
                      <canvas id="alcTransferChart"></canvas>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- TraitsCore Statistics Panel -->
      <div class="collapsible-panel mb-3">
        <div class="panel-header" data-bs-toggle="collapse" data-bs-target="#traitscorePanel" aria-expanded="false" id="traitscorePanelHeader">
          <h5 class="mb-0"><i class="bi bi-box-seam"></i> TraitsCore Statistics</h5>
          <i class="bi bi-chevron-down collapse-icon"></i>
        </div>
        <div class="collapse" id="traitscorePanel">
          <div class="panel-body">
            <div id="traitsCoreStats" class="row g-3 mb-4">
      <div class="col-md-3">
        <div class="stat-card">
          <div class="stat-label">Total Assets</div>
          <div class="stat-value" id="tcTotalAssets">Loading...</div>
          <div class="stat-subtitle">Registered</div>
        </div>
      </div>
      <div class="col-md-3">
        <div class="stat-card">
          <div class="stat-label">Total Minted</div>
          <div class="stat-value" id="tcTotalMinted">Loading...</div>
          <div class="stat-subtitle">All assets</div>
        </div>
      </div>
      <div class="col-md-3">
        <div class="stat-card">
          <div class="stat-label">Total Burned</div>
          <div class="stat-value" id="tcTotalBurned">Loading...</div>
          <div class="stat-subtitle">All assets</div>
        </div>
      </div>
      <div class="col-md-3">
        <div class="stat-card">
          <div class="stat-label">Unique Holders</div>
          <div class="stat-value" id="tcUniqueHolders">Loading...</div>
          <div class="stat-subtitle">Addresses</div>
        </div>
      </div>
      <div class="col-md-3">
        <div class="stat-card">
          <div class="stat-label">Total Transfers</div>
          <div class="stat-value" id="tcTotalTransfers">Loading...</div>
          <div class="stat-subtitle">Single + Batch</div>
        </div>
      </div>
      <div class="col-md-3">
        <div class="stat-card">
          <div class="stat-label">Batch Transfers</div>
          <div class="stat-value" id="tcBatchTransfers">Loading...</div>
          <div class="stat-subtitle">Total batches</div>
        </div>
      </div>
      <div class="col-md-3">
        <div class="stat-card">
          <div class="stat-label">Categories</div>
          <div class="stat-value" id="tcCategories">Loading...</div>
          <div class="stat-subtitle">Total categories</div>
        </div>
      </div>
      <div class="col-md-3">
        <div class="stat-card">
          <div class="stat-label">Extensions</div>
          <div class="stat-value" id="tcExtensions">Loading...</div>
          <div class="stat-subtitle">Authorized</div>
        </div>
      </div>
    </div>

            <!-- TraitsCore Charts -->
            <div class="row mb-3">
              <div class="col-md-6">
                <div class="card">
                  <div class="card-body">
                    <h5 class="card-title">Asset Minting Over Time</h5>
                    <div class="chart-container">
                      <canvas id="tcMintingChart"></canvas>
                    </div>
                  </div>
                </div>
              </div>
              <div class="col-md-6">
                <div class="card">
                  <div class="card-body">
                    <h5 class="card-title">Asset Distribution</h5>
                    <div class="chart-container">
                      <canvas id="tcAssetChart"></canvas>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- TraitsExtensions Statistics Panel -->
      <div class="collapsible-panel mb-3">
        <div class="panel-header" data-bs-toggle="collapse" data-bs-target="#traitsextensionsPanel" aria-expanded="false" id="traitsextensionsPanelHeader">
          <h5 class="mb-0"><i class="bi bi-gear"></i> TraitsExtensions Statistics</h5>
          <i class="bi bi-chevron-down collapse-icon"></i>
        </div>
        <div class="collapse" id="traitsextensionsPanel">
          <div class="panel-body">
            <div id="traitsExtensionsStats" class="row g-3 mb-4">
      <div class="col-md-3">
        <div class="stat-card">
          <div class="stat-label">Traits Applied</div>
          <div class="stat-value" id="teTraitsApplied">Loading...</div>
          <div class="stat-subtitle">Permanent</div>
        </div>
      </div>
      <div class="col-md-3">
        <div class="stat-card">
          <div class="stat-label">Traits Equipped</div>
          <div class="stat-value" id="teTraitsEquipped">Loading...</div>
          <div class="stat-subtitle">Temporary</div>
        </div>
      </div>
      <div class="col-md-3">
        <div class="stat-card">
          <div class="stat-label">Traits Unequipped</div>
          <div class="stat-value" id="teTraitsUnequipped">Loading...</div>
          <div class="stat-subtitle">Total</div>
        </div>
      </div>
      <div class="col-md-3">
        <div class="stat-card">
          <div class="stat-label">Batch Applications</div>
          <div class="stat-value" id="teBatchApplications">Loading...</div>
          <div class="stat-subtitle">Total batches</div>
        </div>
      </div>
      <div class="col-md-3">
        <div class="stat-card">
          <div class="stat-label">Inventory Additions</div>
          <div class="stat-value" id="teInventoryAdded">Loading...</div>
          <div class="stat-subtitle">Assets added</div>
        </div>
      </div>
      <div class="col-md-3">
        <div class="stat-card">
          <div class="stat-label">Inventory Removals</div>
          <div class="stat-value" id="teInventoryRemoved">Loading...</div>
          <div class="stat-subtitle">Assets removed</div>
        </div>
      </div>
      <div class="col-md-3">
        <div class="stat-card">
          <div class="stat-label">Unique Tokens Modified</div>
          <div class="stat-value" id="teUniqueTokens">Loading...</div>
          <div class="stat-subtitle">Tokens</div>
        </div>
      </div>
      <div class="col-md-3">
        <div class="stat-card">
          <div class="stat-label">Total Events</div>
          <div class="stat-value" id="teTotalEvents">Loading...</div>
          <div class="stat-subtitle">All time</div>
        </div>
      </div>
    </div>

            <!-- TraitsExtensions Charts -->
            <div class="row mb-3">
              <div class="col-md-6">
                <div class="card">
                  <div class="card-body">
                    <h5 class="card-title">Trait Activity Over Time</h5>
                    <div class="chart-container">
                      <canvas id="teActivityChart"></canvas>
                    </div>
                  </div>
                </div>
              </div>
              <div class="col-md-6">
                <div class="card">
                  <div class="card-body">
                    <h5 class="card-title">Event Distribution</h5>
                    <div class="chart-container">
                      <canvas id="teEventChart"></canvas>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- AdrianShop Statistics Panel -->
      <div class="collapsible-panel mb-3">
        <div class="panel-header" data-bs-toggle="collapse" data-bs-target="#shopPanel" aria-expanded="false" id="shopPanelHeader">
          <h5 class="mb-0"><i class="bi bi-shop"></i> AdrianShop Statistics</h5>
          <i class="bi bi-chevron-down collapse-icon"></i>
        </div>
        <div class="collapse" id="shopPanel">
          <div class="panel-body">
            <div id="shopStats" class="row g-3 mb-4">
      <div class="col-md-3">
        <div class="stat-card">
          <div class="stat-label">Total Purchases</div>
          <div class="stat-value" id="shopTotalPurchases">Loading...</div>
          <div class="stat-subtitle">All time</div>
        </div>
      </div>
      <div class="col-md-3">
        <div class="stat-card">
          <div class="stat-label">Total Revenue</div>
          <div class="stat-value" id="shopTotalRevenue">Loading...</div>
          <div class="stat-subtitle">$ADRIAN</div>
        </div>
      </div>
      <div class="col-md-3">
        <div class="stat-card">
          <div class="stat-label">Unique Buyers</div>
          <div class="stat-value" id="shopUniqueBuyers">Loading...</div>
          <div class="stat-subtitle">Addresses</div>
        </div>
      </div>
      <div class="col-md-3">
        <div class="stat-card">
          <div class="stat-label">Batch Purchases</div>
          <div class="stat-value" id="shopBatchPurchases">Loading...</div>
          <div class="stat-subtitle">Total batches</div>
        </div>
      </div>
      <div class="col-md-3">
        <div class="stat-card">
          <div class="stat-label">Free Claims</div>
          <div class="stat-value" id="shopFreeClaims">Loading...</div>
          <div class="stat-subtitle">Items claimed</div>
        </div>
      </div>
      <div class="col-md-3">
        <div class="stat-card">
          <div class="stat-label">Active Items</div>
          <div class="stat-value" id="shopActiveItems">Loading...</div>
          <div class="stat-subtitle">Configured</div>
        </div>
      </div>
      <div class="col-md-3">
        <div class="stat-card">
          <div class="stat-label">Allowlist Configured</div>
          <div class="stat-value" id="shopAllowlists">Loading...</div>
          <div class="stat-subtitle">Items</div>
        </div>
      </div>
      <div class="col-md-3">
        <div class="stat-card">
          <div class="stat-label">24h Purchases</div>
          <div class="stat-value" id="shop24hPurchases">Loading...</div>
          <div class="stat-subtitle">Last 24 hours</div>
        </div>
      </div>
    </div>

            <!-- AdrianShop Charts -->
            <div class="row mb-3">
              <div class="col-md-6">
                <div class="card">
                  <div class="card-body">
                    <h5 class="card-title">Revenue Over Time</h5>
                    <div class="chart-container">
                      <canvas id="shopRevenueChart"></canvas>
                    </div>
                  </div>
                </div>
              </div>
              <div class="col-md-6">
                <div class="card">
                  <div class="card-body">
                    <h5 class="card-title">Purchases by Type</h5>
                    <div class="chart-container">
                      <canvas id="shopPurchaseTypeChart"></canvas>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Raw Activity Panel -->
      <div class="collapsible-panel">
        <div class="panel-header" data-bs-toggle="collapse" data-bs-target="#rawActivityPanel" aria-expanded="false" id="rawActivityPanelHeader">
          <h5 class="mb-0"><i class="bi bi-list-ul"></i> Raw Activity</h5>
          <i class="bi bi-chevron-down collapse-icon"></i>
        </div>
        <div class="collapse" id="rawActivityPanel">
          <div class="panel-body">

            <!-- Filters -->
            <div class="card mb-4">
              <div class="card-body">
                <h5 class="card-title mb-3">Filters</h5>
            <div class="row g-3">
              <div class="col-md-3">
                <label for="filterContract" class="form-label">Contract</label>
                <select class="form-select" id="filterContract">
                  <option value="all">All Contracts</option>
                  <option value="floorengine">FloorEngine</option>
                  <option value="erc20">$ADRIAN Token</option>
                  <option value="adrianlabcore">AdrianLABCore (AdrianZERO)</option>
                  <option value="traitscore">TraitsCore (ERC1155)</option>
                  <option value="traitsextensions">TraitsExtensions</option>
                  <option value="shop">AdrianShop</option>
                </select>
              </div>
              <div class="col-md-3">
                <label for="filterEventType" class="form-label">Event Type</label>
                <select class="form-select" id="filterEventType">
                  <option value="all">All Events</option>
                  <optgroup label="FloorEngine">
                    <option value="Listed">Listed</option>
                    <option value="Cancelled">Cancelled</option>
                    <option value="Bought">Bought</option>
                    <option value="FloorSweep">Floor Sweep</option>
                    <option value="PremiumUpdated">Premium Updated</option>
                    <option value="MaxBuyPriceUpdated">Max Buy Price Updated</option>
                  </optgroup>
                  <optgroup label="$ADRIAN Token">
                    <option value="Transfer">Transfer</option>
                    <option value="Approval">Approval</option>
                    <option value="Staked">Staked</option>
                    <option value="WithdrawnStake">Withdrawn Stake</option>
                    <option value="TaxFeeUpdated">Tax Fee Updated</option>
                    <option value="CreatorFeeUpdated">Creator Fee Updated</option>
                    <option value="BurnFeeUpdated">Burn Fee Updated</option>
                  </optgroup>
                  <optgroup label="AdrianZERO">
                    <option value="TokenMinted">Token Minted</option>
                    <option value="TokenBurnt">Token Burnt</option>
                    <option value="SkinAssigned">Skin Assigned</option>
                    <option value="SkinCreated">Skin Created</option>
                    <option value="MutationAssigned">Mutation Assigned</option>
                    <option value="MutationNameAssigned">Mutation Name Assigned</option>
                    <option value="SerumApplied">Serum Applied</option>
                    <option value="SpecialSkinApplied">Special Skin Applied</option>
                  </optgroup>
                  <optgroup label="TraitsCore">
                    <option value="TransferSingle">Transfer Single</option>
                    <option value="TransferBatch">Transfer Batch</option>
                    <option value="AssetRegistered">Asset Registered</option>
                    <option value="AssetMinted">Asset Minted</option>
                    <option value="AssetBurned">Asset Burned</option>
                    <option value="CategoryAdded">Category Added</option>
                    <option value="ExtensionAdded">Extension Added</option>
                  </optgroup>
                  <optgroup label="TraitsExtensions">
                    <option value="TraitEquipped">Trait Equipped</option>
                    <option value="TraitUnequipped">Trait Unequipped</option>
                    <option value="TraitApplied">Trait Applied</option>
                    <option value="TraitsAppliedBatch">Traits Applied Batch</option>
                    <option value="AssetAddedToInventory">Asset Added to Inventory</option>
                    <option value="AssetRemovedFromInventory">Asset Removed from Inventory</option>
                  </optgroup>
                  <optgroup label="AdrianShop">
                    <option value="ItemPurchased">Item Purchased</option>
                    <option value="BatchPurchase">Batch Purchase</option>
                    <option value="FreeItemClaimed">Free Item Claimed</option>
                    <option value="ShopItemConfigured">Shop Item Configured</option>
                    <option value="ShopItemStatusChanged">Shop Item Status Changed</option>
                  </optgroup>
                </select>
              </div>
              <div class="col-md-2">
                <label for="filterDateFrom" class="form-label">From Date</label>
                <input type="date" class="form-control" id="filterDateFrom">
              </div>
              <div class="col-md-2">
                <label for="filterDateTo" class="form-label">To Date</label>
                <input type="date" class="form-control" id="filterDateTo">
              </div>
              <div class="col-md-2">
                <label for="filterAddress" class="form-label">Address</label>
                <input type="text" class="form-control" id="filterAddress" placeholder="0x...">
              </div>
            </div>
            <div class="row mt-3">
              <div class="col-12">
                <button class="btn btn-primary" onclick="applyRawActivityFilters()">Apply Filters</button>
                <button class="btn btn-secondary" onclick="clearRawActivityFilters()">Clear</button>
              </div>
            </div>
          </div>
        </div>

            <!-- Activity List -->
            <div class="card">
              <div class="card-body">
                <div id="rawActivityList" class="activity-list">
                  <div class="loading-spinner">
                    <div class="spinner-border" role="status">
                      <span class="visually-hidden">Loading...</span>
                    </div>
                  </div>
                </div>
                <div id="rawActivityLoading" class="text-center mt-3" style="display: none;">
                  <div class="spinner-border" role="status">
                    <span class="visually-hidden">Loading more...</span>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </main>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
  <script>
    // Constants
    const ERC20_ADDRESS = '0x7e99075ce287f1cf8cbcaaa6a1c7894e404fd7ea';
    const BURN_ADDRESS = '0x0000000000000000000000000000000000000000';
    const FLOOR_ENGINE_ADDRESS = '0x0351F7cBA83277E891D4a85Da498A7eACD764D58';
    const ADRIANLABCORE_ADDRESS = '0x6e369bf0e4e0c106192d606fb6d85836d684da75';
    const TRAITS_CORE_ADDRESS = '0x90546848474fb3c9fda3fdad887969bb244e7e58';
    const TRAITS_EXTENSIONS_ADDRESS = '0x0995c0da1ca071b792e852b6ec531b7cd7d1f8d6';
    const ADRIAN_SHOP_ADDRESS = '0x4b265927b1521995ce416bba3bed98231d2e946b';

    // Supabase configuration
    const SUPABASE_URL = window.SUPABASE_URL || 'YOUR_SUPABASE_URL';
    const SUPABASE_ANON_KEY = window.SUPABASE_ANON_KEY || 'YOUR_SUPABASE_ANON_KEY';

    let supabaseClient = null;
    
    // Rules for images and tags
    let addressTagsRules = {};
    let imageRules = {};

    function initSupabase() {
      if (SUPABASE_URL && SUPABASE_ANON_KEY && SUPABASE_URL !== 'YOUR_SUPABASE_URL') {
        supabaseClient = supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
        console.log('Supabase initialized');
      } else {
        console.error('Supabase credentials not configured');
      }
    }
    
    // Load rules from JSON files
    async function loadRules() {
      try {
        // Address tags
        const tagsResponse = await fetch('./rules/address-tags.json');
        if (tagsResponse.ok) {
          const data = await tagsResponse.json();
          addressTagsRules = data.addressTags || {};
        }

        // Image rules
        const imagesResponse = await fetch('./rules/image-rules.json');
        if (imagesResponse.ok) {
          const data = await imagesResponse.json();
          imageRules = data.imageRules || {};
        }
      } catch (error) {
        console.error('Error loading rules:', error);
      }
    }
    
    // Get address tag badge
    function getAddressTagBadge(address, contextualTag) {
      if (contextualTag) {
        return `<span class="badge bg-${contextualTag.color} ms-2">${contextualTag.tag}</span>`;
      }
      const tagInfo = addressTagsRules[address?.toLowerCase()];
      if (!tagInfo) return '';
      return `<span class="badge bg-${tagInfo.color} ms-2">${tagInfo.tag}</span>`;
    }
    
    // Get event image based on type
    function getEventImage(event) {
      if (!imageRules || !imageRules.eventImages) return '';
      
      const eventImages = imageRules.eventImages;
      
      // TraitApplied: usar mannequin
      if (event.type === 'TraitsExtensions' && event.eventType === 'TraitApplied') {
        if (eventImages.TraitApplied && eventImages.TraitApplied.imageUrl) {
          return `<img src="${eventImages.TraitApplied.imageUrl}" class="nft-thumbnail" loading="lazy" decoding="async" alt="Mannequin" onerror="this.style.display='none'">`;
        }
      }
      
      // ERC20: usar ADRIAN_Coin.gif
      if (event.type === 'ERC20' && eventImages.ERC20 && eventImages.ERC20.imageUrl) {
        return `<img src="${eventImages.ERC20.imageUrl}" class="nft-thumbnail" loading="lazy" decoding="async" alt="ADRIAN Coin" onerror="this.style.display='none'">`;
      }
      
      // TraitsAppliedBatch: imagen dinámica
      if (event.type === 'TraitsExtensions' && event.eventType === 'TraitsAppliedBatch') {
        if (eventImages.TraitsAppliedBatch && eventImages.TraitsAppliedBatch.dynamic) {
          const tokenId = event.data?.token_id || event.data?.tokenId || event.data?.event_data?.tokenId || '0';
          let traitIds = event.data?.trait_ids || event.data?.traitIds || event.data?.event_data?.traitIds || [];
          
          if (typeof traitIds === 'string') {
            traitIds = traitIds.split(',').map(id => id.trim()).filter(id => id);
          }
          
          if (!Array.isArray(traitIds)) {
            traitIds = [];
          }
          
          if (traitIds.length > 0) {
            const traitParams = traitIds.map(id => `trait=${id}`).join('&');
            const imageUrl = `${eventImages.TraitsAppliedBatch.baseUrl}${tokenId}?${traitParams}`;
            return `<img src="${imageUrl}" class="nft-thumbnail" loading="lazy" decoding="async" alt="Custom Trait" onerror="this.style.display='none'">`;
          }
        }
      }
      
      // Contratos que usan imágenes de AdrianPunks
      if (imageRules && imageRules.adrianPunks && imageRules.adrianPunks.contracts) {
        const adrianPunksContracts = imageRules.adrianPunks.contracts;
        if (adrianPunksContracts.includes(event.type) && event.data?.token_id) {
          const tokenId = event.data.token_id;
          
          // AdrianLABCore usa API de render
          if (event.type === 'AdrianLABCore') {
            const imageUrl = `https://adrianlab.vercel.app/api/render/${tokenId}.png`;
            return `<img src="${imageUrl}" class="nft-thumbnail" loading="lazy" decoding="async" alt="Token #${tokenId}" onerror="this.style.display='none'" onclick="window.open('${imageUrl}', '_blank')">`;
          }
          
          // FloorEngine y otros usan imágenes locales
          const imageUrl = `${imageRules.adrianPunks.baseUrl}${tokenId}${imageRules.adrianPunks.extension}`;
          return `<img src="${imageUrl}" class="nft-thumbnail" loading="lazy" decoding="async" alt="Token #${tokenId}" onerror="this.style.display='none'" onclick="window.open('${imageUrl}', '_blank')">`;
        }
      }
      
      return '';
    }

    // Helper functions
    function formatWeiString(weiValue) {
      let weiStr = String(weiValue);
      if (weiStr.includes('e') || weiStr.includes('E')) {
        const num = parseFloat(weiStr);
        weiStr = num.toLocaleString('fullwide', { useGrouping: false, maximumFractionDigits: 0 });
      }
      weiStr = weiStr.replace(/,/g, '');
      return weiStr;
    }

    function formatADRIAN(weiString) {
      try {
        let weiStr = String(weiString);
        if (weiStr.includes('e') || weiStr.includes('E')) {
          const num = parseFloat(weiStr);
          weiStr = num.toLocaleString('fullwide', { useGrouping: false, maximumFractionDigits: 0 });
        }
        weiStr = weiStr.replace(/,/g, '');
        if (!/^\d+$/.test(weiStr)) {
          console.warn('Invalid wei value:', weiString);
          return '0.00';
        }
        const wei = ethers.BigNumber.from(weiStr);
        const adrian = parseFloat(ethers.utils.formatUnits(wei, 18));
        return adrian.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
      } catch (error) {
        console.error('Error formatting ADRIAN:', error, 'Value:', weiString);
        try {
          const num = parseFloat(weiString);
          const adrian = num / 1e18;
          return adrian.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
        } catch (e) {
          return '0.00';
        }
      }
    }

    function shortAddress(address) {
      return `${address.slice(0, 6)}...${address.slice(-4)}`;
    }

    // Chart instances
    let feVolumeChart = null;
    let feActivityChart = null;
    let tokenVolumeChart = null;
    let tokenTransactionsChart = null;
    let tokenSupplyChart = null;
    let tokenStakingChart = null;
    let alcMintingChart = null;
    let alcSkinChart = null;
    let alcMutationChart = null;
    let alcTransferChart = null;
    let tcMintingChart = null;
    let tcAssetChart = null;
    let teActivityChart = null;
    let teEventChart = null;
    let shopRevenueChart = null;
    let shopPurchaseTypeChart = null;

    // Load FloorEngine Statistics
    async function loadFloorEngineStats() {
      if (!supabaseClient) return;
      
      try {
        // Total invested
        const { data: sweeps, error: sweepsError } = await supabaseClient
          .from('sweep_events')
          .select('buy_price_wei');
        
        let totalInvested = ethers.BigNumber.from(0);
        if (sweeps && !sweepsError) {
          sweeps.forEach(sweep => {
            try {
              const buyPrice = formatWeiString(sweep.buy_price_wei);
              totalInvested = totalInvested.add(ethers.BigNumber.from(buyPrice));
            } catch (e) {
              console.warn('Error processing sweep buy_price:', e);
            }
          });
        }
        
        // Total earned
        const { data: trades, error: tradesError } = await supabaseClient
          .from('trade_events')
          .select('price_wei, is_contract_owned, created_at');
        
        let totalEarned = ethers.BigNumber.from(0);
        let punksSold = 0;
        const volumeData = [];
        if (trades && !tradesError) {
          trades.forEach(trade => {
            if (trade.is_contract_owned) {
              try {
                const price = formatWeiString(trade.price_wei);
                totalEarned = totalEarned.add(ethers.BigNumber.from(price));
                punksSold++;
                volumeData.push({
                  date: new Date(trade.created_at).toISOString().split('T')[0],
                  volume: parseFloat(ethers.utils.formatUnits(price, 18))
                });
              } catch (e) {
                console.warn('Error processing trade price:', e);
              }
            }
          });
        }
        
        const punksBought = sweeps ? sweeps.length : 0;
        
        // Currently listed
        const { data: listings, error: listingsError } = await supabaseClient
          .from('punk_listings')
          .select('price_wei')
          .eq('is_contract_owned', true)
          .eq('is_listed', true);
        
        let currentlyListed = 0;
        let listingsValue = ethers.BigNumber.from(0);
        if (listings && !listingsError) {
          currentlyListed = listings.length;
          listings.forEach(listing => {
            try {
              const price = formatWeiString(listing.price_wei);
              listingsValue = listingsValue.add(ethers.BigNumber.from(price));
            } catch (e) {
              console.warn('Error processing listing price:', e);
            }
          });
        }
        
        const netProfit = totalEarned.sub(totalInvested);
        const roi = totalInvested.gt(0) 
          ? netProfit.mul(10000).div(totalInvested).toNumber() / 100 
          : 0;
        
        // Update UI
        document.getElementById('feTotalInvested').textContent = formatADRIAN(totalInvested.toString()) + ' $ADRIAN';
        document.getElementById('feTotalEarned').textContent = formatADRIAN(totalEarned.toString()) + ' $ADRIAN';
        
        const netProfitEl = document.getElementById('feNetProfit');
        netProfitEl.textContent = formatADRIAN(netProfit.toString()) + ' $ADRIAN';
        netProfitEl.className = 'stat-value ' + (netProfit.gte(0) ? 'positive' : 'negative');
        
        const roiEl = document.getElementById('feROI');
        roiEl.textContent = roi.toFixed(2) + '%';
        roiEl.className = 'stat-value ' + (roi >= 0 ? 'positive' : 'negative');
        
        document.getElementById('fePunksBought').textContent = punksBought;
        document.getElementById('fePunksSold').textContent = punksSold;
        document.getElementById('feCurrentlyListed').textContent = currentlyListed;
        document.getElementById('feListingsValue').textContent = formatADRIAN(listingsValue.toString()) + ' $ADRIAN';

        // Create volume chart
        createFEVolumeChart(volumeData);
        
        // Get activity distribution
        const { data: listingEvents } = await supabaseClient
          .from('listing_events')
          .select('event_type');
        const { data: sweepEvents } = await supabaseClient
          .from('sweep_events')
          .select('*');
        
        const listedCount = listingEvents?.filter(e => e.event_type === 'Listed').length || 0;
        const cancelledCount = listingEvents?.filter(e => e.event_type === 'Cancelled').length || 0;
        const boughtCount = punksSold;
        const sweepCount = sweepEvents?.length || 0;
        
        createFEActivityChart(listedCount, cancelledCount, boughtCount, sweepCount);
        
      } catch (error) {
        console.error('Error loading FloorEngine stats:', error);
      }
    }

    // Load Token Statistics
    async function loadTokenStats() {
      if (!supabaseClient) return;
      
      try {
        // Total minted
        const { data: mints, error: mintsError } = await supabaseClient
          .from('erc20_transfers')
          .select('value_wei')
          .eq('contract_address', ERC20_ADDRESS)
          .eq('from_address', BURN_ADDRESS);
        
        let totalMinted = ethers.BigNumber.from(0);
        if (mints && !mintsError) {
          mints.forEach(mint => {
            try {
              const value = formatWeiString(mint.value_wei);
              totalMinted = totalMinted.add(ethers.BigNumber.from(value));
            } catch (e) {
              console.warn('Error processing mint:', e);
            }
          });
        }
        
        // Total burned
        const { data: burns, error: burnsError } = await supabaseClient
          .from('erc20_transfers')
          .select('value_wei')
          .eq('contract_address', ERC20_ADDRESS)
          .eq('to_address', BURN_ADDRESS);
        
        let totalBurned = ethers.BigNumber.from(0);
        if (burns && !burnsError) {
          burns.forEach(burn => {
            try {
              const value = formatWeiString(burn.value_wei);
              totalBurned = totalBurned.add(ethers.BigNumber.from(value));
            } catch (e) {
              console.warn('Error processing burn:', e);
            }
          });
        }
        
        const totalSupply = totalMinted.sub(totalBurned);
        
        // 24h volume and transactions
        const yesterday = new Date();
        yesterday.setDate(yesterday.getDate() - 1);
        const yesterdayISO = yesterday.toISOString();
        
        const { data: transfers24h, error: transfers24hError } = await supabaseClient
          .from('erc20_transfers')
          .select('value_wei, created_at')
          .eq('contract_address', ERC20_ADDRESS)
          .gte('created_at', yesterdayISO);
        
        let volume24h = ethers.BigNumber.from(0);
        let transactions24h = 0;
        const volumeData = [];
        if (transfers24h && !transfers24hError) {
          transactions24h = transfers24h.length;
          transfers24h.forEach(transfer => {
            try {
              const value = formatWeiString(transfer.value_wei);
              volume24h = volume24h.add(ethers.BigNumber.from(value));
              const date = new Date(transfer.created_at).toISOString().split('T')[0];
              volumeData.push({
                date: date,
                volume: parseFloat(ethers.utils.formatUnits(value, 18))
              });
            } catch (e) {
              console.warn('Error processing transfer:', e);
            }
          });
        }
        
        // Total holders (unique addresses with balance > 0)
        // Calculate balances by summing received and subtracting sent
        const { data: received } = await supabaseClient
          .from('erc20_transfers')
          .select('to_address, value_wei')
          .eq('contract_address', ERC20_ADDRESS)
          .neq('to_address', BURN_ADDRESS);
        
        const { data: sent } = await supabaseClient
          .from('erc20_transfers')
          .select('from_address, value_wei')
          .eq('contract_address', ERC20_ADDRESS)
          .neq('from_address', BURN_ADDRESS);
        
        const balances = new Map();
        
        // Add received amounts
        if (received) {
          received.forEach(transfer => {
            try {
              const value = formatWeiString(transfer.value_wei);
              const amount = ethers.BigNumber.from(value);
              const current = balances.get(transfer.to_address) || ethers.BigNumber.from(0);
              balances.set(transfer.to_address, current.add(amount));
            } catch (e) {
              console.warn('Error processing received transfer:', e);
            }
          });
        }
        
        // Subtract sent amounts
        if (sent) {
          sent.forEach(transfer => {
            try {
              const value = formatWeiString(transfer.value_wei);
              const amount = ethers.BigNumber.from(value);
              const current = balances.get(transfer.from_address) || ethers.BigNumber.from(0);
              balances.set(transfer.from_address, current.sub(amount));
            } catch (e) {
              console.warn('Error processing sent transfer:', e);
            }
          });
        }
        
        // Filter positive balances
        const positiveBalances = Array.from(balances.entries())
          .filter(([address, balance]) => balance.gt(0));
        
        const totalHolders = positiveBalances.length;
        const circulatingSupply = positiveBalances
          .reduce((sum, [address, balance]) => sum.add(balance), ethers.BigNumber.from(0));
        
        // Total staked
        const { data: stakes, error: stakesError } = await supabaseClient
          .from('erc20_custom_events')
          .select('event_data')
          .eq('contract_address', ERC20_ADDRESS)
          .eq('event_name', 'Staked');
        
        let totalStaked = ethers.BigNumber.from(0);
        if (stakes && !stakesError) {
          stakes.forEach(stake => {
            try {
              const amount = stake.event_data?.amount;
              if (amount) {
                const value = formatWeiString(amount);
                totalStaked = totalStaked.add(ethers.BigNumber.from(value));
              }
            } catch (e) {
              console.warn('Error processing stake:', e);
            }
          });
        }
        
        // Total rewards
        const { data: withdrawals, error: withdrawalsError } = await supabaseClient
          .from('erc20_custom_events')
          .select('event_data')
          .eq('contract_address', ERC20_ADDRESS)
          .eq('event_name', 'WithdrawnStake');
        
        let totalRewards = ethers.BigNumber.from(0);
        if (withdrawals && !withdrawalsError) {
          withdrawals.forEach(withdrawal => {
            try {
              const reward = withdrawal.event_data?.reward;
              if (reward) {
                const value = formatWeiString(reward);
                totalRewards = totalRewards.add(ethers.BigNumber.from(value));
              }
            } catch (e) {
              console.warn('Error processing reward:', e);
            }
          });
        }
        
        // Total transfers
        const { data: allTransfersCount } = await supabaseClient
          .from('erc20_transfers')
          .select('id', { count: 'exact', head: true })
          .eq('contract_address', ERC20_ADDRESS);
        
        const totalTransfers = allTransfersCount || 0;
        
        // Update UI
        document.getElementById('tokenTotalSupply').textContent = formatADRIAN(totalSupply.toString()) + ' $ADRIAN';
        document.getElementById('tokenCirculatingSupply').textContent = formatADRIAN(circulatingSupply.toString()) + ' $ADRIAN';
        document.getElementById('tokenTotalHolders').textContent = totalHolders.toLocaleString();
        document.getElementById('token24hVolume').textContent = formatADRIAN(volume24h.toString()) + ' $ADRIAN';
        document.getElementById('token24hTransactions').textContent = transactions24h.toLocaleString();
        document.getElementById('tokenTotalStaked').textContent = formatADRIAN(totalStaked.toString()) + ' $ADRIAN';
        document.getElementById('tokenTotalRewards').textContent = formatADRIAN(totalRewards.toString()) + ' $ADRIAN';
        document.getElementById('tokenTotalTransfers').textContent = totalTransfers.toLocaleString();

        // Create charts
        createTokenVolumeChart(volumeData);
        createTokenTransactionsChart();
        createTokenSupplyChart(totalMinted, totalBurned, circulatingSupply);
        createTokenStakingChart();
        
        // Load top holders (convert to array format)
        const holdersMap = new Map();
        positiveBalances.forEach(([address, balance]) => {
          holdersMap.set(address, balance);
        });
        loadTopHolders(holdersMap);
        
      } catch (error) {
        console.error('Error loading token stats:', error);
      }
    }

    // Load AdrianLABCore Statistics
    async function loadAdrianLABCoreStats() {
      if (!supabaseClient) return;
      
      try {
        // Total minted
        const { data: mints, error: mintsError } = await supabaseClient
          .from('erc721_custom_events')
          .select('event_data, created_at')
          .eq('contract_address', ADRIANLABCORE_ADDRESS)
          .eq('event_name', 'TokenMinted');
        
        let totalMinted = 0;
        const mintingData = [];
        if (mints && !mintsError) {
          totalMinted = mints.length;
          const grouped = {};
          mints.forEach(mint => {
            const date = new Date(mint.created_at).toISOString().split('T')[0];
            grouped[date] = (grouped[date] || 0) + 1;
          });
          mintingData.push(...Object.entries(grouped).map(([date, count]) => ({ date, count })));
        }
        
        // Total burned
        const { data: burns, error: burnsError } = await supabaseClient
          .from('erc721_custom_events')
          .select('*')
          .eq('contract_address', ADRIANLABCORE_ADDRESS)
          .eq('event_name', 'TokenBurnt');
        
        const totalBurned = burns && !burnsError ? burns.length : 0;
        const totalSupply = totalMinted - totalBurned;
        
        // Unique holders
        const { data: transfers } = await supabaseClient
          .from('erc721_transfers')
          .select('to_address')
          .eq('contract_address', ADRIANLABCORE_ADDRESS)
          .neq('to_address', BURN_ADDRESS);
        
        const uniqueHolders = new Set();
        if (transfers) {
          transfers.forEach(t => uniqueHolders.add(t.to_address));
        }
        
        // Total transfers
        const { data: allTransfers } = await supabaseClient
          .from('erc721_transfers')
          .select('created_at')
          .eq('contract_address', ADRIANLABCORE_ADDRESS);
        
        const totalTransfers = allTransfers ? allTransfers.length : 0;
        
        // Skins assigned
        const { data: skins } = await supabaseClient
          .from('erc721_custom_events')
          .select('event_data')
          .eq('contract_address', ADRIANLABCORE_ADDRESS)
          .eq('event_name', 'SkinAssigned');
        
        const skinsAssigned = skins ? skins.length : 0;
        const skinDistribution = {};
        if (skins) {
          skins.forEach(skin => {
            const skinName = skin.event_data?.name || 'Unknown';
            skinDistribution[skinName] = (skinDistribution[skinName] || 0) + 1;
          });
        }
        
        // Tokens mutated
        const { data: mutations } = await supabaseClient
          .from('erc721_custom_events')
          .select('event_data')
          .eq('contract_address', ADRIANLABCORE_ADDRESS)
          .eq('event_name', 'MutationNameAssigned');
        
        const tokensMutated = mutations ? mutations.length : 0;
        const mutationDistribution = {};
        if (mutations) {
          mutations.forEach(mutation => {
            const mutationName = mutation.event_data?.newMutation || 'Unknown';
            mutationDistribution[mutationName] = (mutationDistribution[mutationName] || 0) + 1;
          });
        }
        
        // Serums applied
        const { data: serums } = await supabaseClient
          .from('erc721_custom_events')
          .select('*')
          .eq('contract_address', ADRIANLABCORE_ADDRESS)
          .eq('event_name', 'SerumApplied');
        
        const serumsApplied = serums ? serums.length : 0;
        
        // Transfer activity over time
        const transferData = [];
        if (allTransfers) {
          const grouped = {};
          allTransfers.forEach(transfer => {
            const date = new Date(transfer.created_at).toISOString().split('T')[0];
            grouped[date] = (grouped[date] || 0) + 1;
          });
          transferData.push(...Object.entries(grouped).map(([date, count]) => ({ date, count })));
        }
        
        // Update UI
        document.getElementById('alcTotalSupply').textContent = totalSupply.toLocaleString();
        document.getElementById('alcTotalMinted').textContent = totalMinted.toLocaleString();
        document.getElementById('alcTotalBurned').textContent = totalBurned.toLocaleString();
        document.getElementById('alcUniqueHolders').textContent = uniqueHolders.size.toLocaleString();
        document.getElementById('alcTotalTransfers').textContent = totalTransfers.toLocaleString();
        document.getElementById('alcSkinsAssigned').textContent = skinsAssigned.toLocaleString();
        document.getElementById('alcTokensMutated').textContent = tokensMutated.toLocaleString();
        document.getElementById('alcSerumsApplied').textContent = serumsApplied.toLocaleString();

        // Create charts
        createALCMintingChart(mintingData);
        createALCSkinChart(skinDistribution);
        createALCMutationChart(mutationDistribution);
        createALCTransferChart(transferData);
        
      } catch (error) {
        console.error('Error loading AdrianLABCore stats:', error);
      }
    }

    // Load TraitsCore Statistics
    async function loadTraitsCoreStats() {
      if (!supabaseClient) return;
      
      try {
        // Total assets registered
        const { data: assets, error: assetsError } = await supabaseClient
          .from('erc1155_custom_events')
          .select('event_data')
          .eq('contract_address', TRAITS_CORE_ADDRESS)
          .eq('event_name', 'AssetRegistered');
        
        const totalAssets = assets && !assetsError ? assets.length : 0;
        
        // Total minted
        const { data: mints, error: mintsError } = await supabaseClient
          .from('erc1155_custom_events')
          .select('event_data')
          .eq('contract_address', TRAITS_CORE_ADDRESS)
          .eq('event_name', 'AssetMinted');
        
        let totalMinted = 0;
        const assetMints = {};
        if (mints && !mintsError) {
          mints.forEach(mint => {
            const amount = parseInt(mint.event_data?.amount || 0);
            totalMinted += amount;
            const assetId = mint.event_data?.assetId || 'Unknown';
            assetMints[assetId] = (assetMints[assetId] || 0) + amount;
          });
        }
        
        // Total burned
        const { data: burns, error: burnsError } = await supabaseClient
          .from('erc1155_custom_events')
          .select('event_data')
          .eq('contract_address', TRAITS_CORE_ADDRESS)
          .eq('event_name', 'AssetBurned');
        
        let totalBurned = 0;
        if (burns && !burnsError) {
          burns.forEach(burn => {
            totalBurned += parseInt(burn.event_data?.amount || 0);
          });
        }
        
        // Unique holders from transfers
        const { data: transfersSingle } = await supabaseClient
          .from('erc1155_transfers_single')
          .select('to_address')
          .eq('contract_address', TRAITS_CORE_ADDRESS)
          .neq('to_address', BURN_ADDRESS);
        
        const uniqueHolders = new Set();
        if (transfersSingle) {
          transfersSingle.forEach(t => uniqueHolders.add(t.to_address));
        }
        
        // Total transfers (single + batch)
        const { data: singleCount } = await supabaseClient
          .from('erc1155_transfers_single')
          .select('id', { count: 'exact', head: true })
          .eq('contract_address', TRAITS_CORE_ADDRESS);
        
        const { data: batchCount } = await supabaseClient
          .from('erc1155_transfers_batch')
          .select('id', { count: 'exact', head: true })
          .eq('contract_address', TRAITS_CORE_ADDRESS);
        
        const totalTransfers = (singleCount || 0) + (batchCount || 0);
        const batchTransfers = batchCount || 0;
        
        // Categories
        const { data: categoriesAdded } = await supabaseClient
          .from('erc1155_custom_events')
          .select('event_data')
          .eq('contract_address', TRAITS_CORE_ADDRESS)
          .eq('event_name', 'CategoryAdded');
        
        const categories = categoriesAdded && categoriesAdded.length > 0 ? categoriesAdded.length : 0;
        
        // Extensions
        const { data: extensionsAdded } = await supabaseClient
          .from('erc1155_custom_events')
          .select('event_data')
          .eq('contract_address', TRAITS_CORE_ADDRESS)
          .eq('event_name', 'ExtensionAdded');
        
        const extensions = extensionsAdded && extensionsAdded.length > 0 ? extensionsAdded.length : 0;
        
        // Update UI
        document.getElementById('tcTotalAssets').textContent = totalAssets.toLocaleString();
        document.getElementById('tcTotalMinted').textContent = totalMinted.toLocaleString();
        document.getElementById('tcTotalBurned').textContent = totalBurned.toLocaleString();
        document.getElementById('tcUniqueHolders').textContent = uniqueHolders.size.toLocaleString();
        document.getElementById('tcTotalTransfers').textContent = totalTransfers.toLocaleString();
        document.getElementById('tcBatchTransfers').textContent = batchTransfers.toLocaleString();
        document.getElementById('tcCategories').textContent = categories.toLocaleString();
        document.getElementById('tcExtensions').textContent = extensions.toLocaleString();
        
        // Create charts
        createTCMintingChart(mints || []);
        createTCAssetChart(assetMints);
        
      } catch (error) {
        console.error('Error loading TraitsCore stats:', error);
      }
    }

    // Load TraitsExtensions Statistics
    async function loadTraitsExtensionsStats() {
      if (!supabaseClient) return;
      
      try {
        const { data: events, error: eventsError } = await supabaseClient
          .from('traits_extensions_events')
          .select('event_name, event_data, created_at')
          .eq('contract_address', TRAITS_EXTENSIONS_ADDRESS);
        
        let traitsApplied = 0;
        let traitsEquipped = 0;
        let traitsUnequipped = 0;
        let batchApplications = 0;
        let inventoryAdded = 0;
        let inventoryRemoved = 0;
        const uniqueTokens = new Set();
        const activityByDate = {};
        const eventDistribution = {};
        
        if (events && !eventsError) {
          events.forEach(event => {
            const date = new Date(event.created_at).toISOString().split('T')[0];
            activityByDate[date] = (activityByDate[date] || 0) + 1;
            eventDistribution[event.event_name] = (eventDistribution[event.event_name] || 0) + 1;
            
            const tokenId = event.event_data?.tokenId;
            if (tokenId) uniqueTokens.add(tokenId);
            
            switch (event.event_name) {
              case 'TraitApplied':
                traitsApplied++;
                break;
              case 'TraitEquipped':
                traitsEquipped++;
                break;
              case 'TraitUnequipped':
                traitsUnequipped++;
                break;
              case 'TraitsAppliedBatch':
                batchApplications++;
                const traitIds = event.event_data?.traitIds || [];
                traitsApplied += traitIds.length;
                break;
              case 'AssetAddedToInventory':
                inventoryAdded++;
                break;
              case 'AssetRemovedFromInventory':
                inventoryRemoved++;
                break;
            }
          });
        }
        
        // Update UI
        document.getElementById('teTraitsApplied').textContent = traitsApplied.toLocaleString();
        document.getElementById('teTraitsEquipped').textContent = traitsEquipped.toLocaleString();
        document.getElementById('teTraitsUnequipped').textContent = traitsUnequipped.toLocaleString();
        document.getElementById('teBatchApplications').textContent = batchApplications.toLocaleString();
        document.getElementById('teInventoryAdded').textContent = inventoryAdded.toLocaleString();
        document.getElementById('teInventoryRemoved').textContent = inventoryRemoved.toLocaleString();
        document.getElementById('teUniqueTokens').textContent = uniqueTokens.size.toLocaleString();
        document.getElementById('teTotalEvents').textContent = (events?.length || 0).toLocaleString();
        
        // Create charts
        createTEActivityChart(activityByDate);
        createTEEventChart(eventDistribution);
        
      } catch (error) {
        console.error('Error loading TraitsExtensions stats:', error);
      }
    }

    // Load AdrianShop Statistics
    async function loadAdrianShopStats() {
      if (!supabaseClient) return;
      
      try {
        const { data: events, error: eventsError } = await supabaseClient
          .from('shop_events')
          .select('event_name, event_data, created_at')
          .eq('contract_address', ADRIAN_SHOP_ADDRESS);
        
        let totalPurchases = 0;
        let totalRevenue = ethers.BigNumber.from(0);
        const uniqueBuyers = new Set();
        let batchPurchases = 0;
        let freeClaims = 0;
        let activeItems = 0;
        let allowlists = 0;
        let purchases24h = 0;
        const revenueByDate = {};
        const purchaseTypes = { individual: 0, batch: 0, free: 0 };
        
        const yesterday = new Date();
        yesterday.setDate(yesterday.getDate() - 1);
        
        if (events && !eventsError) {
          events.forEach(event => {
            const date = new Date(event.created_at).toISOString().split('T')[0];
            
            switch (event.event_name) {
              case 'ItemPurchased':
                totalPurchases++;
                purchaseTypes.individual++;
                const buyer = event.event_data?.buyer;
                if (buyer) uniqueBuyers.add(buyer);
                
                const totalCost = event.event_data?.totalCost;
                if (totalCost) {
                  try {
                    const cost = formatWeiString(totalCost);
                    totalRevenue = totalRevenue.add(ethers.BigNumber.from(cost));
                    const costNum = parseFloat(ethers.utils.formatUnits(cost, 18));
                    revenueByDate[date] = (revenueByDate[date] || 0) + costNum;
                  } catch (e) {
                    console.warn('Error processing purchase cost:', e);
                  }
                }
                
                if (new Date(event.created_at) >= yesterday) {
                  purchases24h++;
                }
                break;
                
              case 'BatchPurchase':
                batchPurchases++;
                purchaseTypes.batch++;
                const batchBuyer = event.event_data?.buyer;
                if (batchBuyer) uniqueBuyers.add(batchBuyer);
                
                const batchCost = event.event_data?.totalCost;
                if (batchCost) {
                  try {
                    const cost = formatWeiString(batchCost);
                    totalRevenue = totalRevenue.add(ethers.BigNumber.from(cost));
                    const costNum = parseFloat(ethers.utils.formatUnits(cost, 18));
                    revenueByDate[date] = (revenueByDate[date] || 0) + costNum;
                  } catch (e) {
                    console.warn('Error processing batch cost:', e);
                  }
                }
                
                if (new Date(event.created_at) >= yesterday) {
                  purchases24h++;
                }
                break;
                
              case 'FreeItemClaimed':
                freeClaims++;
                purchaseTypes.free++;
                const claimer = event.event_data?.user;
                if (claimer) uniqueBuyers.add(claimer);
                
                if (new Date(event.created_at) >= yesterday) {
                  purchases24h++;
                }
                break;
                
              case 'ShopItemConfigured':
                activeItems++;
                break;
                
              case 'AllowlistConfigured':
                allowlists++;
                break;
            }
          });
        }
        
        // Update UI
        document.getElementById('shopTotalPurchases').textContent = totalPurchases.toLocaleString();
        document.getElementById('shopTotalRevenue').textContent = formatADRIAN(totalRevenue.toString()) + ' $ADRIAN';
        document.getElementById('shopUniqueBuyers').textContent = uniqueBuyers.size.toLocaleString();
        document.getElementById('shopBatchPurchases').textContent = batchPurchases.toLocaleString();
        document.getElementById('shopFreeClaims').textContent = freeClaims.toLocaleString();
        document.getElementById('shopActiveItems').textContent = activeItems.toLocaleString();
        document.getElementById('shopAllowlists').textContent = allowlists.toLocaleString();
        document.getElementById('shop24hPurchases').textContent = purchases24h.toLocaleString();
        
        // Create charts
        createShopRevenueChart(revenueByDate);
        createShopPurchaseTypeChart(purchaseTypes);
        
      } catch (error) {
        console.error('Error loading AdrianShop stats:', error);
      }
    }

    function createTCMintingChart(mints) {
      const ctx = document.getElementById('tcMintingChart');
      if (!ctx) return;
      
      const grouped = {};
      mints.forEach(mint => {
        const assetId = mint.event_data?.assetId || 'Unknown';
        grouped[assetId] = (grouped[assetId] || 0) + parseInt(mint.event_data?.amount || 0);
      });
      
      const labels = Object.keys(grouped).slice(0, 10);
      const amounts = labels.map(label => grouped[label]);
      
      if (tcMintingChart) {
        tcMintingChart.destroy();
      }
      
      tcMintingChart = new Chart(ctx, {
        type: 'bar',
        data: {
          labels: labels,
          datasets: [{
            label: 'Amount Minted',
            data: amounts,
            backgroundColor: '#17a2b8'
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              display: false
            }
          },
          scales: {
            y: {
              beginAtZero: true
            }
          }
        }
      });
    }

    function createTCAssetChart(assetMints) {
      const ctx = document.getElementById('tcAssetChart');
      if (!ctx) return;
      
      const labels = Object.keys(assetMints).slice(0, 10);
      const amounts = labels.map(label => assetMints[label]);
      
      if (tcAssetChart) {
        tcAssetChart.destroy();
      }
      
      tcAssetChart = new Chart(ctx, {
        type: 'doughnut',
        data: {
          labels: labels.map(l => `Asset #${l}`),
          datasets: [{
            data: amounts,
            backgroundColor: [
              '#17a2b8', '#28a745', '#ffc107', '#dc3545', '#6c757d',
              '#007bff', '#9c27b0', '#ff9800', '#4caf50', '#e91e63'
            ]
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              position: 'bottom'
            }
          }
        }
      });
    }

    function createTEActivityChart(activityByDate) {
      const ctx = document.getElementById('teActivityChart');
      if (!ctx) return;
      
      const labels = Object.keys(activityByDate).sort();
      const counts = labels.map(date => activityByDate[date]);
      
      if (teActivityChart) {
        teActivityChart.destroy();
      }
      
      teActivityChart = new Chart(ctx, {
        type: 'line',
        data: {
          labels: labels,
          datasets: [{
            label: 'Events',
            data: counts,
            borderColor: '#ff9800',
            backgroundColor: 'rgba(255, 152, 0, 0.1)',
            tension: 0.4
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              display: true
            }
          },
          scales: {
            y: {
              beginAtZero: true
            }
          }
        }
      });
    }

    function createTEEventChart(eventDistribution) {
      const ctx = document.getElementById('teEventChart');
      if (!ctx) return;
      
      const labels = Object.keys(eventDistribution);
      const counts = labels.map(label => eventDistribution[label]);
      
      if (teEventChart) {
        teEventChart.destroy();
      }
      
      teEventChart = new Chart(ctx, {
        type: 'bar',
        data: {
          labels: labels,
          datasets: [{
            label: 'Count',
            data: counts,
            backgroundColor: '#ff9800'
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              display: false
            }
          },
          scales: {
            y: {
              beginAtZero: true
            }
          }
        }
      });
    }

    function createShopRevenueChart(revenueByDate) {
      const ctx = document.getElementById('shopRevenueChart');
      if (!ctx) return;
      
      const labels = Object.keys(revenueByDate).sort();
      const revenues = labels.map(date => revenueByDate[date]);
      
      if (shopRevenueChart) {
        shopRevenueChart.destroy();
      }
      
      shopRevenueChart = new Chart(ctx, {
        type: 'line',
        data: {
          labels: labels,
          datasets: [{
            label: 'Revenue ($ADRIAN)',
            data: revenues,
            borderColor: '#4caf50',
            backgroundColor: 'rgba(76, 175, 80, 0.1)',
            tension: 0.4
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              display: true
            }
          },
          scales: {
            y: {
              beginAtZero: true
            }
          }
        }
      });
    }

    function createShopPurchaseTypeChart(purchaseTypes) {
      const ctx = document.getElementById('shopPurchaseTypeChart');
      if (!ctx) return;
      
      if (shopPurchaseTypeChart) {
        shopPurchaseTypeChart.destroy();
      }
      
      shopPurchaseTypeChart = new Chart(ctx, {
        type: 'pie',
        data: {
          labels: ['Individual', 'Batch', 'Free Claims'],
          datasets: [{
            data: [purchaseTypes.individual, purchaseTypes.batch, purchaseTypes.free],
            backgroundColor: [
              '#4caf50',
              '#2196f3',
              '#ffc107'
            ]
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              position: 'bottom'
            }
          }
        }
      });
    }

    function createALCMintingChart(data) {
      const ctx = document.getElementById('alcMintingChart');
      if (!ctx) return;
      
      const labels = data.map(d => d.date).sort();
      const counts = labels.map(date => {
        const item = data.find(d => d.date === date);
        return item ? item.count : 0;
      });
      
      if (alcMintingChart) {
        alcMintingChart.destroy();
      }
      
      alcMintingChart = new Chart(ctx, {
        type: 'line',
        data: {
          labels: labels,
          datasets: [{
            label: 'Tokens Minted',
            data: counts,
            borderColor: '#9c27b0',
            backgroundColor: 'rgba(156, 39, 176, 0.1)',
            tension: 0.4
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              display: true
            }
          },
          scales: {
            y: {
              beginAtZero: true
            }
          }
        }
      });
    }

    function createALCSkinChart(distribution) {
      const ctx = document.getElementById('alcSkinChart');
      if (!ctx) return;
      
      const labels = Object.keys(distribution).slice(0, 10);
      const counts = labels.map(label => distribution[label]);
      
      if (alcSkinChart) {
        alcSkinChart.destroy();
      }
      
      alcSkinChart = new Chart(ctx, {
        type: 'doughnut',
        data: {
          labels: labels,
          datasets: [{
            data: counts,
            backgroundColor: [
              '#9c27b0', '#e91e63', '#f44336', '#ff9800', '#ffc107',
              '#4caf50', '#2196f3', '#3f51b5', '#673ab7', '#795548'
            ]
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              position: 'bottom'
            }
          }
        }
      });
    }

    function createALCMutationChart(distribution) {
      const ctx = document.getElementById('alcMutationChart');
      if (!ctx) return;
      
      const labels = Object.keys(distribution).slice(0, 10);
      const counts = labels.map(label => distribution[label]);
      
      if (alcMutationChart) {
        alcMutationChart.destroy();
      }
      
      alcMutationChart = new Chart(ctx, {
        type: 'bar',
        data: {
          labels: labels,
          datasets: [{
            label: 'Mutations',
            data: counts,
            backgroundColor: '#9c27b0'
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              display: false
            }
          },
          scales: {
            y: {
              beginAtZero: true
            }
          }
        }
      });
    }

    function createALCTransferChart(data) {
      const ctx = document.getElementById('alcTransferChart');
      if (!ctx) return;
      
      const labels = data.map(d => d.date).sort();
      const counts = labels.map(date => {
        const item = data.find(d => d.date === date);
        return item ? item.count : 0;
      });
      
      if (alcTransferChart) {
        alcTransferChart.destroy();
      }
      
      alcTransferChart = new Chart(ctx, {
        type: 'line',
        data: {
          labels: labels,
          datasets: [{
            label: 'Transfers',
            data: counts,
            borderColor: '#9c27b0',
            backgroundColor: 'rgba(156, 39, 176, 0.1)',
            tension: 0.4
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              display: true
            }
          },
          scales: {
            y: {
              beginAtZero: true
            }
          }
        }
      });
    }

    // Chart creation functions
    function createFEVolumeChart(data) {
      const ctx = document.getElementById('feVolumeChart');
      if (!ctx) return;
      
      // Group by date
      const grouped = {};
      data.forEach(item => {
        if (!grouped[item.date]) {
          grouped[item.date] = 0;
        }
        grouped[item.date] += item.volume;
      });
      
      const labels = Object.keys(grouped).sort();
      const volumes = labels.map(date => grouped[date]);
      
      if (feVolumeChart) {
        feVolumeChart.destroy();
      }
      
      feVolumeChart = new Chart(ctx, {
        type: 'line',
        data: {
          labels: labels,
          datasets: [{
            label: 'Volume ($ADRIAN)',
            data: volumes,
            borderColor: '#007bff',
            backgroundColor: 'rgba(0, 123, 255, 0.1)',
            tension: 0.4
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              display: true
            }
          },
          scales: {
            y: {
              beginAtZero: true
            }
          }
        }
      });
    }

    function createFEActivityChart(listed, cancelled, bought, sweeps) {
      const ctx = document.getElementById('feActivityChart');
      if (!ctx) return;
      
      if (feActivityChart) {
        feActivityChart.destroy();
      }
      
      feActivityChart = new Chart(ctx, {
        type: 'doughnut',
        data: {
          labels: ['Listed', 'Cancelled', 'Bought', 'Sweeps'],
          datasets: [{
            data: [listed, cancelled, bought, sweeps],
            backgroundColor: [
              '#007bff',
              '#6c757d',
              '#28a745',
              '#ffc107'
            ]
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              position: 'bottom'
            }
          }
        }
      });
    }

    function createTokenVolumeChart(data) {
      const ctx = document.getElementById('tokenVolumeChart');
      if (!ctx) return;
      
      // Group by date
      const grouped = {};
      data.forEach(item => {
        if (!grouped[item.date]) {
          grouped[item.date] = 0;
        }
        grouped[item.date] += item.volume;
      });
      
      const labels = Object.keys(grouped).sort();
      const volumes = labels.map(date => grouped[date]);
      
      if (tokenVolumeChart) {
        tokenVolumeChart.destroy();
      }
      
      tokenVolumeChart = new Chart(ctx, {
        type: 'line',
        data: {
          labels: labels,
          datasets: [{
            label: 'Volume ($ADRIAN)',
            data: volumes,
            borderColor: '#28a745',
            backgroundColor: 'rgba(40, 167, 69, 0.1)',
            tension: 0.4
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              display: true
            }
          },
          scales: {
            y: {
              beginAtZero: true
            }
          }
        }
      });
    }

    async function createTokenTransactionsChart() {
      const ctx = document.getElementById('tokenTransactionsChart');
      if (!ctx) return;
      
      // Get last 7 days of transactions
      const sevenDaysAgo = new Date();
      sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);
      
      const { data: transfers } = await supabaseClient
        .from('erc20_transfers')
        .select('created_at')
        .eq('contract_address', ERC20_ADDRESS)
        .gte('created_at', sevenDaysAgo.toISOString())
        .order('created_at', { ascending: true });
      
      const grouped = {};
      transfers?.forEach(transfer => {
        const date = new Date(transfer.created_at).toISOString().split('T')[0];
        grouped[date] = (grouped[date] || 0) + 1;
      });
      
      const labels = Object.keys(grouped).sort();
      const counts = labels.map(date => grouped[date]);
      
      if (tokenTransactionsChart) {
        tokenTransactionsChart.destroy();
      }
      
      tokenTransactionsChart = new Chart(ctx, {
        type: 'bar',
        data: {
          labels: labels,
          datasets: [{
            label: 'Transactions',
            data: counts,
            backgroundColor: '#17a2b8'
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              display: true
            }
          },
          scales: {
            y: {
              beginAtZero: true
            }
          }
        }
      });
    }

    function createTokenSupplyChart(minted, burned, circulating) {
      const ctx = document.getElementById('tokenSupplyChart');
      if (!ctx) return;
      
      const mintedFormatted = parseFloat(ethers.utils.formatUnits(minted, 18));
      const burnedFormatted = parseFloat(ethers.utils.formatUnits(burned, 18));
      const circulatingFormatted = parseFloat(ethers.utils.formatUnits(circulating, 18));
      
      if (tokenSupplyChart) {
        tokenSupplyChart.destroy();
      }
      
      tokenSupplyChart = new Chart(ctx, {
        type: 'pie',
        data: {
          labels: ['Circulating', 'Burned', 'Other'],
          datasets: [{
            data: [
              circulatingFormatted,
              burnedFormatted,
              Math.max(0, mintedFormatted - circulatingFormatted - burnedFormatted)
            ],
            backgroundColor: [
              '#28a745',
              '#dc3545',
              '#6c757d'
            ]
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              position: 'bottom'
            }
          }
        }
      });
    }

    async function createTokenStakingChart() {
      const ctx = document.getElementById('tokenStakingChart');
      if (!ctx) return;
      
      // Get staking data for last 30 days
      const thirtyDaysAgo = new Date();
      thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
      
      const { data: stakes } = await supabaseClient
        .from('erc20_custom_events')
        .select('created_at, event_data')
        .eq('contract_address', ERC20_ADDRESS)
        .eq('event_name', 'Staked')
        .gte('created_at', thirtyDaysAgo.toISOString())
        .order('created_at', { ascending: true });
      
      const grouped = {};
      stakes?.forEach(stake => {
        const date = new Date(stake.created_at).toISOString().split('T')[0];
        if (!grouped[date]) {
          grouped[date] = 0;
        }
        try {
          const amount = stake.event_data?.amount;
          if (amount) {
            const value = formatWeiString(amount);
            grouped[date] += parseFloat(ethers.utils.formatUnits(value, 18));
          }
        } catch (e) {
          console.warn('Error processing stake for chart:', e);
        }
      });
      
      const labels = Object.keys(grouped).sort();
      const amounts = labels.map(date => grouped[date]);
      
      if (tokenStakingChart) {
        tokenStakingChart.destroy();
      }
      
      tokenStakingChart = new Chart(ctx, {
        type: 'line',
        data: {
          labels: labels,
          datasets: [{
            label: 'Staked ($ADRIAN)',
            data: amounts,
            borderColor: '#ffc107',
            backgroundColor: 'rgba(255, 193, 7, 0.1)',
            tension: 0.4
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              display: true
            }
          },
          scales: {
            y: {
              beginAtZero: true
            }
          }
        }
      });
    }

    async function loadTopHolders(balances) {
      if (!supabaseClient) return;
      
      try {
        // Convert map to array and sort
        const holdersArray = Array.from(balances.entries())
          .map(([address, balance]) => ({
            address,
            balance: parseFloat(ethers.utils.formatUnits(balance, 18))
          }))
          .filter(h => h.balance > 0)
          .sort((a, b) => b.balance - a.balance)
          .slice(0, 10);
        
        const table = document.getElementById('topHoldersTable');
        if (holdersArray.length === 0) {
          table.innerHTML = '<p class="text-muted">No holders found</p>';
          return;
        }
        
        let html = '<table class="table table-striped"><thead><tr><th>Rank</th><th>Address</th><th>Balance</th></tr></thead><tbody>';
        holdersArray.forEach((holder, index) => {
          html += `<tr>
            <td>${index + 1}</td>
            <td><code>${shortAddress(holder.address)}</code></td>
            <td>${holder.balance.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })} $ADRIAN</td>
          </tr>`;
        });
        html += '</tbody></table>';
        
        table.innerHTML = html;
      } catch (error) {
        console.error('Error loading top holders:', error);
        document.getElementById('topHoldersTable').innerHTML = 
          '<div class="alert alert-danger">Error loading top holders: ' + error.message + '</div>';
      }
    }

    // Raw Activity Variables
    let rawActivityPage = 0;
    let rawActivityHasMore = true;
    let rawActivityFilters = {
      contract: 'all',
      eventType: 'all',
      dateFrom: null,
      dateTo: null,
      address: null
    };
    let rawActivityScrollHandler = null;

    // Load Raw Activity
    async function loadRawActivity(reset = false) {
      if (!supabaseClient) return;
      
      if (reset) {
        rawActivityPage = 0;
        rawActivityHasMore = true;
        document.getElementById('rawActivityList').innerHTML = '<div class="loading-spinner"><div class="spinner-border" role="status"></div></div>';
      }
      
      if (!rawActivityHasMore) return;
      
      document.getElementById('rawActivityLoading').style.display = 'block';
      
      try {
        const pageSize = 50;
        const allEvents = [];
        
        // Load FloorEngine events
        if (rawActivityFilters.contract === 'all' || rawActivityFilters.contract === 'floorengine') {
          // Listing events
          if (rawActivityFilters.eventType === 'all' || rawActivityFilters.eventType === 'Listed' || rawActivityFilters.eventType === 'Cancelled') {
            let query = supabaseClient
              .from('listing_events')
              .select('*')
              .order('created_at', { ascending: false })
              .range(rawActivityPage * pageSize, (rawActivityPage + 1) * pageSize - 1);
            
            if (rawActivityFilters.eventType !== 'all') {
              query = query.eq('event_type', rawActivityFilters.eventType);
            }
            if (rawActivityFilters.dateFrom) {
              query = query.gte('created_at', rawActivityFilters.dateFrom + 'T00:00:00Z');
            }
            if (rawActivityFilters.dateTo) {
              query = query.lte('created_at', rawActivityFilters.dateTo + 'T23:59:59Z');
            }
            if (rawActivityFilters.address) {
              query = query.or(`seller.ilike.%${rawActivityFilters.address}%`);
            }
            
            const { data: listings } = await query;
            if (listings) {
              listings.forEach(event => {
                allEvents.push({
                  type: 'FloorEngine',
                  eventType: event.event_type,
                  data: event,
                  timestamp: event.created_at
                });
              });
            }
          }
          
          // Trade events
          if (rawActivityFilters.eventType === 'all' || rawActivityFilters.eventType === 'Bought') {
            let query = supabaseClient
              .from('trade_events')
              .select('*')
              .order('created_at', { ascending: false })
              .range(rawActivityPage * pageSize, (rawActivityPage + 1) * pageSize - 1);
            
            if (rawActivityFilters.dateFrom) {
              query = query.gte('created_at', rawActivityFilters.dateFrom + 'T00:00:00Z');
            }
            if (rawActivityFilters.dateTo) {
              query = query.lte('created_at', rawActivityFilters.dateTo + 'T23:59:59Z');
            }
            if (rawActivityFilters.address) {
              query = query.or(`buyer.ilike.%${rawActivityFilters.address}%,seller.ilike.%${rawActivityFilters.address}%`);
            }
            
            const { data: trades } = await query;
            if (trades) {
              trades.forEach(event => {
                allEvents.push({
                  type: 'FloorEngine',
                  eventType: 'Bought',
                  data: event,
                  timestamp: event.created_at
                });
              });
            }
          }
          
          // Sweep events
          if (rawActivityFilters.eventType === 'all' || rawActivityFilters.eventType === 'FloorSweep') {
            let query = supabaseClient
              .from('sweep_events')
              .select('*')
              .order('created_at', { ascending: false })
              .range(rawActivityPage * pageSize, (rawActivityPage + 1) * pageSize - 1);
            
            if (rawActivityFilters.dateFrom) {
              query = query.gte('created_at', rawActivityFilters.dateFrom + 'T00:00:00Z');
            }
            if (rawActivityFilters.dateTo) {
              query = query.lte('created_at', rawActivityFilters.dateTo + 'T23:59:59Z');
            }
            if (rawActivityFilters.address) {
              query = query.ilike('caller', `%${rawActivityFilters.address}%`);
            }
            
            const { data: sweeps } = await query;
            if (sweeps) {
              sweeps.forEach(event => {
                allEvents.push({
                  type: 'FloorEngine',
                  eventType: 'FloorSweep',
                  data: event,
                  timestamp: event.created_at
                });
              });
            }
          }
          
          // Config events
          if (rawActivityFilters.eventType === 'all' || rawActivityFilters.eventType === 'PremiumUpdated' || rawActivityFilters.eventType === 'MaxBuyPriceUpdated') {
            let query = supabaseClient
              .from('engine_config_events')
              .select('*')
              .order('created_at', { ascending: false })
              .range(rawActivityPage * pageSize, (rawActivityPage + 1) * pageSize - 1);
            
            if (rawActivityFilters.eventType !== 'all') {
              query = query.eq('event_name', rawActivityFilters.eventType);
            }
            if (rawActivityFilters.dateFrom) {
              query = query.gte('created_at', rawActivityFilters.dateFrom + 'T00:00:00Z');
            }
            if (rawActivityFilters.dateTo) {
              query = query.lte('created_at', rawActivityFilters.dateTo + 'T23:59:59Z');
            }
            
            const { data: configs } = await query;
            if (configs) {
              configs.forEach(event => {
                allEvents.push({
                  type: 'FloorEngine',
                  eventType: event.event_name,
                  data: event,
                  timestamp: event.created_at
                });
              });
            }
          }
        }
        
        // Load ERC20 events
        if (rawActivityFilters.contract === 'all' || rawActivityFilters.contract === 'erc20') {
          // Transfers
          if (rawActivityFilters.eventType === 'all' || rawActivityFilters.eventType === 'Transfer') {
            let query = supabaseClient
              .from('erc20_transfers')
              .select('*')
              .eq('contract_address', ERC20_ADDRESS)
              .order('created_at', { ascending: false })
              .range(rawActivityPage * pageSize, (rawActivityPage + 1) * pageSize - 1);
            
            if (rawActivityFilters.dateFrom) {
              query = query.gte('created_at', rawActivityFilters.dateFrom + 'T00:00:00Z');
            }
            if (rawActivityFilters.dateTo) {
              query = query.lte('created_at', rawActivityFilters.dateTo + 'T23:59:59Z');
            }
            if (rawActivityFilters.address) {
              query = query.or(`from_address.ilike.%${rawActivityFilters.address}%,to_address.ilike.%${rawActivityFilters.address}%`);
            }
            
            const { data: transfers } = await query;
            if (transfers) {
              transfers.forEach(event => {
                allEvents.push({
                  type: 'ERC20',
                  eventType: 'Transfer',
                  data: event,
                  timestamp: event.created_at
                });
              });
            }
          }
          
          // Approvals
          if (rawActivityFilters.eventType === 'all' || rawActivityFilters.eventType === 'Approval') {
            let query = supabaseClient
              .from('erc20_approvals')
              .select('*')
              .eq('contract_address', ERC20_ADDRESS)
              .order('created_at', { ascending: false })
              .range(rawActivityPage * pageSize, (rawActivityPage + 1) * pageSize - 1);
            
            if (rawActivityFilters.dateFrom) {
              query = query.gte('created_at', rawActivityFilters.dateFrom + 'T00:00:00Z');
            }
            if (rawActivityFilters.dateTo) {
              query = query.lte('created_at', rawActivityFilters.dateTo + 'T23:59:59Z');
            }
            if (rawActivityFilters.address) {
              query = query.or(`owner.ilike.%${rawActivityFilters.address}%,spender.ilike.%${rawActivityFilters.address}%`);
            }
            
            const { data: approvals } = await query;
            if (approvals) {
              approvals.forEach(event => {
                allEvents.push({
                  type: 'ERC20',
                  eventType: 'Approval',
                  data: event,
                  timestamp: event.created_at
                });
              });
            }
          }
          
          // Custom events
          const customEventTypes = ['Staked', 'WithdrawnStake', 'TaxFeeUpdated', 'CreatorFeeUpdated', 'BurnFeeUpdated'];
          if (rawActivityFilters.eventType === 'all' || customEventTypes.includes(rawActivityFilters.eventType)) {
            let query = supabaseClient
              .from('erc20_custom_events')
              .select('*')
              .eq('contract_address', ERC20_ADDRESS)
              .order('created_at', { ascending: false })
              .range(rawActivityPage * pageSize, (rawActivityPage + 1) * pageSize - 1);
            
            if (rawActivityFilters.eventType !== 'all') {
              query = query.eq('event_name', rawActivityFilters.eventType);
            }
            if (rawActivityFilters.dateFrom) {
              query = query.gte('created_at', rawActivityFilters.dateFrom + 'T00:00:00Z');
            }
            if (rawActivityFilters.dateTo) {
              query = query.lte('created_at', rawActivityFilters.dateTo + 'T23:59:59Z');
            }
            
            const { data: customs } = await query;
            if (customs) {
              customs.forEach(event => {
                allEvents.push({
                  type: 'ERC20',
                  eventType: event.event_name,
                  data: event,
                  timestamp: event.created_at
                });
              });
            }
          }
        }
        
        // Load AdrianLABCore events
        if (rawActivityFilters.contract === 'all' || rawActivityFilters.contract === 'adrianlabcore') {
          // ERC721 Transfers
          if (rawActivityFilters.eventType === 'all' || rawActivityFilters.eventType === 'Transfer') {
            let query = supabaseClient
              .from('erc721_transfers')
              .select('*')
              .eq('contract_address', ADRIANLABCORE_ADDRESS)
              .order('created_at', { ascending: false })
              .range(rawActivityPage * pageSize, (rawActivityPage + 1) * pageSize - 1);
            
            if (rawActivityFilters.dateFrom) {
              query = query.gte('created_at', rawActivityFilters.dateFrom + 'T00:00:00Z');
            }
            if (rawActivityFilters.dateTo) {
              query = query.lte('created_at', rawActivityFilters.dateTo + 'T23:59:59Z');
            }
            if (rawActivityFilters.address) {
              query = query.or(`from_address.ilike.%${rawActivityFilters.address}%,to_address.ilike.%${rawActivityFilters.address}%`);
            }
            
            const { data: transfers } = await query;
            if (transfers) {
              transfers.forEach(event => {
                allEvents.push({
                  type: 'AdrianLABCore',
                  eventType: 'Transfer',
                  data: event,
                  timestamp: event.created_at
                });
              });
            }
          }
          
          // ERC721 Approvals
          if (rawActivityFilters.eventType === 'all' || rawActivityFilters.eventType === 'Approval') {
            let query = supabaseClient
              .from('erc721_approvals')
              .select('*')
              .eq('contract_address', ADRIANLABCORE_ADDRESS)
              .order('created_at', { ascending: false })
              .range(rawActivityPage * pageSize, (rawActivityPage + 1) * pageSize - 1);
            
            if (rawActivityFilters.dateFrom) {
              query = query.gte('created_at', rawActivityFilters.dateFrom + 'T00:00:00Z');
            }
            if (rawActivityFilters.dateTo) {
              query = query.lte('created_at', rawActivityFilters.dateTo + 'T23:59:59Z');
            }
            if (rawActivityFilters.address) {
              query = query.or(`owner.ilike.%${rawActivityFilters.address}%,approved.ilike.%${rawActivityFilters.address}%`);
            }
            
            const { data: approvals } = await query;
            if (approvals) {
              approvals.forEach(event => {
                allEvents.push({
                  type: 'AdrianLABCore',
                  eventType: 'Approval',
                  data: event,
                  timestamp: event.created_at
                });
              });
            }
          }
          
          // Custom events
          const customEventTypes = ['TokenMinted', 'TokenBurnt', 'SkinAssigned', 'SkinCreated', 'MutationAssigned', 
                                   'MutationNameAssigned', 'SerumApplied', 'SpecialSkinApplied'];
          if (rawActivityFilters.eventType === 'all' || customEventTypes.includes(rawActivityFilters.eventType)) {
            let query = supabaseClient
              .from('erc721_custom_events')
              .select('*')
              .eq('contract_address', ADRIANLABCORE_ADDRESS)
              .order('created_at', { ascending: false })
              .range(rawActivityPage * pageSize, (rawActivityPage + 1) * pageSize - 1);
            
            if (rawActivityFilters.eventType !== 'all') {
              query = query.eq('event_name', rawActivityFilters.eventType);
            }
            if (rawActivityFilters.dateFrom) {
              query = query.gte('created_at', rawActivityFilters.dateFrom + 'T00:00:00Z');
            }
            if (rawActivityFilters.dateTo) {
              query = query.lte('created_at', rawActivityFilters.dateTo + 'T23:59:59Z');
            }
            
            const { data: customs } = await query;
            if (customs) {
              customs.forEach(event => {
                allEvents.push({
                  type: 'AdrianLABCore',
                  eventType: event.event_name,
                  data: event,
                  timestamp: event.created_at
                });
              });
            }
          }
        }
        
        // Load TraitsCore events
        if (rawActivityFilters.contract === 'all' || rawActivityFilters.contract === 'traitscore') {
          // TransferSingle events
          if (rawActivityFilters.eventType === 'all' || rawActivityFilters.eventType === 'TransferSingle') {
            let query = supabaseClient
              .from('erc1155_transfers_single')
              .select('*')
              .eq('contract_address', TRAITS_CORE_ADDRESS)
              .order('created_at', { ascending: false })
              .range(rawActivityPage * pageSize, (rawActivityPage + 1) * pageSize - 1);
            
            if (rawActivityFilters.dateFrom) {
              query = query.gte('created_at', rawActivityFilters.dateFrom + 'T00:00:00Z');
            }
            if (rawActivityFilters.dateTo) {
              query = query.lte('created_at', rawActivityFilters.dateTo + 'T23:59:59Z');
            }
            if (rawActivityFilters.address) {
              query = query.or(`from_address.ilike.%${rawActivityFilters.address}%,to_address.ilike.%${rawActivityFilters.address}%,operator.ilike.%${rawActivityFilters.address}%`);
            }
            
            const { data: transfersSingle } = await query;
            if (transfersSingle) {
              transfersSingle.forEach(event => {
                allEvents.push({
                  type: 'TraitsCore',
                  eventType: 'TransferSingle',
                  data: event,
                  timestamp: event.created_at
                });
              });
            }
          }
          
          // TransferBatch events
          if (rawActivityFilters.eventType === 'all' || rawActivityFilters.eventType === 'TransferBatch') {
            let query = supabaseClient
              .from('erc1155_transfers_batch')
              .select('*')
              .eq('contract_address', TRAITS_CORE_ADDRESS)
              .order('created_at', { ascending: false })
              .range(rawActivityPage * pageSize, (rawActivityPage + 1) * pageSize - 1);
            
            if (rawActivityFilters.dateFrom) {
              query = query.gte('created_at', rawActivityFilters.dateFrom + 'T00:00:00Z');
            }
            if (rawActivityFilters.dateTo) {
              query = query.lte('created_at', rawActivityFilters.dateTo + 'T23:59:59Z');
            }
            if (rawActivityFilters.address) {
              query = query.or(`from_address.ilike.%${rawActivityFilters.address}%,to_address.ilike.%${rawActivityFilters.address}%,operator.ilike.%${rawActivityFilters.address}%`);
            }
            
            const { data: transfersBatch } = await query;
            if (transfersBatch) {
              transfersBatch.forEach(event => {
                allEvents.push({
                  type: 'TraitsCore',
                  eventType: 'TransferBatch',
                  data: event,
                  timestamp: event.created_at
                });
              });
            }
          }
          
          // Custom events
          const tcCustomEventTypes = ['AssetRegistered', 'AssetMinted', 'AssetBurned', 'CategoryAdded', 'ExtensionAdded'];
          if (rawActivityFilters.eventType === 'all' || tcCustomEventTypes.includes(rawActivityFilters.eventType)) {
            let query = supabaseClient
              .from('erc1155_custom_events')
              .select('*')
              .eq('contract_address', TRAITS_CORE_ADDRESS)
              .order('created_at', { ascending: false })
              .range(rawActivityPage * pageSize, (rawActivityPage + 1) * pageSize - 1);
            
            if (rawActivityFilters.eventType !== 'all') {
              query = query.eq('event_name', rawActivityFilters.eventType);
            }
            if (rawActivityFilters.dateFrom) {
              query = query.gte('created_at', rawActivityFilters.dateFrom + 'T00:00:00Z');
            }
            if (rawActivityFilters.dateTo) {
              query = query.lte('created_at', rawActivityFilters.dateTo + 'T23:59:59Z');
            }
            
            const { data: tcCustoms } = await query;
            if (tcCustoms) {
              tcCustoms.forEach(event => {
                allEvents.push({
                  type: 'TraitsCore',
                  eventType: event.event_name,
                  data: event,
                  timestamp: event.created_at
                });
              });
            }
          }
        }
        
        // Load TraitsExtensions events
        if (rawActivityFilters.contract === 'all' || rawActivityFilters.contract === 'traitsextensions') {
          const teEventTypes = ['TraitEquipped', 'TraitUnequipped', 'TraitApplied', 'TraitsAppliedBatch', 
                                'AssetAddedToInventory', 'AssetRemovedFromInventory'];
          if (rawActivityFilters.eventType === 'all' || teEventTypes.includes(rawActivityFilters.eventType)) {
            let query = supabaseClient
              .from('traits_extensions_events')
              .select('*')
              .eq('contract_address', TRAITS_EXTENSIONS_ADDRESS)
              .order('created_at', { ascending: false })
              .range(rawActivityPage * pageSize, (rawActivityPage + 1) * pageSize - 1);
            
            if (rawActivityFilters.eventType !== 'all') {
              query = query.eq('event_name', rawActivityFilters.eventType);
            }
            if (rawActivityFilters.dateFrom) {
              query = query.gte('created_at', rawActivityFilters.dateFrom + 'T00:00:00Z');
            }
            if (rawActivityFilters.dateTo) {
              query = query.lte('created_at', rawActivityFilters.dateTo + 'T23:59:59Z');
            }
            
            const { data: teEvents } = await query;
            if (teEvents) {
              teEvents.forEach(event => {
                allEvents.push({
                  type: 'TraitsExtensions',
                  eventType: event.event_name,
                  data: event,
                  timestamp: event.created_at
                });
              });
            }
          }
        }
        
        // Load AdrianShop events
        if (rawActivityFilters.contract === 'all' || rawActivityFilters.contract === 'shop') {
          const shopEventTypes = ['ItemPurchased', 'BatchPurchase', 'FreeItemClaimed', 'ShopItemConfigured', 
                                  'ShopItemStatusChanged', 'ShopItemPriceChanged', 'AllowlistConfigured'];
          if (rawActivityFilters.eventType === 'all' || shopEventTypes.includes(rawActivityFilters.eventType)) {
            let query = supabaseClient
              .from('shop_events')
              .select('*')
              .eq('contract_address', ADRIAN_SHOP_ADDRESS)
              .order('created_at', { ascending: false })
              .range(rawActivityPage * pageSize, (rawActivityPage + 1) * pageSize - 1);
            
            if (rawActivityFilters.eventType !== 'all') {
              query = query.eq('event_name', rawActivityFilters.eventType);
            }
            if (rawActivityFilters.dateFrom) {
              query = query.gte('created_at', rawActivityFilters.dateFrom + 'T00:00:00Z');
            }
            if (rawActivityFilters.dateTo) {
              query = query.lte('created_at', rawActivityFilters.dateTo + 'T23:59:59Z');
            }
            const { data: shopEvents } = await query;
            if (shopEvents) {
              shopEvents.forEach(event => {
                // Filter by buyer/user if address filter is set
                if (rawActivityFilters.address) {
                  const buyer = event.event_data?.buyer?.toLowerCase();
                  const user = event.event_data?.user?.toLowerCase();
                  const addr = rawActivityFilters.address.toLowerCase();
                  if (!buyer?.includes(addr) && !user?.includes(addr)) {
                    return; // Skip this event
                  }
                }
                
                allEvents.push({
                  type: 'AdrianShop',
                  eventType: event.event_name,
                  data: event,
                  timestamp: event.created_at
                });
              });
            }
          }
        }
        
        // Sort by timestamp (most recent first)
        allEvents.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
        
        // Render events
        if (reset) {
          document.getElementById('rawActivityList').innerHTML = '';
        }
        
        renderRawActivityEvents(allEvents);
        
        // Check if there's more data
        if (allEvents.length < pageSize) {
          rawActivityHasMore = false;
        } else {
          rawActivityPage++;
        }
        
      } catch (error) {
        console.error('Error loading raw activity:', error);
        document.getElementById('rawActivityList').innerHTML = 
          '<div class="alert alert-danger">Error loading activity: ' + error.message + '</div>';
      } finally {
        document.getElementById('rawActivityLoading').style.display = 'none';
      }
    }

    function renderRawActivityEvents(events) {
      const container = document.getElementById('rawActivityList');
      
      events.forEach(event => {
        const item = createRawActivityItem(event);
        container.appendChild(item);
      });
    }

    function createRawActivityItem(event) {
      const div = document.createElement('div');
      div.className = 'activity-item';
      
      let badgeColor = 'bg-secondary';
      let badgeText = event.type;
      if (event.type === 'FloorEngine') {
        badgeColor = 'bg-primary';
        badgeText = 'FloorEngine';
      } else if (event.type === 'ERC20') {
        badgeColor = 'bg-success';
        badgeText = '$ADRIAN';
      } else if (event.type === 'AdrianLABCore') {
        badgeColor = 'bg-purple';
        badgeText = 'AdrianZERO';
      } else if (event.type === 'TraitsCore') {
        badgeColor = 'bg-info';
        badgeText = 'TraitsCore';
      } else if (event.type === 'TraitsExtensions') {
        badgeColor = 'bg-warning';
        badgeText = 'TraitsExt';
      } else if (event.type === 'AdrianShop') {
        badgeColor = 'bg-danger';
        badgeText = 'Shop';
      }
      
      const date = new Date(event.timestamp);
      const dateStr = date.toLocaleString('es-ES', { 
        year: 'numeric', 
        month: 'short', 
        day: 'numeric', 
        hour: '2-digit', 
        minute: '2-digit' 
      });
      
      let details = '';
      let txHash = '';
      
      if (event.type === 'FloorEngine') {
        if (event.eventType === 'Listed' || event.eventType === 'Cancelled') {
          details = `Token #${event.data.token_id} - ${event.eventType} by ${shortAddress(event.data.seller)}`;
          if (event.data.price_wei) {
            details += ` - Price: ${formatADRIAN(event.data.price_wei)} $ADRIAN`;
          }
          txHash = event.data.tx_hash;
        } else if (event.eventType === 'Bought') {
          details = `Token #${event.data.token_id} - Bought by ${shortAddress(event.data.buyer)} from ${shortAddress(event.data.seller)}`;
          if (event.data.price_wei) {
            details += ` - Price: ${formatADRIAN(event.data.price_wei)} $ADRIAN`;
          }
          txHash = event.data.tx_hash;
        } else if (event.eventType === 'FloorSweep') {
          details = `Token #${event.data.token_id} - Sweep by ${shortAddress(event.data.caller)}`;
          if (event.data.buy_price_wei) {
            details += ` - Buy: ${formatADRIAN(event.data.buy_price_wei)} $ADRIAN`;
          }
          if (event.data.caller_reward_wei) {
            details += ` - Reward: ${formatADRIAN(event.data.caller_reward_wei)} $ADRIAN`;
          }
          txHash = event.data.tx_hash;
        } else {
          details = `${event.eventType}`;
          if (event.data.event_data) {
            details += ` - ${JSON.stringify(event.data.event_data)}`;
          }
          txHash = event.data.tx_hash;
        }
      } else if (event.type === 'ERC20') {
        if (event.eventType === 'Transfer') {
          const from = shortAddress(event.data.from_address);
          const to = shortAddress(event.data.to_address);
          const fromTag = getAddressTagBadge(event.data.from_address);
          const toTag = getAddressTagBadge(event.data.to_address);
          details = `Transfer from ${from}${fromTag} to ${to}${toTag}`;
          if (event.data.value_wei) {
            details += ` - Amount: ${formatADRIAN(event.data.value_wei)} $ADRIAN`;
          }
          txHash = event.data.tx_hash;
        } else if (event.eventType === 'Approval') {
          const owner = shortAddress(event.data.owner);
          const spender = shortAddress(event.data.spender);
          const ownerTag = getAddressTagBadge(event.data.owner);
          const spenderTag = getAddressTagBadge(event.data.spender);
          details = `Approval by ${owner}${ownerTag} to ${spender}${spenderTag}`;
          if (event.data.value_wei) {
            details += ` - Amount: ${formatADRIAN(event.data.value_wei)} $ADRIAN`;
          }
          txHash = event.data.tx_hash;
        } else {
          details = `${event.eventType}`;
          if (event.data.event_data) {
            const eventData = event.data.event_data;
            if (eventData.staker) details += ` - Staker: ${shortAddress(eventData.staker)}`;
            if (eventData.amount) details += ` - Amount: ${formatADRIAN(eventData.amount)} $ADRIAN`;
            if (eventData.reward) details += ` - Reward: ${formatADRIAN(eventData.reward)} $ADRIAN`;
            if (eventData.newTaxFee) details += ` - Tax Fee: ${eventData.newTaxFee} bps`;
            if (eventData.newCreatorFee) details += ` - Creator Fee: ${eventData.newCreatorFee} bps`;
            if (eventData.newBurnFee) details += ` - Burn Fee: ${eventData.newBurnFee} bps`;
          }
          txHash = event.data.tx_hash;
        }
      } else if (event.type === 'AdrianLABCore') {
        if (event.eventType === 'Transfer') {
          details = `Token #${event.data.token_id} - Transfer from ${shortAddress(event.data.from_address)} to ${shortAddress(event.data.to_address)}`;
          txHash = event.data.tx_hash;
        } else if (event.eventType === 'Approval') {
          details = `Token #${event.data.token_id} - Approval by ${shortAddress(event.data.owner)} to ${shortAddress(event.data.approved)}`;
          txHash = event.data.tx_hash;
        } else if (event.eventType === 'TokenMinted') {
          const tokenId = event.data.event_data?.tokenId || 'N/A';
          const to = event.data.event_data?.to || 'N/A';
          details = `Token #${tokenId} - Minted to ${shortAddress(to)}`;
          txHash = event.data.tx_hash;
        } else if (event.eventType === 'TokenBurnt') {
          const tokenId = event.data.event_data?.tokenId || 'N/A';
          const burner = event.data.event_data?.burner || 'N/A';
          details = `Token #${tokenId} - Burnt by ${shortAddress(burner)}`;
          txHash = event.data.tx_hash;
        } else if (event.eventType === 'SkinAssigned') {
          const tokenId = event.data.event_data?.tokenId || 'N/A';
          const skinName = event.data.event_data?.name || 'Unknown';
          details = `Token #${tokenId} - Skin "${skinName}" assigned`;
          txHash = event.data.tx_hash;
        } else if (event.eventType === 'SkinCreated') {
          const skinId = event.data.event_data?.skinId || 'N/A';
          const skinName = event.data.event_data?.name || 'Unknown';
          const rarity = event.data.event_data?.rarity || 'N/A';
          details = `Skin #${skinId} "${skinName}" created - Rarity: ${rarity}`;
          txHash = event.data.tx_hash;
        } else if (event.eventType === 'MutationNameAssigned') {
          const tokenId = event.data.event_data?.tokenId || 'N/A';
          const mutation = event.data.event_data?.newMutation || 'Unknown';
          details = `Token #${tokenId} - Mutation "${mutation}" assigned`;
          txHash = event.data.tx_hash;
        } else if (event.eventType === 'SerumApplied') {
          const tokenId = event.data.event_data?.tokenId || 'N/A';
          const serumId = event.data.event_data?.serumId || 'N/A';
          details = `Token #${tokenId} - Serum #${serumId} applied`;
          txHash = event.data.tx_hash;
        } else if (event.eventType === 'SpecialSkinApplied') {
          const tokenId = event.data.event_data?.tokenId || 'N/A';
          const skinId = event.data.event_data?.skinId || 'N/A';
          const mutation = event.data.event_data?.mutation || 'Unknown';
          details = `Token #${tokenId} - Special skin #${skinId} applied (${mutation})`;
          txHash = event.data.tx_hash;
        } else {
          details = `${event.eventType}`;
          if (event.data.event_data) {
            details += ` - ${JSON.stringify(event.data.event_data)}`;
          }
          txHash = event.data.tx_hash;
        }
      } else if (event.type === 'TraitsCore') {
        if (event.eventType === 'TransferSingle') {
          const from = shortAddress(event.data.from_address);
          const to = shortAddress(event.data.to_address);
          const tokenId = event.data.token_id;
          const value = event.data.value;
          details = `Transfer from ${from} to ${to} - Asset #${tokenId} (${value})`;
          txHash = event.data.tx_hash;
        } else if (event.eventType === 'TransferBatch') {
          const from = shortAddress(event.data.from_address);
          const to = shortAddress(event.data.to_address);
          const tokenIds = event.data.token_ids || [];
          const values = event.data.values || [];
          details = `Batch Transfer from ${from} to ${to} - ${tokenIds.length} assets`;
          txHash = event.data.tx_hash;
        } else if (event.eventType === 'AssetRegistered') {
          const assetId = event.data.event_data?.assetId || 'N/A';
          const category = event.data.event_data?.category || 'Unknown';
          details = `Asset #${assetId} registered - Category: ${category}`;
          txHash = event.data.tx_hash;
        } else if (event.eventType === 'AssetMinted') {
          const assetId = event.data.event_data?.assetId || 'N/A';
          const to = event.data.event_data?.to || 'N/A';
          const amount = event.data.event_data?.amount || '0';
          details = `Asset #${assetId} minted to ${shortAddress(to)} - Amount: ${amount}`;
          txHash = event.data.tx_hash;
        } else if (event.eventType === 'AssetBurned') {
          const assetId = event.data.event_data?.assetId || 'N/A';
          const from = event.data.event_data?.from || 'N/A';
          const amount = event.data.event_data?.amount || '0';
          details = `Asset #${assetId} burned from ${shortAddress(from)} - Amount: ${amount}`;
          txHash = event.data.tx_hash;
        } else if (event.eventType === 'CategoryAdded') {
          const category = event.data.event_data?.category || 'Unknown';
          details = `Category "${category}" added`;
          txHash = event.data.tx_hash;
        } else if (event.eventType === 'ExtensionAdded') {
          const extension = event.data.event_data?.extension || 'N/A';
          details = `Extension ${shortAddress(extension)} authorized`;
          txHash = event.data.tx_hash;
        } else {
          details = `${event.eventType}`;
          if (event.data.event_data) {
            details += ` - ${JSON.stringify(event.data.event_data)}`;
          }
          txHash = event.data.tx_hash;
        }
      } else if (event.type === 'TraitsExtensions') {
        const tokenId = event.data.event_data?.tokenId || 'N/A';
        
        if (event.eventType === 'TraitEquipped') {
          const traitId = event.data.event_data?.traitId || 'N/A';
          const category = event.data.event_data?.category || 'Unknown';
          details = `Token #${tokenId} - Trait #${traitId} equipped (${category})`;
          txHash = event.data.tx_hash;
        } else if (event.eventType === 'TraitUnequipped') {
          const category = event.data.event_data?.category || 'Unknown';
          details = `Token #${tokenId} - Trait unequipped (${category})`;
          txHash = event.data.tx_hash;
        } else if (event.eventType === 'TraitApplied') {
          const traitId = event.data.event_data?.traitId || 'N/A';
          const category = event.data.event_data?.category || 'Unknown';
          details = `Token #${tokenId} - Trait #${traitId} applied permanently (${category})`;
          txHash = event.data.tx_hash;
        } else if (event.eventType === 'TraitsAppliedBatch') {
          const traitIds = event.data.event_data?.traitIds || [];
          const categories = event.data.event_data?.categories || [];
          details = `Token #${tokenId} - ${traitIds.length} traits applied in batch`;
          txHash = event.data.tx_hash;
        } else if (event.eventType === 'AssetAddedToInventory') {
          const assetId = event.data.event_data?.assetId || 'N/A';
          const amount = event.data.event_data?.amount || '0';
          details = `Token #${tokenId} - Asset #${assetId} added to inventory (${amount})`;
          txHash = event.data.tx_hash;
        } else if (event.eventType === 'AssetRemovedFromInventory') {
          const assetId = event.data.event_data?.assetId || 'N/A';
          const amount = event.data.event_data?.amount || '0';
          details = `Token #${tokenId} - Asset #${assetId} removed from inventory (${amount})`;
          txHash = event.data.tx_hash;
        } else {
          details = `Token #${tokenId} - ${event.eventType}`;
          txHash = event.data.tx_hash;
        }
      } else if (event.type === 'AdrianShop') {
        if (event.eventType === 'ItemPurchased') {
          const buyer = event.data.event_data?.buyer || 'N/A';
          const assetId = event.data.event_data?.assetId || 'N/A';
          const quantity = event.data.event_data?.quantity || '0';
          const totalCost = event.data.event_data?.totalCost || '0';
          details = `${shortAddress(buyer)} purchased Asset #${assetId} (${quantity}x)`;
          if (totalCost !== '0') {
            details += ` - Cost: ${formatADRIAN(totalCost)} $ADRIAN`;
          }
          txHash = event.data.tx_hash;
        } else if (event.eventType === 'BatchPurchase') {
          const buyer = event.data.event_data?.buyer || 'N/A';
          const assetIds = event.data.event_data?.assetIds || [];
          const totalCost = event.data.event_data?.totalCost || '0';
          details = `${shortAddress(buyer)} batch purchased ${assetIds.length} items`;
          if (totalCost !== '0') {
            details += ` - Cost: ${formatADRIAN(totalCost)} $ADRIAN`;
          }
          txHash = event.data.tx_hash;
        } else if (event.eventType === 'FreeItemClaimed') {
          const user = event.data.event_data?.user || 'N/A';
          const assetId = event.data.event_data?.assetId || 'N/A';
          const quantity = event.data.event_data?.quantity || '0';
          details = `${shortAddress(user)} claimed free Asset #${assetId} (${quantity}x)`;
          txHash = event.data.tx_hash;
        } else if (event.eventType === 'ShopItemConfigured') {
          const assetId = event.data.event_data?.assetId || 'N/A';
          const price = event.data.event_data?.price || '0';
          details = `Asset #${assetId} configured - Price: ${formatADRIAN(price)} $ADRIAN`;
          txHash = event.data.tx_hash;
        } else if (event.eventType === 'ShopItemStatusChanged') {
          const assetId = event.data.event_data?.assetId || 'N/A';
          const isActive = event.data.event_data?.isActive;
          details = `Asset #${assetId} status changed to ${isActive ? 'active' : 'inactive'}`;
          txHash = event.data.tx_hash;
        } else if (event.eventType === 'ShopItemPriceChanged') {
          const assetId = event.data.event_data?.assetId || 'N/A';
          const newPrice = event.data.event_data?.newPrice || '0';
          details = `Asset #${assetId} price updated to ${formatADRIAN(newPrice)} $ADRIAN`;
          txHash = event.data.tx_hash;
        } else if (event.eventType === 'AllowlistConfigured') {
          const assetId = event.data.event_data?.assetId || 'N/A';
          details = `Allowlist configured for Asset #${assetId}`;
          txHash = event.data.tx_hash;
        } else {
          details = `${event.eventType}`;
          if (event.data.event_data) {
            details += ` - ${JSON.stringify(event.data.event_data)}`;
          }
          txHash = event.data.tx_hash;
        }
      }
      
      // Get image for this event
      const image = getEventImage(event);
      
      div.innerHTML = `
        <div class="activity-header">
          <div>
            <span class="badge ${badgeColor} activity-badge">${badgeText}</span>
            <span class="badge bg-secondary activity-badge ms-2">${event.eventType}</span>
          </div>
          <div class="activity-date">${dateStr}</div>
        </div>
        <div class="activity-details">
          ${image}
          <span>${details}</span>
        </div>
        ${txHash ? `<div class="mt-2"><a href="https://basescan.org/tx/${txHash}" target="_blank" class="activity-link">View on Basescan <i class="bi bi-box-arrow-up-right"></i></a></div>` : ''}
      `;
      
      return div;
    }

    function applyRawActivityFilters() {
      rawActivityFilters.contract = document.getElementById('filterContract').value;
      rawActivityFilters.eventType = document.getElementById('filterEventType').value;
      rawActivityFilters.dateFrom = document.getElementById('filterDateFrom').value || null;
      rawActivityFilters.dateTo = document.getElementById('filterDateTo').value || null;
      rawActivityFilters.address = document.getElementById('filterAddress').value.trim() || null;
      
      loadRawActivity(true);
    }

    function clearRawActivityFilters() {
      document.getElementById('filterContract').value = 'all';
      document.getElementById('filterEventType').value = 'all';
      document.getElementById('filterDateFrom').value = '';
      document.getElementById('filterDateTo').value = '';
      document.getElementById('filterAddress').value = '';
      
      rawActivityFilters = {
        contract: 'all',
        eventType: 'all',
        dateFrom: null,
        dateTo: null,
        address: null
      };
      
      loadRawActivity(true);
    }

    function setupRawActivityScroll() {
      const list = document.getElementById('rawActivityList');
      if (!list) return;
      
      rawActivityScrollHandler = () => {
        const scrollTop = list.scrollTop;
        const scrollHeight = list.scrollHeight;
        const clientHeight = list.clientHeight;
        
        if (scrollTop + clientHeight >= scrollHeight - 100) {
          if (rawActivityHasMore) {
            loadRawActivity(false);
          }
        }
      };
      
      list.addEventListener('scroll', rawActivityScrollHandler);
    }

    // Function to update quick stats in sidebar
    async function updateQuickStats() {
      if (!supabaseClient) return;
      
      try {
        // Get total supply from ERC20 contract
        const ethers5 = window.ethers5Backup || window.ethers;
        if (ethers5) {
          try {
            let readProvider;
            if (window.ethereum) {
              readProvider = new ethers5.providers.Web3Provider(window.ethereum);
            } else {
              readProvider = new ethers5.providers.JsonRpcProvider('https://mainnet.base.org');
            }
            const tokenABI = ["function totalSupply() view returns (uint256)"];
            const tokenContract = new ethers5.Contract(ERC20_ADDRESS, tokenABI, readProvider);
            const totalSupplyWei = await tokenContract.totalSupply();
            const supplyFormatted = parseFloat(ethers5.utils.formatUnits(totalSupplyWei, 18));
            
            const totalSupplyEl = document.getElementById('quickTotalSupply');
            if (totalSupplyEl) {
              totalSupplyEl.textContent = supplyFormatted >= 1000000 
                ? (supplyFormatted / 1000000).toFixed(1) + 'M'
                : supplyFormatted >= 1000 
                ? (supplyFormatted / 1000).toFixed(1) + 'K'
                : supplyFormatted.toFixed(1);
            }
          } catch (error) {
            console.warn('Error reading totalSupply:', error);
          }
        }
        
        // Get total transactions from erc20_transfers
        const { count: txCount } = await supabaseClient
          .from('erc20_transfers')
          .select('*', { count: 'exact', head: true })
          .eq('contract_address', ERC20_ADDRESS);
        
        const totalTransactionsEl = document.getElementById('quickTotalTransactions');
        if (totalTransactionsEl && txCount !== null) {
          totalTransactionsEl.textContent = txCount.toLocaleString();
        }
        
        // Get total volume
        const { data: transfers } = await supabaseClient
          .from('erc20_transfers')
          .select('value_wei')
          .eq('contract_address', ERC20_ADDRESS);
        
        if (transfers && transfers.length > 0 && window.ethers) {
          let totalWei = ethers.BigNumber.from(0);
          transfers.forEach(transfer => {
            if (transfer.value_wei) {
              try {
                const valueStr = String(transfer.value_wei).includes('e') 
                  ? parseFloat(transfer.value_wei).toFixed(0)
                  : transfer.value_wei;
                totalWei = totalWei.add(ethers.BigNumber.from(valueStr));
              } catch (e) {
                console.warn('Error processing transfer value:', e);
              }
            }
          });
          const totalVolume = parseFloat(ethers.utils.formatUnits(totalWei, 18));
          
          const totalVolumeEl = document.getElementById('quickTotalVolume');
          if (totalVolumeEl) {
            totalVolumeEl.textContent = totalVolume >= 1000000 
              ? (totalVolume / 1000000).toFixed(1) + 'M $ADRIAN'
              : totalVolume >= 1000 
              ? (totalVolume / 1000).toFixed(1) + 'K $ADRIAN'
              : totalVolume.toFixed(2) + ' $ADRIAN';
          }
        }
        
        // Get total holders (unique addresses from erc20_transfers)
        const { data: holdersData } = await supabaseClient
          .from('erc20_transfers')
          .select('from_address, to_address')
          .eq('contract_address', ERC20_ADDRESS);
        
        if (holdersData) {
          const uniqueHolders = new Set();
          holdersData.forEach(transfer => {
            if (transfer.from_address && transfer.from_address !== BURN_ADDRESS) {
              uniqueHolders.add(transfer.from_address.toLowerCase());
            }
            if (transfer.to_address && transfer.to_address !== BURN_ADDRESS) {
              uniqueHolders.add(transfer.to_address.toLowerCase());
            }
          });
          
          const totalHoldersEl = document.getElementById('quickTotalHolders');
          if (totalHoldersEl) {
            totalHoldersEl.textContent = uniqueHolders.size.toLocaleString();
          }
        }
      } catch (error) {
        console.error('Error updating quick stats:', error);
      }
    }

    // Initialize on page load
    document.addEventListener('DOMContentLoaded', async () => {
      initSupabase();
      
      // Load rules first (images and tags)
      await loadRules();
      
      if (supabaseClient) {
        // Load quick stats in sidebar
        updateQuickStats();
        
        // Load stats for expanded panels
        await Promise.all([
          loadFloorEngineStats(),
          loadTokenStats()
        ]);
        
        // Load raw activity when panel is shown
        const rawActivityPanel = document.getElementById('rawActivityPanel');
        if (rawActivityPanel) {
          rawActivityPanel.addEventListener('shown.bs.collapse', () => {
            if (document.getElementById('rawActivityList').children.length === 0 || 
                document.getElementById('rawActivityList').querySelector('.loading-spinner')) {
              loadRawActivity(true);
              setupRawActivityScroll();
            }
          });
        }
        
        // Load stats when panels are expanded (lazy loading)
        const panels = {
          'adrianlabcorePanel': loadAdrianLABCoreStats,
          'traitscorePanel': loadTraitsCoreStats,
          'traitsextensionsPanel': loadTraitsExtensionsStats,
          'shopPanel': loadAdrianShopStats
        };
        
        Object.keys(panels).forEach(panelId => {
          const panel = document.getElementById(panelId);
          if (panel) {
            panel.addEventListener('shown.bs.collapse', () => {
              if (!window[panelId + 'Loaded']) {
                panels[panelId]();
                window[panelId + 'Loaded'] = true;
              }
              // Update charts when panel is shown (Chart.js needs visible canvas)
              setTimeout(() => {
                const charts = {
                  'adrianlabcorePanel': [alcMintingChart, alcSkinChart, alcMutationChart, alcTransferChart],
                  'traitscorePanel': [tcMintingChart, tcAssetChart],
                  'traitsextensionsPanel': [teActivityChart, teEventChart],
                  'shopPanel': [shopRevenueChart, shopPurchaseTypeChart]
                };
                if (charts[panelId]) {
                  charts[panelId].forEach(chart => {
                    if (chart) {
                      chart.resize();
                    }
                  });
                }
              }, 100);
            });
          }
        });
        
        // Update charts when FloorEngine and Token panels are shown
        const floorEnginePanel = document.getElementById('floorEnginePanel');
        if (floorEnginePanel) {
          floorEnginePanel.addEventListener('shown.bs.collapse', () => {
            setTimeout(() => {
              if (feVolumeChart) feVolumeChart.resize();
              if (feActivityChart) feActivityChart.resize();
            }, 100);
          });
        }
        
        const tokenStatsPanel = document.getElementById('tokenStatsPanel');
        if (tokenStatsPanel) {
          tokenStatsPanel.addEventListener('shown.bs.collapse', () => {
            setTimeout(() => {
              if (tokenVolumeChart) tokenVolumeChart.resize();
              if (tokenTransactionsChart) tokenTransactionsChart.resize();
              if (tokenSupplyChart) tokenSupplyChart.resize();
              if (tokenStakingChart) tokenStakingChart.resize();
            }, 100);
          });
        }
      } else {
        console.error('Supabase not initialized');
        document.body.innerHTML = '<div class="container mt-5"><div class="alert alert-danger">Error: Supabase credentials not configured</div></div>';
      }
    });
  </script>
</body>
</html>

