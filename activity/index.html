<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>$ADRIAN Ecosystem Activity</title>
  <link rel="icon" type="image/x-icon" href="../favicon.ico">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css">
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/5.7.2/ethers.umd.min.js"></script>
  <script src="./supabase-config.js"></script>
  <style>
    :root {
      --bg-color: #ffffff;
      --text-color: #333333;
      --card-bg: #ffffff;
      --border-color: #dee2e6;
    }

    [data-theme="dark"] {
      --bg-color: #1a1a1a;
      --text-color: #ffffff;
      --card-bg: #2d2d2d;
      --border-color: #404040;
    }

    .bg-purple {
      background-color: #9c27b0 !important;
    }

    body {
      background-color: var(--bg-color);
      color: var(--text-color);
      margin: 0;
      padding: 0;
    }

    #menu-container {
      margin: 0;
      padding: 0;
    }

    #menu-container .navbar {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      width: 100%;
      z-index: 1000;
    }

    .main-container {
      min-height: 100vh;
    }

    /* Contenedor de lista de actividades - completamente plano, sin anidados */
    .activity-list-container {
      width: 100%;
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    /* Cada evento es completamente independiente - sin anidamiento */
    .activity-item {
      border: 1px solid var(--border-color);
      border-radius: 8px;
      padding: 1rem;
      background-color: var(--card-bg);
      /* Cada evento es un contenedor independiente */
      display: block;
      width: 100%;
      box-sizing: border-box;
      margin: 0;
      /* Sin dependencias de contenedores padre */
      position: relative;
      transition: transform 0.2s;
    }

    .activity-item:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 8px rgba(0,0,0,0.1);
    }

    .activity-item:hover .nft-thumbnail {
      border-color: #007bff;
    }

    .activity-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 0.5rem;
      flex-wrap: wrap;
      gap: 0.5rem;
    }

    .activity-badge {
      font-size: 0.75rem;
      padding: 0.25rem 0.5rem;
    }

    .activity-date {
      font-size: 0.85rem;
      color: #6c757d;
    }

    .activity-details {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      flex-wrap: wrap;
    }

    .nft-thumbnail {
      width: 80px;
      height: 80px;
      object-fit: cover;
      border-radius: 4px;
      border: 2px solid var(--border-color);
      background: var(--card-bg);
      flex-shrink: 0;
      transition: border-color 0.2s;
    }

    .activity-link {
      font-size: 0.85rem;
      text-decoration: none;
    }

    /* Ajustar tipograf√≠a para que coincida con market */
    .activity-item .card-title {
      font-size: 1rem;
      font-weight: 600;
      margin-bottom: 0.25rem;
    }

    .load-more-container {
      text-align: center;
      padding: 2rem 1rem;
    }

    .loading-spinner {
      text-align: center;
      padding: 2rem;
    }

    /* Simple Tabs (sin Bootstrap) */
    .tabs-container {
      display: flex;
      gap: 0.5rem;
      margin-bottom: 1rem;
    }

    .tab-button {
      padding: 0.75rem 1.5rem;
      border: none;
      background: transparent;
      color: var(--text-color);
      cursor: pointer;
      border-bottom: 3px solid transparent;
      transition: all 0.2s;
      font-size: 1rem;
      opacity: 0.6;
    }

    .tab-button:hover {
      opacity: 0.8;
    }

    .tab-button.active {
      opacity: 1;
      border-bottom-color: #007bff;
      font-weight: 600;
    }

    .tab-content {
      display: none;
    }

    .tab-content.active {
      display: block;
    }

    /* Filters Panel Collapsible */
    #filtersBody {
      display: block;
      transition: max-height 0.3s ease-out, opacity 0.3s ease-out, padding 0.3s ease-out;
      overflow: hidden;
    }

    #filtersBody.collapsed {
      max-height: 0;
      opacity: 0;
      padding-top: 0 !important;
      padding-bottom: 0 !important;
    }

    #filtersToggleIcon {
      transition: transform 0.3s ease;
    }

    #filtersToggleIcon.rotated {
      transform: rotate(180deg);
    }

    /* Statistics Styles */
    .period-btn.active {
      background-color: #007bff !important;
      color: white !important;
      border-color: #007bff !important;
    }

    .period-btn {
      transition: all 0.2s;
    }

    .period-btn:hover {
      background-color: rgba(0, 123, 255, 0.1);
    }

    #statistics-charts-container canvas {
      max-height: 400px;
    }

    #statistics-top10-container .table {
      margin-bottom: 0;
    }

    #statistics-top10-container .table thead th {
      border-bottom: 2px solid var(--border-color);
      font-weight: 600;
      font-size: 0.85rem;
    }

    #statistics-top10-container .table tbody tr:hover {
      background-color: rgba(0, 123, 255, 0.05);
    }

    #statistics-top10-container code {
      background-color: rgba(0, 0, 0, 0.05);
      padding: 2px 4px;
      border-radius: 3px;
      font-family: 'Courier New', monospace;
    }

    [data-theme="dark"] #statistics-top10-container code {
      background-color: rgba(255, 255, 255, 0.1);
    }

    @media (max-width: 768px) {
      .activity-item {
        padding: 0.75rem;
      }
      
      .activity-header {
        font-size: 0.9rem;
      }
      
      .activity-details {
        font-size: 0.85rem;
      }
      
      .nft-thumbnail {
        width: 60px;
        height: 60px;
      }

      /* En m√≥viles, el panel de filtros est√° colapsado por defecto */
      #filtersBody:not(.show) {
        max-height: 0;
        opacity: 0;
        padding-top: 0 !important;
        padding-bottom: 0 !important;
      }

      #filtersBody.show {
        max-height: 2000px;
        opacity: 1;
      }

      #filtersToggleIcon {
        transform: rotate(180deg);
      }

      #filtersToggleIcon.rotated {
        transform: rotate(0deg);
      }
    }
  </style>
</head>
<body>
  <!-- Menu -->
  <div id="menu-container">
    <object data="../market/components/menu.html" type="text/html" style="width: 100%; height: auto;">
      <nav class="navbar navbar-expand-lg bg-light">
    <div class="container-fluid">
          <a class="navbar-brand" href="/">$ADRIAN</a>
    </div>
  </nav>
    </object>
    </div>

  <!-- Main Content -->
  <div class="main-container">
    <div class="container" style="padding-top: 20px; padding-bottom: 20px;">
      <h1 class="mb-4">$ADRIAN Ecosystem Activity</h1>

      <!-- Simple Tabs (sin Bootstrap) -->
      <div class="tabs-container mb-4" style="border-bottom: 2px solid var(--border-color);">
        <button class="tab-button active" onclick="showActivityTab()" id="tab-activity-btn">
          <i class="bi bi-list-ul"></i> Activity
        </button>
        <button class="tab-button" onclick="showStatisticsTab()" id="tab-statistics-btn">
          <i class="bi bi-graph-up"></i> Statistics
        </button>
    </div>

      <!-- Activity Tab Content -->
      <div id="activity-tab-content" class="tab-content active">
        <!-- Filters -->
        <div class="card mb-4">
          <div class="card-header d-flex justify-content-between align-items-center" style="cursor: pointer;" onclick="toggleFilters()">
            <h5 class="mb-0">Filters</h5>
            <i class="bi bi-chevron-down" id="filtersToggleIcon"></i>
          </div>
          <div class="card-body" id="filtersBody">
            <div class="row g-3">
              <div class="col-md-3">
              <label class="form-label">Contract</label>
              <select id="filterContract" class="form-select">
                  <option value="all">All Contracts</option>
                  <option value="floorengine">FloorEngine</option>
                <option value="erc20">ERC20</option>
                <option value="adrianpunks">AdrianPunks</option>
                <option value="adrianlabcore">AdrianZERO</option>
                <option value="erc1155">AdrianLAB</option>
                <option value="traitsextensions">Traits</option>
                <option value="adrianshop">Shop</option>
                <option value="adriannameregistry">AdrianNameRegistry</option>
                <option value="adrianserummodule">AdrianSerumModule</option>
                <option value="punkquest">PunkQuest</option>
                </select>
              </div>
              <div class="col-md-3">
              <label class="form-label">Event Type</label>
              <select id="filterEventType" class="form-select">
                  <option value="all">All Events</option>
                </select>
              </div>
              <div class="col-md-2">
              <label class="form-label">Date From</label>
              <input type="date" id="filterDateFrom" class="form-control">
              </div>
              <div class="col-md-2">
              <label class="form-label">Date To</label>
              <input type="date" id="filterDateTo" class="form-control">
              </div>
              <div class="col-md-2">
              <label class="form-label">Address</label>
              <input type="text" id="filterAddress" class="form-control" placeholder="0x...">
              </div>
            </div>
            <div class="row mt-3">
              <div class="col-12">
              <button class="btn btn-primary" onclick="applyFilters()">Apply Filters</button>
              <button class="btn btn-secondary ms-2" onclick="clearFilters()">Clear</button>
              </div>
            </div>
          </div>
        </div>

        <!-- Activity List - Fuera de contenedores anidados para mejor rendimiento -->
        <div id="activityListContainer" class="activity-list-container">
              <div class="loading-spinner">
                <div class="spinner-border" role="status">
                  <span class="visually-hidden">Loading...</span>
                </div>
              </div>
            </div>

        <!-- Load More Button -->
        <div id="loadMoreContainer" class="load-more-container" style="display: none;">
          <button class="btn btn-primary btn-lg" onclick="loadMore()">
            <i class="bi bi-arrow-down-circle"></i> Load More
          </button>
              </div>
      </div> <!-- End Activity Tab -->

      <!-- Statistics Tab Content -->
      <div id="statistics-tab-content" class="tab-content">
        <div id="statistics-container">
          <div class="text-center py-5">
              <div class="spinner-border" role="status">
              <span class="visually-hidden">Cargando estad√≠sticas...</span>
              </div>
            </div>
          </div>
      </div> <!-- End Statistics Tab -->
        </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
  <script src="./statistics.js"></script>
  <script>
    // ============================================
    // CONFIGURATION
    // ============================================
    const SUPABASE_URL = window.SUPABASE_URL || 'YOUR_SUPABASE_URL';
    const SUPABASE_ANON_KEY = window.SUPABASE_ANON_KEY || 'YOUR_SUPABASE_ANON_KEY';

    const PAGE_SIZE = 10; // Items por p√°gina
    const MAX_ITEMS_IN_DOM = 50; // M√°ximo de items en el DOM
    const LOAD_IMAGES = true; // Activar carga de im√°genes
    const MAX_CONCURRENT_SVG = 5; // M√°ximo de im√°genes SVG cargando simult√°neamente (controlado para m√≥viles)
    const IMAGE_LOAD_TIMEOUT = 5000; // Timeout de 5 segundos para im√°genes
    let activeSVGLoads = 0; // Contador de im√°genes SVG cargando
    let svgLoadQueue = []; // Cola de im√°genes SVG pendientes de cargar
    
    // Cach√© de im√°genes ya cargadas (reutilizaci√≥n)
    const imageCache = new Map(); // tokenId -> HTML string de la imagen
    const loadedImagesCache = new Map(); // tokenId -> elemento img ya cargado (para clonar)
    
    // Detectar si es m√≥vil y desactivar SVG
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth <= 768;
    
    // Polyfill para requestIdleCallback (no disponible en Safari/iOS)
    if (!window.requestIdleCallback) {
      window.requestIdleCallback = function(callback, options) {
        const timeout = options?.timeout || 0;
        const start = Date.now();
        return setTimeout(function() {
          callback({
            didTimeout: timeout > 0 && (Date.now() - start) >= timeout,
            timeRemaining: function() {
              return Math.max(0, 50 - (Date.now() - start));
            }
          });
        }, 1);
      };
    }
    
    if (!window.cancelIdleCallback) {
      window.cancelIdleCallback = function(id) {
        clearTimeout(id);
      };
    }
    
    // Contract addresses
    const FLOOR_ENGINE_ADDRESS = '0x0351F7cBA83277E891D4a85Da498A7eACD764D58';
    const ERC20_ADDRESS = '0x7E99075Ce287F1cF8cBCAaa6A1C7894e404fD7Ea';
    const BURN_ADDRESS = '0x0000000000000000000000000000000000000000';
    const ADRIANLABCORE_ADDRESS = '0x6e369bf0e4e0c106192d606fb6d85836d684da75';
    const ADRIANPUNKS_ADDRESS = '0x79be8acdd339c7b92918fcc3fd3875b5aaad7566';
    const ERC1155_ADDRESS = '0x90546848474fb3c9fda3fdad887969bb244e7e58';
    const TRAITS_EXTENSIONS_ADDRESS = '0x0995c0dA1ca071b792E852b6Ec531b7cD7d1F8D6';
    const ADRIAN_SHOP_ADDRESS = '0x4b265927b1521995ce416bba3bed98231d2e946b';
    const ADRIAN_NAME_REGISTRY_ADDRESS = '0xaeC5ED33c88c1943BB7452aC4B571ad0b4c4068C';
    const ADRIAN_SERUM_MODULE_ADDRESS = '0x0000000000000000000000000000000000000000'; // Placeholder
    const PUNK_QUEST_ADDRESS = '0xaf22843e195b792a3f874562ab7cee751066665e';

    // ============================================
    // STATE
    // ============================================
    let supabaseClient = null;
    let currentPage = 0;
    let hasMore = true;
    let isLoading = false;
    let allLoadedEvents = []; // Todos los eventos cargados
    let displayedEvents = []; // Eventos mostrados actualmente
    let renderedEventsCount = 0; // Contador de eventos ya renderizados (para optimizaci√≥n)
    let addressTagsRules = {};
    let imageRules = {};
    let eventRules = {};
    let intersectionObserver = null;

    // Filters
    const filters = {
      contract: 'all',
      eventType: 'all',
      dateFrom: null,
      dateTo: null,
      address: null
    };

    // ============================================
    // INITIALIZATION
    // ============================================
    async function init() {
      console.log('üöÄ Inicializando aplicaci√≥n...');
      
      // Inicializar Supabase
      if (SUPABASE_URL && SUPABASE_ANON_KEY && SUPABASE_URL !== 'YOUR_SUPABASE_URL') {
        supabaseClient = supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
        console.log('‚úÖ Supabase inicializado');
      } else {
        console.error('‚ùå Credenciales de Supabase no configuradas');
        showError('Error: Credenciales de Supabase no configuradas');
        return;
      }

      // Cargar reglas
      await loadRules();

      // Configurar Intersection Observer para scroll infinito
      setupIntersectionObserver();

      // Cargar primera p√°gina
      await loadFirstPage();
    }

    // ============================================
    // RULES LOADING
    // ============================================
    async function loadRules() {
      try {
        // Address tags
        const tagsResponse = await fetch('./rules/address-tags.json');
        if (tagsResponse.ok) {
          const data = await tagsResponse.json();
          addressTagsRules = data.addressTags || {};
        }

        // Image rules
        const imagesResponse = await fetch('./rules/image-rules.json');
        if (imagesResponse.ok) {
          const data = await imagesResponse.json();
          imageRules = data.imageRules || {};
        }

        // Event rules
        const eventsResponse = await fetch('./rules/event-rules.json');
        if (eventsResponse.ok) {
          const data = await eventsResponse.json();
          eventRules = data.eventRules || {};
        }
      } catch (error) {
        console.error('Error cargando reglas:', error);
      }
    }

    // ============================================
    // DATA LOADING
    // ============================================
    async function loadFirstPage() {
      if (isLoading) return;
      
      currentPage = 0;
      hasMore = true;
      allLoadedEvents = [];
      displayedEvents = [];
      renderedEventsCount = 0; // Resetear contador al limpiar filtros
      
      showLoading();
      await loadMore();
    }

    async function loadMore() {
      if (isLoading || !hasMore) {
        console.log('‚è∏Ô∏è Load More: isLoading=', isLoading, 'hasMore=', hasMore);
        return;
      }
      
      console.log('üì• Load More: Cargando p√°gina', currentPage + 1);
      isLoading = true;
      updateLoadMoreButton();

      try {
        const pageSize = PAGE_SIZE;
        const offset = currentPage * pageSize;
        console.log(`üìä Fetching events: offset=${offset}, limit=${pageSize}`);
        
        const newEvents = await fetchEvents(offset, pageSize);
        console.log(`‚úÖ Fetched ${newEvents.length} eventos`);
        
        if (newEvents.length === 0) {
          console.log('‚ö†Ô∏è No hay m√°s eventos');
          hasMore = false;
        } else {
          allLoadedEvents = allLoadedEvents.concat(newEvents);
          currentPage++;
          console.log(`üì¶ Total eventos cargados: ${allLoadedEvents.length}, p√°gina actual: ${currentPage}`);
          
          // Aplicar filtros y renderizar
          applyFiltersAndRender();
        }
      } catch (error) {
        console.error('‚ùå Error cargando eventos:', error);
        showError('Error cargando eventos: ' + error.message);
      } finally {
        isLoading = false;
        hideLoading();
        updateLoadMoreButton();
        console.log('‚úÖ Load More completado');
      }
    }

    // Helper function para normalizar timestamps (usar block_timestamp si existe)
    function getEventTimestamp(event) {
      // Prioridad: block_timestamp > timestamp > created_at > updated_at
      return event.block_timestamp || event.timestamp || event.created_at || event.updated_at;
    }

    async function fetchEvents(offset, limit) {
      const events = [];
      
      // Para paginaci√≥n correcta con m√∫ltiples tablas, necesitamos:
      // 1. Cargar m√°s eventos de cada tabla (limit * 2 para asegurar suficientes)
      // 2. Combinar todos
      // 3. Ordenar por timestamp
      // 4. Tomar slice(offset, offset + limit)
      const fetchLimit = limit * 2;
      
      // OPTIMIZACI√ìN: Agrupar queries para ejecutarlas en paralelo
      const queries = [];
      
      // FloorEngine events
      if (filters.contract === 'all' || filters.contract === 'floorengine') {
        // Active listings from punk_listings (estado actual)
        // IMPORTANTE: punk_listings.updated_at es la fecha de actualizaci√≥n en BD, no el timestamp del bloque
        // Necesitamos buscar en listing_events el evento "Listed" correspondiente para obtener el timestamp real
        if (filters.eventType === 'all' || filters.eventType === 'Listed') {
          let listingsQuery = supabaseClient
            .from('punk_listings')
            .select('*')
            .eq('is_listed', true)
            .order('updated_at', { ascending: false })
            .limit(fetchLimit);
          
          if (filters.dateFrom) {
            listingsQuery = listingsQuery.gte('updated_at', filters.dateFrom + 'T00:00:00Z');
          }
          if (filters.dateTo) {
            listingsQuery = listingsQuery.lte('updated_at', filters.dateTo + 'T23:59:59Z');
          }
          if (filters.address) {
            listingsQuery = listingsQuery.ilike('seller', `%${filters.address}%`);
          }
          
          // Variable para almacenar listings que necesitan lookup de timestamp
          const listingsNeedingTimestamp = [];
          
          queries.push({ 
            query: listingsQuery, 
            handler: (listingsData) => {
              if (listingsData) {
                listingsData.forEach(listing => {
                  // Guardar para lookup posterior
                  listingsNeedingTimestamp.push({
                    listing: listing,
                    eventIndex: events.length
                  });
                  
                  // Agregar evento con timestamp temporal
                  events.push({
                    type: 'FloorEngine',
                    eventType: listing.last_event || 'Listed',
                    data: {
                      token_id: listing.token_id,
                      seller: listing.seller,
                      price_wei: listing.price_wei,
                      is_contract_owned: listing.is_contract_owned,
                      is_listed: listing.is_listed,
                      last_event: listing.last_event,
                      last_tx_hash: listing.last_tx_hash,
                      last_block_number: listing.last_block_number,
                      created_at: listing.updated_at,
                      tx_hash: listing.last_tx_hash
                    },
                    timestamp: listing.updated_at // Temporal, se actualizar√° despu√©s
                  });
                });
              }
            }
          });
          
          // Query adicional para obtener timestamps reales de listing_events y sweep_events
          if (filters.eventType === 'all' || filters.eventType === 'Listed') {
            // Query para eventos Listed
            let listedEventsQuery = supabaseClient
              .from('listing_events')
              .select('tx_hash, created_at, block_timestamp, timestamp')
              .eq('event_type', 'Listed')
              .order('created_at', { ascending: false })
              .limit(fetchLimit * 2); // M√°s eventos para asegurar cobertura
            
            if (filters.dateFrom) {
              listedEventsQuery = listedEventsQuery.gte('created_at', filters.dateFrom + 'T00:00:00Z');
            }
            if (filters.dateTo) {
              listedEventsQuery = listedEventsQuery.lte('created_at', filters.dateTo + 'T23:59:59Z');
            }
            
            queries.push({ 
              query: listedEventsQuery, 
              handler: (listedEventsData) => {
                if (listedEventsData) {
                  // Crear mapa de timestamps reales
                  const timestampMap = new Map();
                  listedEventsData.forEach(event => {
                    const realTimestamp = getEventTimestamp(event);
                    timestampMap.set(event.tx_hash, realTimestamp);
                  });
                  
                  // Almacenar el mapa para uso posterior
                  window._listingTimestampMap = timestampMap;
                }
              }
            });
            
            // Query para eventos FloorSweep
            let sweepEventsQuery = supabaseClient
              .from('sweep_events')
              .select('tx_hash, created_at, block_timestamp, timestamp')
              .order('created_at', { ascending: false })
              .limit(fetchLimit * 2);
            
            if (filters.dateFrom) {
              sweepEventsQuery = sweepEventsQuery.gte('created_at', filters.dateFrom + 'T00:00:00Z');
            }
            if (filters.dateTo) {
              sweepEventsQuery = sweepEventsQuery.lte('created_at', filters.dateTo + 'T23:59:59Z');
            }
            
            queries.push({ 
              query: sweepEventsQuery, 
              handler: (sweepEventsData) => {
                if (sweepEventsData) {
                  // Crear/actualizar mapa de timestamps reales
                  if (!window._sweepTimestampMap) {
                    window._sweepTimestampMap = new Map();
                  }
                  sweepEventsData.forEach(event => {
                    const realTimestamp = getEventTimestamp(event);
                    window._sweepTimestampMap.set(event.tx_hash, realTimestamp);
                  });
                }
              }
            });
          }
        }
        
        // Listing events hist√≥ricos (para eventos Cancelled)
        if (filters.eventType === 'all' || filters.eventType === 'Cancelled') {
          let query = supabaseClient
            .from('listing_events')
            .select('*')
            .eq('event_type', 'Cancelled')
            .order('created_at', { ascending: false })
            .limit(fetchLimit);
          
          if (filters.dateFrom) {
            query = query.gte('created_at', filters.dateFrom + 'T00:00:00Z');
          }
          if (filters.dateTo) {
            query = query.lte('created_at', filters.dateTo + 'T23:59:59Z');
          }
          
          queries.push({ query, handler: (data) => {
            if (data) {
              data.forEach(event => {
                events.push({
                  type: 'FloorEngine',
                  eventType: event.event_type,
                  data: event,
                  timestamp: getEventTimestamp(event)
                });
              });
            }
          }});
        }
          
          // Trade events
        let tradeQuery = supabaseClient
              .from('trade_events')
              .select('*')
              .order('created_at', { ascending: false })
          .limit(fetchLimit);
        
        if (filters.dateFrom) {
          tradeQuery = tradeQuery.gte('created_at', filters.dateFrom + 'T00:00:00Z');
        }
        if (filters.dateTo) {
          tradeQuery = tradeQuery.lte('created_at', filters.dateTo + 'T23:59:59Z');
        }
        
        queries.push({ query: tradeQuery, handler: (data) => {
          if (data) {
            data.forEach(event => {
              events.push({
                type: 'FloorEngine',
                eventType: 'Bought',
                data: event,
                timestamp: getEventTimestamp(event)
              });
            });
          }
        }});
          
        // Sweep events
        let sweepQuery = supabaseClient
              .from('sweep_events')
              .select('*')
              .order('created_at', { ascending: false })
          .limit(fetchLimit);
        
        if (filters.dateFrom) {
          sweepQuery = sweepQuery.gte('created_at', filters.dateFrom + 'T00:00:00Z');
        }
        if (filters.dateTo) {
          sweepQuery = sweepQuery.lte('created_at', filters.dateTo + 'T23:59:59Z');
        }
        
        queries.push({ query: sweepQuery, handler: (data) => {
          if (data) {
            data.forEach(event => {
              events.push({
                type: 'FloorEngine',
                eventType: 'FloorSweep',
                data: event,
                timestamp: getEventTimestamp(event)
              });
            });
          }
        }});
          }
          
      // ERC20 events
      if (filters.contract === 'all' || filters.contract === 'erc20') {
        // Transfers
        if (filters.eventType === 'all' || filters.eventType === 'Transfer') {
          let query = supabaseClient
          .from('erc20_transfers')
            .select('*')
            .eq('contract_address', ERC20_ADDRESS.toLowerCase())
            .order('created_at', { ascending: false })
            .limit(fetchLimit);
          
          if (filters.dateFrom) {
            query = query.gte('created_at', filters.dateFrom + 'T00:00:00Z');
          }
          if (filters.dateTo) {
            query = query.lte('created_at', filters.dateTo + 'T23:59:59Z');
          }
          if (filters.address) {
            query = query.or(`from_address.ilike.%${filters.address}%,to_address.ilike.%${filters.address}%`);
          }
          
          queries.push({ query, handler: (data) => {
            if (data) {
              data.forEach(event => {
              events.push({
                type: 'ERC20',
                eventType: 'Transfer',
                data: event,
                timestamp: event.created_at
              });
            });
          }
          }});
        }

        // Approvals
        if (filters.eventType === 'all' || filters.eventType === 'Approval') {
          let query = supabaseClient
            .from('erc20_approvals')
          .select('*')
            .eq('contract_address', ERC20_ADDRESS.toLowerCase())
            .order('created_at', { ascending: false })
            .limit(fetchLimit);
          
          if (filters.dateFrom) {
            query = query.gte('created_at', filters.dateFrom + 'T00:00:00Z');
          }
          if (filters.dateTo) {
            query = query.lte('created_at', filters.dateTo + 'T23:59:59Z');
          }
          if (filters.address) {
            query = query.or(`owner.ilike.%${filters.address}%,spender.ilike.%${filters.address}%`);
          }
          
          queries.push({ query, handler: (data) => {
            if (data) {
              data.forEach(event => {
              events.push({
                type: 'ERC20',
                eventType: 'Approval',
                data: event,
                timestamp: event.created_at
              });
            });
          }
          }});
        }

        // Custom events
        if (filters.eventType === 'all') {
            let query = supabaseClient
              .from('erc20_custom_events')
          .select('*')
              .eq('contract_address', ERC20_ADDRESS.toLowerCase())
              .order('created_at', { ascending: false })
              .limit(fetchLimit);
          
          if (filters.dateFrom) {
            query = query.gte('created_at', filters.dateFrom + 'T00:00:00Z');
          }
          if (filters.dateTo) {
            query = query.lte('created_at', filters.dateTo + 'T23:59:59Z');
          }
          
          queries.push({ query, handler: (data) => {
            if (data) {
              data.forEach(event => {
              const eventType = event.event_name || event.event_type || 'Unknown';
              events.push({
                type: 'ERC20',
                eventType: eventType,
                data: event,
                timestamp: event.created_at
              });
            });
          }
          }});
        } else {
          const customEventTypes = ['Staked', 'WithdrawnStake', 'TaxFeeUpdated', 'CreatorFeeUpdated', 'BurnFeeUpdated'];
          if (customEventTypes.includes(filters.eventType)) {
            let query = supabaseClient
          .from('erc20_custom_events')
              .select('*')
              .eq('contract_address', ERC20_ADDRESS.toLowerCase())
              .eq('event_name', filters.eventType)
              .order('created_at', { ascending: false })
              .range(offset, offset + limit - 1);
            
            if (filters.dateFrom) {
              query = query.gte('created_at', filters.dateFrom + 'T00:00:00Z');
            }
            if (filters.dateTo) {
              query = query.lte('created_at', filters.dateTo + 'T23:59:59Z');
            }
            
            queries.push({ query, handler: (data) => {
              if (data) {
                data.forEach(event => {
                events.push({
                  type: 'ERC20',
                  eventType: event.event_name,
                  data: event,
                  timestamp: event.created_at
                });
              });
            }
            }});
          }
        }
      }

      // AdrianLABCore (ERC721) events
      if (filters.contract === 'all' || filters.contract === 'adrianlabcore') {
        // Transfers
        if (filters.eventType === 'all' || filters.eventType === 'Transfer') {
          let query = supabaseClient
            .from('erc721_transfers')
            .select('*')
            .eq('contract_address', ADRIANLABCORE_ADDRESS)
            .order('created_at', { ascending: false })
            .limit(fetchLimit);
          
          if (filters.dateFrom) {
            query = query.gte('created_at', filters.dateFrom + 'T00:00:00Z');
          }
          if (filters.dateTo) {
            query = query.lte('created_at', filters.dateTo + 'T23:59:59Z');
          }
          if (filters.address) {
            query = query.or(`from_address.ilike.%${filters.address}%,to_address.ilike.%${filters.address}%`);
          }
          
          const { data: transfers } = await query;
          if (transfers) {
            transfers.forEach(event => {
              events.push({
                type: 'AdrianLABCore',
                eventType: 'Transfer',
                data: event,
                timestamp: event.created_at
              });
            });
          }
        }

        // Approvals
        if (filters.eventType === 'all' || filters.eventType === 'Approval') {
          let query = supabaseClient
            .from('erc721_approvals')
            .select('*')
            .eq('contract_address', ADRIANLABCORE_ADDRESS)
            .order('created_at', { ascending: false })
            .limit(fetchLimit);
          
          if (filters.dateFrom) {
            query = query.gte('created_at', filters.dateFrom + 'T00:00:00Z');
          }
          if (filters.dateTo) {
            query = query.lte('created_at', filters.dateTo + 'T23:59:59Z');
          }
          if (filters.address) {
            query = query.or(`owner.ilike.%${filters.address}%,approved.ilike.%${filters.address}%`);
          }
          
          const { data: approvals } = await query;
          if (approvals) {
            approvals.forEach(event => {
              events.push({
                type: 'AdrianLABCore',
                eventType: 'Approval',
                data: event,
                timestamp: event.created_at
              });
            });
          }
        }

        // ApprovalForAll
        if (filters.eventType === 'all' || filters.eventType === 'ApprovalForAll') {
          let query = supabaseClient
            .from('erc721_approvals_for_all')
            .select('*')
            .eq('contract_address', ADRIANLABCORE_ADDRESS)
            .order('created_at', { ascending: false })
            .limit(fetchLimit);
          
          if (filters.dateFrom) {
            query = query.gte('created_at', filters.dateFrom + 'T00:00:00Z');
          }
          if (filters.dateTo) {
            query = query.lte('created_at', filters.dateTo + 'T23:59:59Z');
          }
          if (filters.address) {
            query = query.or(`owner.ilike.%${filters.address}%,operator.ilike.%${filters.address}%`);
          }
          
          const { data: approvalsForAll } = await query;
          if (approvalsForAll) {
            approvalsForAll.forEach(event => {
              events.push({
                type: 'AdrianLABCore',
                eventType: 'ApprovalForAll',
                data: event,
                timestamp: event.created_at
              });
            });
          }
        }

        // Custom events
        if (filters.eventType === 'all') {
          let query = supabaseClient
            .from('erc721_custom_events')
            .select('*')
            .eq('contract_address', ADRIANLABCORE_ADDRESS)
            .order('created_at', { ascending: false })
            .limit(fetchLimit);
          
          if (filters.dateFrom) {
            query = query.gte('created_at', filters.dateFrom + 'T00:00:00Z');
          }
          if (filters.dateTo) {
            query = query.lte('created_at', filters.dateTo + 'T23:59:59Z');
          }
          
          const { data: customs } = await query;
          if (customs) {
            customs.forEach(event => {
              // Usar event_name o event_type con fallback
              const eventType = event.event_name || event.event_type || 'Unknown';
              events.push({
                type: 'AdrianLABCore',
                eventType: eventType,
                data: event,
                timestamp: event.created_at
              });
            });
          }
        } else {
          const customEventTypes = ['TokenMinted', 'TokenBurnt', 'SkinAssigned', 'SkinCreated', 'MutationNameAssigned', 'SerumApplied', 'SpecialSkinApplied'];
          if (customEventTypes.includes(filters.eventType)) {
            let query = supabaseClient
              .from('erc721_custom_events')
              .select('*')
              .eq('contract_address', ADRIANLABCORE_ADDRESS)
              .eq('event_name', filters.eventType)
              .order('created_at', { ascending: false })
              .limit(fetchLimit);
            
            if (filters.dateFrom) {
              query = query.gte('created_at', filters.dateFrom + 'T00:00:00Z');
            }
            if (filters.dateTo) {
              query = query.lte('created_at', filters.dateTo + 'T23:59:59Z');
            }
            
            const { data: customs } = await query;
            if (customs) {
              customs.forEach(event => {
                events.push({
                  type: 'AdrianLABCore',
                  eventType: event.event_name,
                  data: event,
                  timestamp: event.created_at
                });
              });
            }
          }
        }
      }

      // AdrianPunks (ERC721) events
      if (filters.contract === 'all' || filters.contract === 'adrianpunks') {
        // Transfers
        if (filters.eventType === 'all' || filters.eventType === 'Transfer') {
          let query = supabaseClient
            .from('erc721_transfers')
            .select('*')
            .eq('contract_address', ADRIANPUNKS_ADDRESS.toLowerCase())
            .order('created_at', { ascending: false })
            .limit(fetchLimit);
          
          if (filters.dateFrom) {
            query = query.gte('created_at', filters.dateFrom + 'T00:00:00Z');
          }
          if (filters.dateTo) {
            query = query.lte('created_at', filters.dateTo + 'T23:59:59Z');
          }
          if (filters.address) {
            query = query.or(`from_address.ilike.%${filters.address}%,to_address.ilike.%${filters.address}%`);
          }
          
          queries.push({ query, handler: (data) => {
            if (data) {
              data.forEach(event => {
                events.push({
                  type: 'AdrianPunks',
                  eventType: 'Transfer',
                  data: event,
                  timestamp: getEventTimestamp(event)
                });
              });
            }
          }});
        }

        // Approvals
        if (filters.eventType === 'all' || filters.eventType === 'Approval') {
          let query = supabaseClient
            .from('erc721_approvals')
            .select('*')
            .eq('contract_address', ADRIANPUNKS_ADDRESS.toLowerCase())
            .order('created_at', { ascending: false })
            .limit(fetchLimit);
          
          if (filters.dateFrom) {
            query = query.gte('created_at', filters.dateFrom + 'T00:00:00Z');
          }
          if (filters.dateTo) {
            query = query.lte('created_at', filters.dateTo + 'T23:59:59Z');
          }
          if (filters.address) {
            query = query.or(`owner.ilike.%${filters.address}%,approved.ilike.%${filters.address}%`);
          }
          
          queries.push({ query, handler: (data) => {
            if (data) {
              data.forEach(event => {
                events.push({
                  type: 'AdrianPunks',
                  eventType: 'Approval',
                  data: event,
                  timestamp: getEventTimestamp(event)
                });
              });
            }
          }});
        }

        // ApprovalForAll
        if (filters.eventType === 'all' || filters.eventType === 'ApprovalForAll') {
          let query = supabaseClient
            .from('erc721_approvals_for_all')
            .select('*')
            .eq('contract_address', ADRIANPUNKS_ADDRESS.toLowerCase())
            .order('created_at', { ascending: false })
            .limit(fetchLimit);
          
          if (filters.dateFrom) {
            query = query.gte('created_at', filters.dateFrom + 'T00:00:00Z');
          }
          if (filters.dateTo) {
            query = query.lte('created_at', filters.dateTo + 'T23:59:59Z');
          }
          if (filters.address) {
            query = query.or(`owner.ilike.%${filters.address}%,operator.ilike.%${filters.address}%`);
          }
          
          queries.push({ query, handler: (data) => {
            if (data) {
              data.forEach(event => {
                events.push({
                  type: 'AdrianPunks',
                  eventType: 'ApprovalForAll',
                  data: event,
                  timestamp: getEventTimestamp(event)
                });
              });
            }
          }});
        }

        // Custom events
        if (filters.eventType === 'all') {
          let query = supabaseClient
            .from('erc721_custom_events')
            .select('*')
            .eq('contract_address', ADRIANPUNKS_ADDRESS.toLowerCase())
            .order('created_at', { ascending: false })
            .limit(fetchLimit);
          
          if (filters.dateFrom) {
            query = query.gte('created_at', filters.dateFrom + 'T00:00:00Z');
          }
          if (filters.dateTo) {
            query = query.lte('created_at', filters.dateTo + 'T23:59:59Z');
          }
          
          queries.push({ query, handler: (data) => {
            if (data) {
              data.forEach(event => {
                const eventType = event.event_name || event.event_type || 'Unknown';
                events.push({
                  type: 'AdrianPunks',
                  eventType: eventType,
                  data: event,
                  timestamp: getEventTimestamp(event)
                });
              });
            }
          }});
        } else {
          // Si hay un tipo de evento espec√≠fico, buscar en custom_events
          let query = supabaseClient
            .from('erc721_custom_events')
            .select('*')
            .eq('contract_address', ADRIANPUNKS_ADDRESS.toLowerCase())
            .eq('event_name', filters.eventType)
            .order('created_at', { ascending: false })
            .limit(fetchLimit);
          
          if (filters.dateFrom) {
            query = query.gte('created_at', filters.dateFrom + 'T00:00:00Z');
          }
          if (filters.dateTo) {
            query = query.lte('created_at', filters.dateTo + 'T23:59:59Z');
          }
          
          queries.push({ query, handler: (data) => {
            if (data) {
              data.forEach(event => {
                events.push({
                  type: 'AdrianPunks',
                  eventType: event.event_name,
                  data: event,
                  timestamp: event.created_at
                });
              });
            }
          }});
        }
      }

      // ERC1155 (AdrianLAB) events
      if (filters.contract === 'all' || filters.contract === 'erc1155') {
        // TransferSingle
        if (filters.eventType === 'all' || filters.eventType === 'TransferSingle') {
          let query = supabaseClient
            .from('erc1155_transfers_single')
            .select('*')
            .eq('contract_address', ERC1155_ADDRESS)
            .order('created_at', { ascending: false })
            .limit(fetchLimit);
          
          if (filters.dateFrom) {
            query = query.gte('created_at', filters.dateFrom + 'T00:00:00Z');
          }
          if (filters.dateTo) {
            query = query.lte('created_at', filters.dateTo + 'T23:59:59Z');
          }
          if (filters.address) {
            query = query.or(`from_address.ilike.%${filters.address}%,to_address.ilike.%${filters.address}%`);
          }
          
          const { data: transfers } = await query;
          if (transfers) {
            transfers.forEach(event => {
              const tokenIdValue = event.token_id || event.tokenId || null;
              events.push({
                type: 'ERC1155',
                eventType: 'TransferSingle',
                data: { ...event, token_id: tokenIdValue },
                timestamp: event.created_at
              });
            });
          }
        }

        // TransferBatch
        if (filters.eventType === 'all' || filters.eventType === 'TransferBatch') {
          let query = supabaseClient
            .from('erc1155_transfers_batch')
            .select('*')
            .eq('contract_address', ERC1155_ADDRESS)
            .order('created_at', { ascending: false })
            .limit(fetchLimit);
          
          if (filters.dateFrom) {
            query = query.gte('created_at', filters.dateFrom + 'T00:00:00Z');
          }
          if (filters.dateTo) {
            query = query.lte('created_at', filters.dateTo + 'T23:59:59Z');
          }
          if (filters.address) {
            query = query.or(`from_address.ilike.%${filters.address}%,to_address.ilike.%${filters.address}%`);
          }
          
          const { data: batchTransfers } = await query;
          if (batchTransfers) {
            batchTransfers.forEach(event => {
              const tokenIds = event.token_ids || [];
              const firstTokenId = Array.isArray(tokenIds) && tokenIds.length > 0 ? tokenIds[0] : null;
              events.push({
                type: 'ERC1155',
                eventType: 'TransferBatch',
                data: { ...event, token_id: firstTokenId, token_ids: tokenIds },
                timestamp: event.created_at
              });
            });
          }
        }

        // ApprovalForAll
        if (filters.eventType === 'all' || filters.eventType === 'ApprovalForAll') {
          let query = supabaseClient
            .from('erc1155_approvals_for_all')
            .select('*')
            .eq('contract_address', ERC1155_ADDRESS)
            .order('created_at', { ascending: false })
            .limit(fetchLimit);
          
          if (filters.dateFrom) {
            query = query.gte('created_at', filters.dateFrom + 'T00:00:00Z');
          }
          if (filters.dateTo) {
            query = query.lte('created_at', filters.dateTo + 'T23:59:59Z');
          }
          if (filters.address) {
            query = query.or(`owner.ilike.%${filters.address}%,operator.ilike.%${filters.address}%`);
          }
          
          const { data: approvalsForAll } = await query;
          if (approvalsForAll) {
            approvalsForAll.forEach(event => {
              events.push({
                type: 'ERC1155',
                eventType: 'ApprovalForAll',
                data: event,
                timestamp: event.created_at
              });
            });
          }
        }

        // URI Updates
        if (filters.eventType === 'all' || filters.eventType === 'URI') {
          let query = supabaseClient
            .from('erc1155_uri_updates')
            .select('*')
            .eq('contract_address', ERC1155_ADDRESS)
            .order('created_at', { ascending: false })
            .limit(fetchLimit);
          
          if (filters.dateFrom) {
            query = query.gte('created_at', filters.dateFrom + 'T00:00:00Z');
          }
          if (filters.dateTo) {
            query = query.lte('created_at', filters.dateTo + 'T23:59:59Z');
          }
          
          const { data: uriUpdates } = await query;
          if (uriUpdates) {
            uriUpdates.forEach(event => {
              events.push({
                type: 'ERC1155',
                eventType: 'URI',
                data: event,
                timestamp: event.created_at
              });
            });
          }
        }

        // Custom events
        if (filters.eventType === 'all') {
          let query = supabaseClient
            .from('erc1155_custom_events')
            .select('*')
            .eq('contract_address', ERC1155_ADDRESS)
            .order('created_at', { ascending: false })
            .range(offset, offset + limit - 1);
          
          if (filters.dateFrom) {
            query = query.gte('created_at', filters.dateFrom + 'T00:00:00Z');
          }
          if (filters.dateTo) {
            query = query.lte('created_at', filters.dateTo + 'T23:59:59Z');
          }
          
          const { data: customs } = await query;
          if (customs) {
            customs.forEach(event => {
              // Usar event_name o event_type con fallback
              const eventType = event.event_name || event.event_type || 'Unknown';
              events.push({
                type: 'ERC1155',
                eventType: eventType,
                data: event,
                timestamp: event.created_at
              });
            });
          }
        } else {
          const customEventTypes = ['AssetMinted', 'AssetBurned', 'PackOpened', 'SerumUsed'];
          if (customEventTypes.includes(filters.eventType)) {
            let query = supabaseClient
              .from('erc1155_custom_events')
              .select('*')
              .eq('contract_address', ERC1155_ADDRESS)
              .eq('event_name', filters.eventType)
              .order('created_at', { ascending: false })
              .limit(fetchLimit);
            
            if (filters.dateFrom) {
              query = query.gte('created_at', filters.dateFrom + 'T00:00:00Z');
            }
            if (filters.dateTo) {
              query = query.lte('created_at', filters.dateTo + 'T23:59:59Z');
            }
            
            const { data: customs } = await query;
            if (customs) {
              customs.forEach(event => {
                events.push({
                  type: 'ERC1155',
                  eventType: event.event_name,
                  data: event,
                  timestamp: event.created_at
                });
              });
            }
          }
        }
      }

      // TraitsExtensions events
      if (filters.contract === 'all' || filters.contract === 'traitsextensions') {
        if (filters.eventType === 'all') {
            let query = supabaseClient
            .from('traits_extensions_events')
              .select('*')
            .eq('contract_address', TRAITS_EXTENSIONS_ADDRESS.toLowerCase())
              .order('created_at', { ascending: false })
            .limit(fetchLimit);
          
          if (filters.dateFrom) {
            query = query.gte('created_at', filters.dateFrom + 'T00:00:00Z');
          }
          if (filters.dateTo) {
            query = query.lte('created_at', filters.dateTo + 'T23:59:59Z');
          }
          
          const { data: customs } = await query;
          if (customs) {
            customs.forEach(event => {
              // Usar event_name o event_type con fallback
              const eventType = event.event_name || event.event_type || 'Unknown';
              events.push({
                type: 'TraitsExtensions',
                eventType: eventType,
                  data: event,
                  timestamp: event.created_at
                });
              });
            }
        } else {
          const customEventTypes = ['TraitApplied', 'TraitsAppliedBatch', 'AssetAddedToInventory', 'TraitRemoved'];
          if (customEventTypes.includes(filters.eventType)) {
            let query = supabaseClient
              .from('traits_extensions_events')
              .select('*')
              .eq('contract_address', TRAITS_EXTENSIONS_ADDRESS.toLowerCase())
              .eq('event_name', filters.eventType)
              .order('created_at', { ascending: false })
              .limit(fetchLimit);
            
            if (filters.dateFrom) {
              query = query.gte('created_at', filters.dateFrom + 'T00:00:00Z');
            }
            if (filters.dateTo) {
              query = query.lte('created_at', filters.dateTo + 'T23:59:59Z');
            }
            
            const { data: customs } = await query;
            if (customs) {
              customs.forEach(event => {
                // Si event_data es un string JSON, parsearlo
                let eventData = event;
                if (event.event_data && typeof event.event_data === 'string') {
                  try {
                    const parsed = JSON.parse(event.event_data);
                    eventData = { ...event, event_data: parsed };
                  } catch (e) {
                    console.warn('Error parsing event_data JSON:', e);
                  }
                }
                
                // Usar event_name o event_type con fallback
                const eventType = event.event_name || event.event_type || 'Unknown';
                events.push({
                  type: 'TraitsExtensions',
                  eventType: eventType,
                  data: eventData,
                  timestamp: event.created_at
                });
              });
            }
          }
            }
          }
          
      // AdrianShop events
      if (filters.contract === 'all' || filters.contract === 'adrianshop') {
        if (filters.eventType === 'all') {
            let query = supabaseClient
            .from('shop_events')
              .select('*')
            .eq('contract_address', ADRIAN_SHOP_ADDRESS)
              .order('created_at', { ascending: false })
            .limit(fetchLimit);
          
          if (filters.dateFrom) {
            query = query.gte('created_at', filters.dateFrom + 'T00:00:00Z');
          }
          if (filters.dateTo) {
            query = query.lte('created_at', filters.dateTo + 'T23:59:59Z');
          }
          if (filters.address) {
            query = query.ilike('event_data->>buyer', `%${filters.address}%`);
          }
          
          const { data: shopEvents } = await query;
          if (shopEvents) {
            shopEvents.forEach(event => {
              // Usar event_name o event_type con fallback
              const eventType = event.event_name || event.event_type || 'Unknown';
              events.push({
                type: 'AdrianShop',
                eventType: eventType,
                  data: event,
                  timestamp: event.created_at
                });
              });
            }
        } else {
          const customEventTypes = ['ItemPurchased', 'BatchPurchase', 'ItemListed', 'ItemDelisted'];
          if (customEventTypes.includes(filters.eventType)) {
            let query = supabaseClient
              .from('shop_events')
              .select('*')
              .eq('contract_address', ADRIAN_SHOP_ADDRESS)
              .eq('event_name', filters.eventType)
              .order('created_at', { ascending: false })
              .limit(fetchLimit);
            
            if (filters.dateFrom) {
              query = query.gte('created_at', filters.dateFrom + 'T00:00:00Z');
            }
            if (filters.dateTo) {
              query = query.lte('created_at', filters.dateTo + 'T23:59:59Z');
            }
            if (filters.address) {
              query = query.ilike('event_data->>buyer', `%${filters.address}%`);
            }
            
            const { data: shopEvents } = await query;
            if (shopEvents) {
              shopEvents.forEach(event => {
                events.push({
                  type: 'AdrianShop',
                  eventType: event.event_name,
                  data: event,
                  timestamp: event.created_at
                });
              });
            }
          }
        }
      }

      // AdrianNameRegistry events (NUEVO)
      if (filters.contract === 'all' || filters.contract === 'adriannameregistry') {
        if (filters.eventType === 'all') {
            let query = supabaseClient
            .from('name_registry_events')
              .select('*')
            .eq('contract_address', ADRIAN_NAME_REGISTRY_ADDRESS.toLowerCase())
              .order('created_at', { ascending: false })
            .limit(fetchLimit);
          
          if (filters.dateFrom) {
            query = query.gte('created_at', filters.dateFrom + 'T00:00:00Z');
          }
          if (filters.dateTo) {
            query = query.lte('created_at', filters.dateTo + 'T23:59:59Z');
          }
          if (filters.address) {
            query = query.ilike('setter', `%${filters.address}%`);
          }
          
          const { data: nameEvents } = await query;
          if (nameEvents) {
            nameEvents.forEach(event => {
              // Usar event_name o event_type con fallback
              const eventType = event.event_name || event.event_type || 'NameSet';
              events.push({
                type: 'AdrianNameRegistry',
                eventType: eventType,
                  data: event,
                  timestamp: event.created_at
                });
              });
            }
          }
          
        // Config events
        if (filters.eventType === 'all' || filters.eventType === 'PriceUpdated' || filters.eventType === 'TreasuryUpdated') {
            let query = supabaseClient
            .from('name_registry_config_events')
              .select('*')
            .eq('contract_address', ADRIAN_NAME_REGISTRY_ADDRESS.toLowerCase())
              .order('created_at', { ascending: false })
            .limit(fetchLimit);
          
          if (filters.eventType !== 'all') {
            query = query.eq('event_type', filters.eventType);
          }
          if (filters.dateFrom) {
            query = query.gte('created_at', filters.dateFrom + 'T00:00:00Z');
          }
          if (filters.dateTo) {
            query = query.lte('created_at', filters.dateTo + 'T23:59:59Z');
          }
          
          const { data: configEvents } = await query;
          if (configEvents) {
            configEvents.forEach(event => {
              // Usar event_type o event_name con fallback
              const eventType = event.event_type || event.event_name || 'Unknown';
              events.push({
                type: 'AdrianNameRegistry',
                eventType: eventType,
                  data: event,
                  timestamp: event.created_at
                });
              });
          }
        }
      }

      // AdrianSerumModule events (NUEVO)
      if (filters.contract === 'all' || filters.contract === 'adrianserummodule') {
        if (ADRIAN_SERUM_MODULE_ADDRESS !== '0x0000000000000000000000000000000000000000') {
            let query = supabaseClient
            .from('serum_module_events')
              .select('*')
            .eq('contract_address', ADRIAN_SERUM_MODULE_ADDRESS.toLowerCase())
              .order('created_at', { ascending: false })
            .limit(fetchLimit);
          
          if (filters.dateFrom) {
            query = query.gte('created_at', filters.dateFrom + 'T00:00:00Z');
          }
          if (filters.dateTo) {
            query = query.lte('created_at', filters.dateTo + 'T23:59:59Z');
          }
          if (filters.address) {
            query = query.ilike('user_address', `%${filters.address}%`);
          }
          
          const { data: serumEvents } = await query;
          if (serumEvents) {
            serumEvents.forEach(event => {
              // Usar event_name o event_type con fallback
              const eventType = event.event_name || event.event_type || 'SerumApplied';
              events.push({
                type: 'AdrianSerumModule',
                eventType: eventType,
                  data: event,
                  timestamp: event.created_at
                });
              });
            }
          }
        }
        
      // PunkQuest events (NUEVO)
      if (filters.contract === 'all' || filters.contract === 'punkquest') {
        if (PUNK_QUEST_ADDRESS !== '0x0000000000000000000000000000000000000000') {
          // Staking events
            let query = supabaseClient
            .from('punk_quest_staking_events')
              .select('*')
            .eq('contract_address', PUNK_QUEST_ADDRESS.toLowerCase())
              .order('created_at', { ascending: false })
            .limit(fetchLimit);
          
          if (filters.dateFrom) {
            query = query.gte('created_at', filters.dateFrom + 'T00:00:00Z');
          }
          if (filters.dateTo) {
            query = query.lte('created_at', filters.dateTo + 'T23:59:59Z');
          }
          if (filters.address) {
            query = query.ilike('user_address', `%${filters.address}%`);
          }
          
          const { data: stakingEvents } = await query;
          if (stakingEvents) {
            stakingEvents.forEach(event => {
              // La tabla usa event_type, no event_name
              const eventType = event.event_type || event.event_name || 'Staked';
              events.push({
                type: 'PunkQuest',
                eventType: eventType,
                  data: event,
                  timestamp: event.created_at
                });
              });
          }

          // Item events
          query = supabaseClient
            .from('punk_quest_item_events')
              .select('*')
            .eq('contract_address', PUNK_QUEST_ADDRESS.toLowerCase())
              .order('created_at', { ascending: false })
            .limit(fetchLimit);
          
          if (filters.dateFrom) {
            query = query.gte('created_at', filters.dateFrom + 'T00:00:00Z');
          }
          if (filters.dateTo) {
            query = query.lte('created_at', filters.dateTo + 'T23:59:59Z');
          }
          if (filters.address) {
            query = query.ilike('user_address', `%${filters.address}%`);
          }
          
          const { data: itemEvents } = await query;
          if (itemEvents) {
            itemEvents.forEach(event => {
              // La tabla usa event_type, no event_name
              const eventType = event.event_type || event.event_name || 'ItemPurchased';
              events.push({
                type: 'PunkQuest',
                eventType: eventType,
                  data: event,
                  timestamp: event.created_at
                });
              });
          }

          // Event events
          query = supabaseClient
            .from('punk_quest_event_events')
              .select('*')
            .eq('contract_address', PUNK_QUEST_ADDRESS.toLowerCase())
              .order('created_at', { ascending: false })
            .limit(fetchLimit);
          
          if (filters.dateFrom) {
            query = query.gte('created_at', filters.dateFrom + 'T00:00:00Z');
          }
          if (filters.dateTo) {
            query = query.lte('created_at', filters.dateTo + 'T23:59:59Z');
          }
          
          const { data: questEvents } = await query;
          if (questEvents) {
            questEvents.forEach(event => {
              // La tabla usa event_type, no event_name
              const eventType = event.event_type || event.event_name || 'EventStarted';
              events.push({
                type: 'PunkQuest',
                eventType: eventType,
                  data: event,
                  timestamp: event.created_at
                });
              });
            }
          }
        }
      
      // OPTIMIZACI√ìN: Ejecutar todas las queries en paralelo
      if (queries.length > 0) {
        const startTime = performance.now();
        const results = await Promise.all(queries.map(async q => {
          try {
            const response = await q.query;
            return { data: response.data, handler: q.handler };
          } catch (err) {
            console.warn('Error en query:', err);
            return { data: null, handler: q.handler };
          }
        }));
        
        // Procesar resultados
        results.forEach(result => {
          if (result && result.handler) {
            result.handler(result.data);
          }
        });
        
        const endTime = performance.now();
        console.log(`‚ö° ${queries.length} queries ejecutadas en paralelo en ${(endTime - startTime).toFixed(2)}ms`);
        }
        
      // Ordenar por timestamp descendente
      events.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
      
      // Para paginaci√≥n: tomar eventos desde offset hasta offset + limit
      const startIndex = offset;
      const endIndex = offset + limit;
      const paginatedEvents = events.slice(startIndex, endIndex);
      
      console.log(`üìä Total eventos encontrados: ${events.length}, mostrando ${paginatedEvents.length} (√≠ndices ${startIndex}-${endIndex})`);
      
      // Si obtenemos menos eventos de los solicitados, no hay m√°s
      if (paginatedEvents.length < limit) {
        console.log('‚ö†Ô∏è Menos eventos de los solicitados, no hay m√°s p√°ginas');
      }
      
      return paginatedEvents;
    }

    // ============================================
    // FILTERING & RENDERING
    // ============================================
    function applyFiltersAndRender() {
      // Aplicar filtros a allLoadedEvents
      let filtered = [...allLoadedEvents];
      
      // Aplicar filtros de fecha y direcci√≥n si existen
      if (filters.dateFrom) {
        filtered = filtered.filter(e => new Date(e.timestamp) >= new Date(filters.dateFrom + 'T00:00:00Z'));
      }
      if (filters.dateTo) {
        filtered = filtered.filter(e => new Date(e.timestamp) <= new Date(filters.dateTo + 'T23:59:59Z'));
      }
      
      // Deduplicar eventos ERC20 basado en tx_hash y log_index
      const seenEvents = new Map();
      filtered = filtered.filter(e => {
        if (e.type === 'ERC20' && e.data?.tx_hash && e.data?.log_index !== undefined) {
          const key = `${e.data.tx_hash}-${e.data.log_index}`;
          if (seenEvents.has(key)) {
            return false; // Duplicado, remover
          }
          seenEvents.set(key, true);
        }
        return true;
      });
      
      // Aplicar reglas de eventos
      filtered = applyEventFilteringRules(filtered);
      applyContextualTagging(filtered);
      
      // Actualizar displayedEvents
      displayedEvents = filtered;
      
      // Limpiar DOM si hay demasiados items
      cleanupOldItems();
      
      // Renderizar
      renderEvents();
    }

    function renderEvents() {
      const container = document.getElementById('activityListContainer');
      if (!container) return;
      
      // Si no hay eventos, mostrar mensaje
      if (displayedEvents.length === 0) {
        container.innerHTML = '<div class="text-center py-5"><p>No hay eventos para mostrar</p></div>';
        renderedEventsCount = 0;
        return;
      }
      
      // OPTIMIZACI√ìN: Solo renderizar nuevos eventos, no re-renderizar todo
      const newEventsCount = displayedEvents.length - renderedEventsCount;
      
      if (renderedEventsCount === 0) {
        // Primera carga: renderizar todo
        const fragment = document.createDocumentFragment();
        
        displayedEvents.forEach((event) => {
          const item = createEventItem(event);
          fragment.appendChild(item);
        });
        
        container.innerHTML = '';
        container.appendChild(fragment);
        renderedEventsCount = displayedEvents.length;
      } else if (newEventsCount > 0) {
        // Cargas posteriores: solo agregar nuevos eventos
        const fragment = document.createDocumentFragment();
        const newEvents = displayedEvents.slice(renderedEventsCount);
        
        // Remover sentinel anterior si existe
        const oldSentinel = document.getElementById('scrollSentinel');
        if (oldSentinel) {
          oldSentinel.remove();
        }
        
        newEvents.forEach((event) => {
          const item = createEventItem(event);
          fragment.appendChild(item);
        });
        
        container.appendChild(fragment);
        renderedEventsCount = displayedEvents.length;
      }
      
      // Agregar sentinel al final para Intersection Observer
      const sentinel = document.createElement('div');
      sentinel.id = 'scrollSentinel';
      sentinel.style.height = '1px';
      sentinel.style.visibility = 'hidden';
      container.appendChild(sentinel);
      
      // Re-conectar Intersection Observer al sentinel
      if (intersectionObserver && sentinel) {
        intersectionObserver.observe(sentinel);
        console.log('‚úÖ Sentinel agregado y observado');
      }
      
      // Cargar im√°genes AdrianLAB de forma controlada (5 SVG a la vez)
      if (LOAD_IMAGES) {
        requestIdleCallback(() => {
          loadAdrianLABImagesLazy();
        }, { timeout: 1000 });
      }
      
      console.log(`‚úÖ Renderizados ${displayedEvents.length} eventos (${newEventsCount > 0 ? `+${newEventsCount} nuevos` : 'sin cambios'})`);
    }
    
    function createEventItem(event) {
      // Crear contenedor completamente independiente
      const div = document.createElement('div');
      div.className = 'activity-item';
      
      // Badge
      let badgeColor = 'bg-secondary';
      let badgeText = event.type;
      if (event.type === 'FloorEngine') badgeColor = 'bg-primary';
      else if (event.type === 'ERC20') badgeColor = 'bg-success';
      else if (event.type === 'AdrianPunks') badgeColor = 'bg-primary';
      else if (event.type === 'AdrianLABCore') badgeColor = 'bg-purple';
      else if (event.type === 'ERC1155') badgeColor = 'bg-info';
      else if (event.type === 'TraitsExtensions') badgeColor = 'bg-warning';
      else if (event.type === 'AdrianShop') badgeColor = 'bg-danger';
      else if (event.type === 'AdrianNameRegistry') badgeColor = 'bg-primary';
      else if (event.type === 'AdrianSerumModule') badgeColor = 'bg-info';
      else if (event.type === 'PunkQuest') badgeColor = 'bg-warning';
      
      // Date
      const date = new Date(event.timestamp);
      const dateStr = date.toLocaleString('es-ES', { 
        year: 'numeric', 
        month: 'short', 
        day: 'numeric', 
        hour: '2-digit', 
        minute: '2-digit' 
      });
      
      // Details
      const details = formatEventDetails(event);
      const txHash = event.data?.tx_hash || '';
      
      // Imagen solo si est√° habilitada (desactivada por ahora para debug)
      const image = LOAD_IMAGES ? getEventImage(event) : '';
      
      // HTML simple y plano, sin anidamientos complejos
      div.innerHTML = `
        <div class="activity-header">
          <div>
            <span class="badge ${badgeColor} activity-badge">${badgeText}</span>
            <span class="badge bg-secondary activity-badge ms-2">${event.eventType}</span>
          </div>
          <div class="activity-date">${dateStr}</div>
        </div>
        <div class="activity-details">
          ${image}
          <span>${details}</span>
        </div>
        ${txHash ? `<div class="mt-2"><a href="https://basescan.org/tx/${txHash}" target="_blank" class="activity-link">View on Basescan <i class="bi bi-box-arrow-up-right"></i></a></div>` : ''}
      `;
      
      return div;
    }

    function formatEventDetails(event) {
      if (event.type === 'FloorEngine') {
        if (event.eventType === 'Listed' || event.eventType === 'Cancelled') {
          const tokenId = event.data.token_id;
          const seller = shortAddress(event.data.seller);
          const price = event.data.price_wei ? formatADRIAN(event.data.price_wei) : '';
          return `Token #${tokenId} - ${event.eventType} by ${seller}${price ? ' - Price: ' + price + ' $ADRIAN' : ''}`;
        } else if (event.eventType === 'Bought') {
          const tokenId = event.data.token_id;
          const buyer = shortAddress(event.data.buyer);
          const seller = shortAddress(event.data.seller);
          const price = event.data.price_wei ? formatADRIAN(event.data.price_wei) : '';
          return `Token #${tokenId} - Bought by ${buyer} from ${seller}${price ? ' - Price: ' + price + ' $ADRIAN' : ''}`;
        } else if (event.eventType === 'FloorSweep') {
          const tokenId = event.data.token_id;
          const caller = shortAddress(event.data.caller);
          const buyPrice = event.data.buy_price_wei ? formatADRIAN(event.data.buy_price_wei) : '';
          const reward = event.data.caller_reward_wei ? formatADRIAN(event.data.caller_reward_wei) : '';
          return `Token #${tokenId} - Sweep by ${caller}${buyPrice ? ' - Buy: ' + buyPrice + ' $ADRIAN' : ''}${reward ? ' - Reward: ' + reward + ' $ADRIAN' : ''}`;
        }
      } else if (event.type === 'ERC20') {
        if (event.eventType === 'Transfer') {
          const from = shortAddress(event.data.from_address);
          const to = shortAddress(event.data.to_address);
          const amount = event.data.value_wei ? formatADRIAN(event.data.value_wei) : '';
          // El tag contextual se aplica al to_address (destinatario) para REWARD y SALEPROCEEDS
          const fromTag = getAddressTagBadge(event.data.from_address);
          const toTag = getAddressTagBadge(event.data.to_address, event.contextualTag);
          return `Transfer from ${from}${fromTag} to ${to}${toTag}${amount ? ' - Amount: ' + amount + ' $ADRIAN' : ''}`;
        } else if (event.eventType === 'Approval') {
          const owner = shortAddress(event.data.owner);
          const spender = shortAddress(event.data.spender);
          const amount = event.data.value_wei ? formatADRIAN(event.data.value_wei) : '';
          return `Approval: ${owner} approved ${spender}${amount ? ' - Amount: ' + amount + ' $ADRIAN' : ''}`;
        }
      } else if (event.type === 'AdrianPunks') {
        if (event.eventType === 'Transfer') {
          const tokenId = event.data.token_id;
          const from = shortAddress(event.data.from_address);
          const to = shortAddress(event.data.to_address);
          return `Token #${tokenId} - Transfer from ${from} to ${to}`;
        } else if (event.eventType === 'Approval') {
          const tokenId = event.data.token_id;
          const owner = shortAddress(event.data.owner);
          const approved = shortAddress(event.data.approved);
          return `Token #${tokenId} - Approval: ${owner} approved ${approved}`;
        } else if (event.eventType === 'ApprovalForAll') {
          const owner = shortAddress(event.data.owner);
          const operator = shortAddress(event.data.operator);
          const approved = event.data.approved ? 'approved' : 'revoked';
          return `ApprovalForAll: ${owner} ${approved} ${operator}`;
        }
      } else if (event.type === 'AdrianLABCore') {
        if (event.eventType === 'Transfer') {
          const tokenId = event.data.token_id;
          const from = shortAddress(event.data.from_address);
          const to = shortAddress(event.data.to_address);
          return `Token #${tokenId} - Transfer from ${from} to ${to}`;
        } else if (event.eventType === 'TokenMinted') {
          const tokenId = event.data.token_id || event.data.event_data?.tokenId;
          const to = shortAddress(event.data.to_address || event.data.event_data?.to);
          return `Token #${tokenId} - Minted to ${to}`;
        } else if (event.eventType === 'SkinAssigned') {
          const tokenId = event.data.token_id || event.data.event_data?.tokenId;
          const skinName = event.data.event_data?.skinName || 'Unknown';
          return `Token #${tokenId} - Skin "${skinName}" assigned`;
        }
      } else if (event.type === 'ERC1155') {
        if (event.eventType === 'TransferSingle') {
          const tokenId = event.data.token_id || event.data.tokenId;
          const from = shortAddress(event.data.from_address);
          const to = shortAddress(event.data.to_address);
          const amount = event.data.value || event.data.amount || '1';
          return `Token #${tokenId} - Transfer ${amount} from ${from} to ${to}`;
        } else if (event.eventType === 'TransferBatch') {
          const tokenIds = event.data.token_ids || [];
          const from = shortAddress(event.data.from_address);
          const to = shortAddress(event.data.to_address);
          return `Batch Transfer (${tokenIds.length} tokens) from ${from} to ${to}`;
        } else if (event.eventType === 'AssetMinted') {
          const tokenId = event.data.token_id || event.data.event_data?.tokenId;
          const to = shortAddress(event.data.to_address || event.data.event_data?.to);
          const amount = event.data.amount || event.data.event_data?.amount || '1';
          return `Token #${tokenId} - ${amount} minted to ${to}`;
        } else if (event.eventType === 'PackOpened') {
          const opener = shortAddress(event.data.event_data?.opener || event.data.user_address);
          const items = event.data.event_data?.items || [];
          return `Pack opened by ${opener} - ${items.length} items`;
        }
      } else if (event.type === 'TraitsExtensions') {
        if (event.eventType === 'TraitApplied') {
          const tokenId = event.data.token_id || event.data.event_data?.tokenId;
          const traitId = event.data.trait_id || event.data.event_data?.traitId;
          return `Token #${tokenId} - Trait #${traitId} applied`;
        } else if (event.eventType === 'TraitsAppliedBatch') {
          const tokenId = event.data.token_id || event.data.event_data?.tokenId;
          const traitIds = event.data.trait_ids || event.data.event_data?.traitIds || [];
          return `Token #${tokenId} - ${traitIds.length} traits applied: [${traitIds.join(', ')}]`;
        }
      } else if (event.type === 'AdrianShop') {
        if (event.eventType === 'ItemPurchased') {
          const buyer = shortAddress(event.data.event_data?.buyer);
          const itemId = event.data.event_data?.itemId || 'N/A';
          const quantity = event.data.event_data?.quantity || '1';
          return `Item #${itemId} (x${quantity}) purchased by ${buyer}`;
        }
      } else if (event.type === 'AdrianNameRegistry') {
        if (event.eventType === 'NameSet' || event.eventType === 'NameRemoved') {
          const tokenId = event.data.token_id;
          const newName = event.data.new_name || event.data.event_data?.newName;
          const setter = shortAddress(event.data.setter);
          const paid = event.data.paid ? ' (Paid)' : ' (Free)';
          return `Token #${tokenId} - Name "${newName}" ${event.eventType === 'NameSet' ? 'set' : 'removed'} by ${setter}${paid}`;
        }
      } else if (event.type === 'AdrianSerumModule') {
        const tokenId = event.data.token_id || event.data.event_data?.tokenId;
        const serumId = event.data.serum_id || event.data.event_data?.serumId;
        const success = event.data.success !== false;
        return `Token #${tokenId} - Serum #${serumId} ${success ? 'applied successfully' : 'failed'}`;
      } else if (event.type === 'PunkQuest') {
        if (event.eventType === 'Staked' || event.eventType === 'Unstaked') {
          const tokenId = event.data.token_id || event.data.event_data?.tokenId;
          const user = shortAddress(event.data.user_address || event.data.event_data?.user);
          const reward = event.data.reward_wei ? formatADRIAN(event.data.reward_wei) : '';
          const bonus = event.data.bonus_added ? ` (Bonus: ${event.data.bonus_added})` : '';
          return `Token #${tokenId} - ${event.eventType} by ${user}${reward ? ' - Reward: ' + reward + ' $ADRIAN' : ''}${bonus}`;
        } else if (event.eventType === 'RewardClaimed') {
          const tokenId = event.data.token_id || event.data.event_data?.tokenId;
          const user = shortAddress(event.data.user_address || event.data.event_data?.user);
          const reward = event.data.reward_wei ? formatADRIAN(event.data.reward_wei) : '';
          return `Token #${tokenId} - Reward claimed by ${user}${reward ? ' - Amount: ' + reward + ' $ADRIAN' : ''}`;
        } else if (event.eventType === 'ItemPurchased' || event.eventType === 'ItemUsed' || event.eventType === 'ItemEquipped') {
          const itemId = event.data.item_id || event.data.event_data?.itemId;
          const user = shortAddress(event.data.user_address || event.data.event_data?.user);
          return `Item #${itemId} - ${event.eventType} by ${user}`;
        } else if (event.eventType === 'EventTriggered' || event.eventType === 'AdvancedEventTriggered') {
          const tokenId = event.data.token_id || event.data.event_data?.tokenId;
          const eventName = event.data.event_name || event.data.event_data?.name || 'Unknown Event';
          return `Token #${tokenId} - Event: ${eventName}`;
        }
      }
      
      return `${event.eventType}`;
    }

    function getEventImage(event) {
      if (!imageRules || !imageRules.eventImages) return '';
      
      const eventImages = imageRules.eventImages;
      
      // TraitApplied: usar mannequin (sin extensi√≥n SVG en el c√≥digo, solo URL)
      if (event.type === 'TraitsExtensions' && event.eventType === 'TraitApplied') {
        if (eventImages.TraitApplied && eventImages.TraitApplied.imageUrl) {
          // Nota: La URL puede ser .svg pero se carga desde el servidor, no causa crash
          return `<img src="${eventImages.TraitApplied.imageUrl}" class="nft-thumbnail" loading="lazy" decoding="async" alt="Mannequin" onerror="this.style.display='none'">`;
        }
      }
      
      // ERC20: usar ADRIAN_Coin.gif
      if (event.type === 'ERC20' && eventImages.ERC20 && eventImages.ERC20.imageUrl) {
        return `<img src="${eventImages.ERC20.imageUrl}" class="nft-thumbnail" loading="lazy" decoding="async" alt="ADRIAN Coin" onerror="this.style.display='none'">`;
      }
      
      // TraitsAppliedBatch: imagen din√°mica
      if (event.type === 'TraitsExtensions' && event.eventType === 'TraitsAppliedBatch') {
        if (eventImages.TraitsAppliedBatch && eventImages.TraitsAppliedBatch.dynamic) {
          // Extraer tokenId y traitIds de diferentes posibles ubicaciones en los datos
          const tokenId = event.data?.token_id || event.data?.tokenId || event.data?.event_data?.tokenId || event.data?.event_data?.token_id || '0';
          // traitIds puede venir como array o como string separado por comas
          let traitIds = event.data?.trait_ids || event.data?.traitIds || event.data?.event_data?.traitIds || event.data?.event_data?.trait_ids || [];
          
          // Si es string, convertir a array
          if (typeof traitIds === 'string') {
            traitIds = traitIds.split(',').map(id => id.trim()).filter(id => id);
          }
          
          // Asegurar que sea array
          if (!Array.isArray(traitIds)) {
            traitIds = [];
          }
          
          if (traitIds.length > 0) {
            const traitParams = traitIds.map(id => `trait=${id}`).join('&');
            const imageUrl = `${eventImages.TraitsAppliedBatch.baseUrl}${tokenId}?${traitParams}`;
            return `<img src="${imageUrl}" class="nft-thumbnail" loading="lazy" decoding="async" alt="Custom Trait" onerror="this.style.display='none'">`;
          }
        }
      }
      
      // Contratos que usan im√°genes de AdrianPunks (definidos en image-rules.json)
      if (imageRules && imageRules.adrianPunks && imageRules.adrianPunks.contracts) {
        const adrianPunksContracts = imageRules.adrianPunks.contracts;
        if (adrianPunksContracts.includes(event.type) && event.data?.token_id) {
          const tokenId = event.data.token_id;
          
          // AdrianLABCore usa API de render de AdrianZERO, no la l√≥gica de AdrianPunks
          if (event.type === 'AdrianLABCore') {
            const imageUrl = `https://adrianlab.vercel.app/api/render/${tokenId}.png`;
            return `<img src="${imageUrl}" class="nft-thumbnail" loading="lazy" decoding="async" alt="Token #${tokenId}" onerror="this.style.display='none'" onclick="window.open('${imageUrl}', '_blank')">`;
          }
          
          // FloorEngine y PunkQuest usan getNFTImageUrl (im√°genes de AdrianPunks)
          const imageUrl = getNFTImageUrl(tokenId);
          if (imageUrl) {
            return `<img src="${imageUrl}" class="nft-thumbnail" loading="lazy" decoding="async" alt="Token #${tokenId}" onerror="this.style.display='none'" onclick="window.open('${imageUrl}', '_blank')">`;
          }
        }
      }
      
      // ERC1155: imagen de AdrianLAB con carga controlada (5 SVG a la vez)
      if (event.type === 'ERC1155' && (event.data?.token_id || event.data?.tokenId)) {
        const tokenId = event.data.token_id || event.data.tokenId;
        return createAdrianLABImage(tokenId);
      }
      
      return '';
    }
    
    function getNFTImageUrl(tokenId) {
      if (!tokenId || tokenId === 'N/A') return null;
      if (imageRules && imageRules.adrianPunks) {
        return `${imageRules.adrianPunks.baseUrl}${tokenId}${imageRules.adrianPunks.extension}`;
      }
      return `../market/adrianpunksimages/${tokenId}.png`;
    }
    
    // ============================================
    // ADRIANLAB IMAGES - CARGA CONTROLADA (5 SVG a la vez)
    // ============================================
    function getAdrianLABImageUrls(tokenId) {
      if (!tokenId || tokenId === 'N/A') return [];
      
      const urls = [];
      if (imageRules && imageRules.adrianLAB) {
        const baseUrl = imageRules.adrianLAB.baseUrl;
        const primaryExtension = imageRules.adrianLAB.extension;
        const fallbackExtensions = imageRules.adrianLAB.fallbackExtensions || [];
        
        // Agregar extensi√≥n principal primero (SVG)
        urls.push(`${baseUrl}${tokenId}${primaryExtension}`);
        
        // Agregar extensiones de fallback (PNG, GIF)
        fallbackExtensions.forEach(ext => {
          urls.push(`${baseUrl}${tokenId}${ext}`);
        });
      } else {
        // Fallback hardcodeado
        urls.push(`https://adrianzero.com/traitlab/assets/traits/${tokenId}.svg`);
        urls.push(`https://adrianzero.com/traitlab/assets/traits/${tokenId}.png`);
        urls.push(`https://adrianzero.com/traitlab/assets/traits/${tokenId}.gif`);
      }
      
      return urls;
    }
    
    function createAdrianLABImage(tokenId) {
      if (!tokenId || tokenId === 'N/A') return '';
      
      // OPTIMIZACI√ìN: Reutilizar imagen del cach√© si ya existe
      if (imageCache.has(tokenId)) {
        // Si la imagen ya est√° cargada, clonar el elemento
        const cachedImg = loadedImagesCache.get(tokenId);
        if (cachedImg && cachedImg.complete && cachedImg.naturalWidth > 0) {
          // Clonar el elemento img ya cargado (m√°s eficiente que crear nuevo)
          const cloned = cachedImg.cloneNode(true);
          cloned.id = `adrianlab-img-${tokenId}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
          // Convertir a string HTML para insertar
          const tempDiv = document.createElement('div');
          tempDiv.appendChild(cloned);
          return tempDiv.innerHTML;
        }
        // Si est√° en cach√© pero a√∫n no cargada, usar el HTML del cach√©
        return imageCache.get(tokenId);
      }
      
      const urls = getAdrianLABImageUrls(tokenId);
      if (!urls || urls.length === 0) return '';
      
      // Crear imagen con data-src para carga diferida controlada
      const imageId = `adrianlab-img-${tokenId}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
      const urlsAttr = urls.map(url => url.replace(/"/g, '&quot;')).join(',');
      const imageHTML = `<img id="${imageId}" data-src="${urls[0]}" class="nft-thumbnail adrianlab-image" loading="lazy" decoding="async" alt="Trait #${tokenId}" data-fallback-urls="${urlsAttr}" data-current-index="0" data-token-id="${tokenId}" style="display: block; background: var(--card-bg); min-width: 80px; min-height: 80px;" onerror="tryNextAdrianLABImage(this)" onclick="if(this.src) window.open(this.src, '_blank')">`;
      
      // Guardar en cach√© para reutilizaci√≥n
      imageCache.set(tokenId, imageHTML);
      
      return imageHTML;
    }
    
    // Funci√≥n para cargar imagen SVG con control de concurrencia (m√°ximo 5)
    function loadAdrianLABImageWithTimeout(img) {
      if (activeSVGLoads >= MAX_CONCURRENT_SVG) {
        // Agregar a la cola si ya hay 5 cargando
        svgLoadQueue.push(img);
        return;
      }
      
      activeSVGLoads++;
      const urlsStr = img.getAttribute('data-fallback-urls') || '';
      const urls = urlsStr.split(',').map(url => url.trim()).filter(url => url);
      const currentIndex = parseInt(img.getAttribute('data-current-index') || '0');
      
      if (urls.length === 0 || currentIndex >= urls.length) {
        activeSVGLoads--;
        img.style.display = 'none';
        processSVGQueue(); // Procesar siguiente en cola
        return;
      }
      
      const url = urls[currentIndex];
      const timeoutId = setTimeout(() => {
        activeSVGLoads--;
        // Si la imagen no carg√≥ en el timeout, intentar siguiente o ocultar
        if (!img.complete || img.naturalWidth === 0) {
          tryNextAdrianLABImage(img);
        } else {
          processSVGQueue(); // Procesar siguiente en cola
        }
      }, IMAGE_LOAD_TIMEOUT);
      
      img.onload = function() {
        clearTimeout(timeoutId);
        activeSVGLoads--;
        this.style.display = 'block';
        
        // OPTIMIZACI√ìN: Guardar imagen cargada en cach√© para reutilizaci√≥n
        const tokenId = this.getAttribute('data-token-id');
        if (tokenId && !loadedImagesCache.has(tokenId)) {
          loadedImagesCache.set(tokenId, this);
        }
        
        processSVGQueue(); // Procesar siguiente en cola
      };
      
      img.onerror = function() {
        clearTimeout(timeoutId);
        activeSVGLoads--;
        tryNextAdrianLABImage(this);
      };
      
      img.src = url;
    }
    
    // Procesar cola de im√°genes SVG pendientes
    function processSVGQueue() {
      if (svgLoadQueue.length === 0 || activeSVGLoads >= MAX_CONCURRENT_SVG) {
        return;
      }
      
      const img = svgLoadQueue.shift();
      if (img && img.getAttribute('data-src')) {
        loadAdrianLABImageWithTimeout(img);
      }
    }
    
    // Cargar im√°genes AdrianLAB de forma controlada (5 a la vez)
    function loadAdrianLABImagesLazy() {
      const images = document.querySelectorAll('img.adrianlab-image[data-src]');
      const tokenIdsToLoad = new Set(); // Evitar cargar el mismo tokenId m√∫ltiples veces
      
      images.forEach(img => {
        const tokenId = img.getAttribute('data-token-id');
        // Solo agregar a la cola si:
        // 1. Tiene data-src y a√∫n no tiene src
        // 2. No est√° ya cargando este tokenId (evitar duplicados)
        if (img && img.getAttribute('data-src') && !img.src && tokenId && !tokenIdsToLoad.has(tokenId)) {
          // Verificar si ya est√° cargada en cach√©
          const cachedImg = loadedImagesCache.get(tokenId);
          if (cachedImg && cachedImg.complete && cachedImg.naturalWidth > 0) {
            // Reutilizar imagen del cach√©: clonar src y atributos
            img.src = cachedImg.src;
            img.removeAttribute('data-src');
            img.style.display = 'block';
            return; // No agregar a la cola, ya est√° resuelto
          }
          
          tokenIdsToLoad.add(tokenId);
          svgLoadQueue.push(img);
        }
      });
      
      // Procesar primeras 5 im√°genes √∫nicas
      for (let i = 0; i < Math.min(MAX_CONCURRENT_SVG, svgLoadQueue.length); i++) {
        const img = svgLoadQueue.shift();
        if (img) {
          loadAdrianLABImageWithTimeout(img);
        }
      }
    }
    
    function tryNextAdrianLABImage(img) {
      try {
        const urlsStr = img.getAttribute('data-fallback-urls') || '';
        const urls = urlsStr.split(',').map(url => url.trim()).filter(url => url);
        const currentIndex = parseInt(img.getAttribute('data-current-index') || '0');
        
        if (currentIndex < urls.length - 1) {
          const nextIndex = currentIndex + 1;
          img.setAttribute('data-current-index', nextIndex.toString());
          // Intentar siguiente URL
          loadAdrianLABImageWithTimeout(img);
      } else {
          // Si no hay m√°s fallbacks, ocultar la imagen
          img.style.display = 'none';
          processSVGQueue(); // Procesar siguiente en cola
        }
      } catch (error) {
        console.warn('Error en tryNextAdrianLABImage:', error);
        img.style.display = 'none';
        if (activeSVGLoads > 0) activeSVGLoads--;
        processSVGQueue(); // Procesar siguiente en cola
      }
    }
    
    // Hacer funci√≥n global para que funcione desde onerror
    window.tryNextAdrianLABImage = tryNextAdrianLABImage;

    // ============================================
    // UTILITY FUNCTIONS
    // ============================================
    function formatADRIAN(weiString) {
      try {
        let weiStr = String(weiString);
        if (weiStr.includes('e') || weiStr.includes('E')) {
          const num = parseFloat(weiStr);
          weiStr = num.toLocaleString('fullwide', { useGrouping: false, maximumFractionDigits: 0 });
        }
        weiStr = weiStr.replace(/,/g, '');
        if (!/^\d+$/.test(weiStr)) return '0.00';
        const wei = ethers.BigNumber.from(weiStr);
        const adrian = parseFloat(ethers.utils.formatUnits(wei, 18));
        return adrian.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
      } catch (error) {
        return '0.00';
      }
    }

    function shortAddress(address) {
      if (!address) return 'N/A';
      return `${address.slice(0, 6)}...${address.slice(-4)}`;
    }

    function getAddressTagBadge(address, contextualTag) {
      if (contextualTag) {
        return `<span class="badge bg-${contextualTag.color} ms-2">${contextualTag.tag}</span>`;
      }
      const tagInfo = addressTagsRules[address?.toLowerCase()];
      if (!tagInfo) return '';
      return `<span class="badge bg-${tagInfo.color} ms-2">${tagInfo.tag}</span>`;
    }

    function applyEventFilteringRules(events) {
      if (!eventRules || !eventRules.filtering) return events;
      
      const filteringRules = eventRules.filtering;
      let filtered = [...events];
      
      // Filtrado de mints redundantes
      if (filteringRules.redundantMints && filteringRules.redundantMints.enabled) {
        const rules = filteringRules.redundantMints.rules || [];
        rules.forEach(rule => {
          if (rule.sourceEvent && rule.conflictEvent) {
            // Buscar TransferSingle que sean mints (from_address = 0x0)
            const transferSingles = filtered.filter(e => 
              e.type === rule.sourceEvent.type &&
              e.eventType === rule.sourceEvent.eventType &&
              e.data.from_address === BURN_ADDRESS.toLowerCase()
            );
            
            // Buscar AssetMinted correspondientes
            const assetMinteds = filtered.filter(e =>
              e.type === rule.conflictEvent.type &&
              e.eventType === rule.conflictEvent.eventType
            );
            
            // Crear mapa de AssetMinted por tokenId y to_address
            const mintedMap = new Map();
            assetMinteds.forEach(mint => {
              const tokenId = mint.data.token_id || mint.data.tokenId || mint.data.event_data?.tokenId;
              const toAddress = (mint.data.to_address || mint.data.event_data?.to || '').toLowerCase();
              if (tokenId && toAddress) {
                const key = `${tokenId}-${toAddress}`;
                if (!mintedMap.has(key)) {
                  mintedMap.set(key, []);
                }
                mintedMap.get(key).push(mint);
              }
            });
            
            // Remover TransferSingle que tienen AssetMinted correspondiente
            filtered = filtered.filter(e => {
              if (e.type === rule.sourceEvent.type && e.eventType === rule.sourceEvent.eventType) {
                const tokenId = e.data.token_id || e.data.tokenId;
                const toAddress = (e.data.to_address || '').toLowerCase();
                if (tokenId && toAddress) {
                  const key = `${tokenId}-${toAddress}`;
                  if (mintedMap.has(key)) {
                    // Hay AssetMinted correspondiente, remover este TransferSingle
                    return false;
                  }
                }
              }
              return true;
            });
          }
        });
      }
      
      // Filtrado de FloorSweep duplicados
      if (filteringRules.duplicateFloorSweeps && filteringRules.duplicateFloorSweeps.enabled) {
        const rules = filteringRules.duplicateFloorSweeps.rules || [];
        rules.forEach(rule => {
          if (rule.sourceEvent && rule.conflictEvent) {
            // Agrupar FloorSweeps por token_id y timestamp (ventana de 10 minutos)
            const sweepGroups = new Map();
            
            filtered.forEach(event => {
              if (event.type === 'FloorEngine' && event.eventType === 'FloorSweep') {
                const tokenId = event.data.token_id;
                const timestamp = new Date(event.timestamp);
                // Usar token_id como clave principal, luego agrupar por ventana de tiempo
                const baseKey = `${tokenId}`;
                
                // Buscar si ya existe un grupo para este token_id
                let foundGroup = null;
                for (const [key, group] of sweepGroups.entries()) {
                  if (key.startsWith(`${tokenId}-`)) {
                    // Verificar si este evento est√° dentro de 15 minutos de alg√∫n evento del grupo
                    const groupTimestamps = group.map(e => new Date(e.timestamp));
                    const isClose = groupTimestamps.some(ts => {
                      const timeDiff = Math.abs(timestamp - ts);
                      return timeDiff < 15 * 60 * 1000; // 15 minutos
                    });
                    if (isClose) {
                      foundGroup = key;
                      break;
                    }
                  }
                }
                
                if (foundGroup) {
                  sweepGroups.get(foundGroup).push(event);
                } else {
                  // Crear nuevo grupo
                  const newKey = `${tokenId}-${timestamp.getTime()}`;
                  sweepGroups.set(newKey, [event]);
                }
              }
            });
            
            // Para cada grupo, mantener solo el que tiene m√°s informaci√≥n
            sweepGroups.forEach((sweeps, key) => {
              if (sweeps.length > 1) {
                // Ordenar por cantidad de informaci√≥n (m√°s informaci√≥n = m√°s campos no nulos)
                sweeps.sort((a, b) => {
                  // Contar campos con informaci√≥n v√°lida (no null, no vac√≠o, no 'N/A')
                  const aInfo = [
                    a.data.caller,
                    a.data.buy_price_wei,
                    a.data.caller_reward_wei,
                    a.data.relist_price_wei
                  ].filter(v => {
                    if (v == null) return false;
                    if (v === '') return false;
                    if (String(v).toUpperCase() === 'N/A') return false;
                    if (String(v).trim() === '') return false;
                    return true;
                  }).length;
                  
                  const bInfo = [
                    b.data.caller,
                    b.data.buy_price_wei,
                    b.data.caller_reward_wei,
                    b.data.relist_price_wei
                  ].filter(v => {
                    if (v == null) return false;
                    if (v === '') return false;
                    if (String(v).toUpperCase() === 'N/A') return false;
                    if (String(v).trim() === '') return false;
                    return true;
                  }).length;
                  
                  return bInfo - aInfo; // Ordenar descendente (m√°s info primero)
                });
                
                // Mantener solo el primero (el que tiene m√°s informaci√≥n)
                const keepEvent = sweeps[0];
                const removeEvents = sweeps.slice(1);
                
                // Remover los eventos con menos informaci√≥n
                const eventsToRemove = new Set(removeEvents);
                filtered = filtered.filter(event => {
                  if (event.type === 'FloorEngine' && event.eventType === 'FloorSweep') {
                    // Verificar si este evento est√° en el grupo y debe ser removido
                    const tokenId = event.data.token_id;
                    const timestamp = new Date(event.timestamp);
                    
                    // Verificar si est√° en el grupo actual
                    const inGroup = sweeps.some(s => {
                      const sTokenId = s.data.token_id;
                      const sTimestamp = new Date(s.timestamp);
                      const timeDiff = Math.abs(timestamp - sTimestamp);
                      return sTokenId === tokenId && timeDiff < 15 * 60 * 1000; // 15 minutos
                    });
                    
                    if (inGroup) {
                      // Es parte de este grupo, mantener solo el que tiene m√°s info
                      return event === keepEvent;
                    }
                  }
                  return true;
                });
              }
            });
          }
        });
      }
      
      return filtered;
    }

    function applyContextualTagging(events) {
      if (!eventRules || !eventRules.contextualTagging) return;
      
      const contextualRules = eventRules.contextualTagging;
      
      // Etiquetado contextual para FloorSweep
      if (contextualRules.floorSweep && contextualRules.floorSweep.enabled) {
        const rules = contextualRules.floorSweep.rules || [];
        rules.forEach(rule => {
          if (rule.triggerEvent && rule.targetEvents) {
            // Buscar eventos FloorSweep
            const floorSweeps = events.filter(e =>
              e.type === rule.triggerEvent.type &&
              e.eventType === rule.triggerEvent.eventType
            );
            
            // Para cada FloorSweep, buscar ERC20 transfers relacionados
            floorSweeps.forEach(sweep => {
              const sweepTimestamp = new Date(sweep.timestamp);
              // Normalizar caller (puede ser "N/A", null, undefined, o string vac√≠o)
              let sweepCaller = sweep.data.caller;
              if (sweepCaller && typeof sweepCaller === 'string') {
                sweepCaller = sweepCaller.trim();
                if (sweepCaller.toUpperCase() === 'N/A' || sweepCaller === '') {
                  sweepCaller = null;
                } else {
                  sweepCaller = sweepCaller.toLowerCase();
                }
              } else if (!sweepCaller) {
                sweepCaller = null;
              } else {
                sweepCaller = String(sweepCaller).toLowerCase();
              }
              const sweepSeller = sweep.data.seller?.toLowerCase(); // Seller del listing original
              
              rule.targetEvents.forEach(targetRule => {
                if (targetRule.type === 'ERC20' && targetRule.eventType === 'Transfer') {
                  // Verificar condici√≥n de from_address si existe en la regla
                  const requiredFromAddress = targetRule.conditions?.from_address?.toLowerCase();
                  
                  events.forEach(event => {
                    if (event.type === targetRule.type && event.eventType === targetRule.eventType) {
                      // Verificar from_address si est√° especificado en la regla
                      if (requiredFromAddress) {
                        const eventFromAddress = event.data.from_address?.toLowerCase();
                        if (eventFromAddress !== requiredFromAddress) {
                          return; // No coincide, saltar este evento
                        }
                      }
                      
                      const eventTimestamp = new Date(event.timestamp);
                      const timeDiff = Math.abs(eventTimestamp - sweepTimestamp);
                      
                      // Si el evento est√° dentro de 5 minutos del sweep
                      if (timeDiff < 5 * 60 * 1000) {
                        // Normalizar montos para comparaci√≥n (convertir a string para comparar)
                        const normalizeAmount = (amount) => {
                          if (amount == null) return null;
                          // Si es BigNumber de ethers, usar toString()
                          if (amount && typeof amount === 'object' && amount.toString && typeof amount.toString === 'function') {
                            return amount.toString();
                          }
                          if (typeof amount === 'string') {
                            // Limpiar string de espacios y convertir a n√∫mero para normalizar
                            const cleaned = amount.trim();
                            if (cleaned === '' || cleaned === '0') return null;
                            return cleaned;
                          }
                          if (typeof amount === 'number') {
                            return amount.toString();
                          }
                          return String(amount);
                        };
                        
                        const eventAmount = normalizeAmount(event.data.value_wei);
                        const matchAmount = targetRule.matchAmount;
                        
                        if (matchAmount === 'caller_reward_wei') {
                          // Reward va al caller (solo si hay caller v√°lido)
                          if (sweepCaller) {
                            const rewardAmount = normalizeAmount(sweep.data.caller_reward_wei);
                            const eventToAddress = event.data.to_address?.toLowerCase();
                            
                            // Debug logging
                            if (eventAmount && rewardAmount) {
                              console.log('üîç Checking REWARD match:', {
                                eventAmount,
                                rewardAmount,
                                match: eventAmount === rewardAmount,
                                eventTo: eventToAddress,
                                sweepCaller: sweepCaller,
                                addressMatch: eventToAddress === sweepCaller
                              });
                            }
                            
                            if (eventAmount && rewardAmount && eventAmount === rewardAmount && eventToAddress === sweepCaller) {
                              event.contextualTag = targetRule.tag;
                              console.log('‚úÖ Tagged REWARD:', eventAmount, 'to', eventToAddress);
                            }
                          } else {
                            console.log('‚ö†Ô∏è Sweep has no valid caller, skipping REWARD tag');
                          }
                        } else if (matchAmount === 'buy_price_wei') {
                          // Buy price va al seller (no al caller)
                          const buyAmount = normalizeAmount(sweep.data.buy_price_wei);
                          const eventToAddress = event.data.to_address?.toLowerCase();
                          
                          // Debug logging
                          if (eventAmount && buyAmount) {
                            console.log('üîç Checking SALEPROCEEDS match:', {
                              eventAmount,
                              buyAmount,
                              match: eventAmount === buyAmount,
                              eventTo: eventToAddress,
                              sweepSeller: sweepSeller,
                              sweepCaller: sweepCaller
                            });
                          }
                          
                          // Si tenemos seller en el sweep, usar ese, si no, buscar cualquier transfer del monto correcto
                          if (eventAmount && buyAmount && eventAmount === buyAmount) {
                            if (sweepSeller && eventToAddress === sweepSeller) {
                              event.contextualTag = targetRule.tag;
                              console.log('‚úÖ Tagged SALEPROCEEDS (by seller):', eventAmount, 'to', eventToAddress);
                            } else if (!sweepSeller) {
                              // Si no hay seller en el sweep, etiquetar cualquier transfer del monto correcto
                              // que no sea el reward (para evitar duplicados)
                              if (!sweepCaller || eventToAddress !== sweepCaller) {
                                event.contextualTag = targetRule.tag;
                                console.log('‚úÖ Tagged SALEPROCEEDS (by amount):', eventAmount, 'to', eventToAddress);
                              }
                            }
                          }
                        }
                      }
                    }
                  });
                }
              });
            });
          }
        });
      }
    }
    
    function setupIntersectionObserver() {
      if (!('IntersectionObserver' in window)) {
        console.warn('Intersection Observer no soportado, usando bot√≥n Load More');
        return;
      }
      
      // Limpiar observer anterior si existe
      if (intersectionObserver) {
        intersectionObserver.disconnect();
      }
      
      intersectionObserver = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting && hasMore && !isLoading) {
            console.log('üìú Sentinel visible, cargando m√°s eventos...');
            loadMore();
          }
        });
      }, {
        root: null,
        rootMargin: '200px', // Cargar antes de llegar al final
        threshold: 0.1
      });
      
      console.log('‚úÖ Intersection Observer configurado');
    }
    
    function showActivityTab() {
      document.getElementById('activity-tab-content').classList.add('active');
      document.getElementById('statistics-tab-content').classList.remove('active');
      document.getElementById('tab-activity-btn').classList.add('active');
      document.getElementById('tab-statistics-btn').classList.remove('active');
    }
    
    // Statistics Manager instance
    let statisticsManager = null;

    // Variables para el per√≠odo de estad√≠sticas
    let currentStatsPeriod = 'all';
    let currentStatsDateFrom = null;
    let currentStatsDateTo = null;

    function showStatisticsTab() {
      document.getElementById('activity-tab-content').classList.remove('active');
      document.getElementById('statistics-tab-content').classList.add('active');
      document.getElementById('tab-activity-btn').classList.remove('active');
      document.getElementById('tab-statistics-btn').classList.add('active');
      
      // Inicializar y cargar estad√≠sticas si no est√° inicializado
      if (!statisticsManager && supabaseClient) {
        console.log('üìä Inicializando StatisticsManager...');
        statisticsManager = new StatisticsManager(supabaseClient, {
          contracts: {
            FLOOR_ENGINE: FLOOR_ENGINE_ADDRESS,
            ERC20: ERC20_ADDRESS,
            ADRIANPUNKS: ADRIANPUNKS_ADDRESS,
            ADRIANLABCORE: ADRIANLABCORE_ADDRESS,
            ERC1155: ERC1155_ADDRESS,
            TRAITS_EXTENSIONS: TRAITS_EXTENSIONS_ADDRESS,
            ADRIAN_SHOP: ADRIAN_SHOP_ADDRESS,
            ADRIAN_NAME_REGISTRY: ADRIAN_NAME_REGISTRY_ADDRESS,
            ADRIAN_SERUM_MODULE: ADRIAN_SERUM_MODULE_ADDRESS,
            PUNK_QUEST: PUNK_QUEST_ADDRESS
          },
          charts: {
            enabled: true,
            library: 'chartjs'
          }
        });
        
        statisticsManager.init().then(() => {
          console.log('‚úÖ StatisticsManager inicializado, renderizando...');
          // Cargar con per√≠odo "all" por defecto
          const { dateFrom, dateTo } = statisticsManager.getPeriodDates('all');
          currentStatsDateFrom = dateFrom;
          currentStatsDateTo = dateTo;
          loadStatisticsWithPeriod(dateFrom, dateTo);
        }).catch(error => {
          console.error('‚ùå Error inicializando StatisticsManager:', error);
          const container = document.getElementById('statistics-container');
          if (container) {
            container.innerHTML = '<div class="alert alert-danger">Error inicializando estad√≠sticas: ' + error.message + '</div>';
          }
        });
      } else if (statisticsManager) {
        // Si ya est√° inicializado, solo renderizar (usar√° cach√© si est√° disponible)
        console.log('üìä Re-renderizando estad√≠sticas...');
        loadStatisticsWithPeriod(currentStatsDateFrom, currentStatsDateTo);
      } else {
        console.warn('‚ö†Ô∏è StatisticsManager no puede inicializarse: supabaseClient no disponible');
        const container = document.getElementById('statistics-container');
        if (container) {
          container.innerHTML = '<div class="alert alert-warning">Error: No se pudo conectar a la base de datos</div>';
        }
      }
    }

    function loadStatisticsWithPeriod(dateFrom, dateTo) {
      if (!statisticsManager) return;
      
      const container = document.getElementById('statistics-container');
      if (container) {
        container.innerHTML = '<div class="text-center py-5"><div class="spinner-border" role="status"><span class="visually-hidden">Cargando estad√≠sticas...</span></div></div>';
      }

      statisticsManager.render('statistics-container', dateFrom, dateTo).then(() => {
        // Configurar event listeners para los botones de per√≠odo
        setupPeriodButtons();
      }).catch(error => {
        console.error('‚ùå Error renderizando estad√≠sticas:', error);
        if (container) {
          container.innerHTML = '<div class="alert alert-danger">Error cargando estad√≠sticas: ' + error.message + '</div>';
        }
      });
    }

    function setupPeriodButtons() {
      // Configurar botones de per√≠odo r√°pido
      document.querySelectorAll('.period-btn').forEach(btn => {
        btn.addEventListener('click', function() {
          // Remover active de todos los botones
          document.querySelectorAll('.period-btn').forEach(b => b.classList.remove('active'));
          // Agregar active al bot√≥n clickeado
          this.classList.add('active');
          
          const period = this.getAttribute('data-period');
          currentStatsPeriod = period;
          
          const { dateFrom, dateTo } = statisticsManager.getPeriodDates(period);
          currentStatsDateFrom = dateFrom;
          currentStatsDateTo = dateTo;
          
          // Limpiar date pickers si es per√≠odo predefinido
          if (period !== 'custom') {
            const dateFromEl = document.getElementById('statsDateFrom');
            const dateToEl = document.getElementById('statsDateTo');
            if (dateFromEl) dateFromEl.value = dateFrom || '';
            if (dateToEl) dateToEl.value = dateTo || '';
          }
          
          loadStatisticsWithPeriod(dateFrom, dateTo);
        });
      });

      // Marcar el bot√≥n activo seg√∫n el per√≠odo actual (por defecto "all")
      const activePeriod = currentStatsPeriod || 'all';
      document.querySelectorAll('.period-btn').forEach(btn => {
        if (btn.getAttribute('data-period') === activePeriod) {
          btn.classList.add('active');
        }
      });
    }

    function applyStatsPeriod() {
      const dateFrom = document.getElementById('statsDateFrom').value || null;
      const dateTo = document.getElementById('statsDateTo').value || null;
      
      // Validar que dateTo >= dateFrom
      if (dateFrom && dateTo && new Date(dateTo) < new Date(dateFrom)) {
        alert('La fecha "Hasta" debe ser mayor o igual a la fecha "Desde"');
        return;
      }
      
      currentStatsDateFrom = dateFrom;
      currentStatsDateTo = dateTo;
      currentStatsPeriod = 'custom';
      
      // Remover active de todos los botones
      document.querySelectorAll('.period-btn').forEach(b => b.classList.remove('active'));
      
      loadStatisticsWithPeriod(dateFrom, dateTo);
    }

    // Hacer funci√≥n global
    window.applyStatsPeriod = applyStatsPeriod;

    function cleanupOldItems() {
      // Si hay m√°s de MAX_ITEMS_IN_DOM, mantener solo los √∫ltimos
      if (displayedEvents.length > MAX_ITEMS_IN_DOM) {
        const toRemove = displayedEvents.length - MAX_ITEMS_IN_DOM;
        displayedEvents = displayedEvents.slice(toRemove);
      }
    }

    // ============================================
    // UI HELPERS
    // ============================================
    function showLoading() {
      const container = document.getElementById('activityListContainer');
      if (container) {
        container.innerHTML = '<div class="loading-spinner"><div class="spinner-border" role="status"></div></div>';
      }
    }

    function hideLoading() {
      // Loading se oculta cuando renderizamos
    }

    function showError(message) {
      const container = document.getElementById('activityListContainer');
      if (container) {
        container.innerHTML = `<div class="alert alert-danger">${message}</div>`;
      }
    }

    function updateLoadMoreButton() {
      const container = document.getElementById('loadMoreContainer');
      if (container) {
        if (hasMore && !isLoading) {
          container.style.display = 'block';
          console.log('‚úÖ Bot√≥n Load More visible');
        } else {
          container.style.display = 'none';
          if (!hasMore) {
            console.log('‚ÑπÔ∏è No hay m√°s eventos, bot√≥n oculto');
          }
        }
      }
    }

    // ============================================
    // FILTER HANDLERS
    // ============================================
    function toggleFilters() {
      const filtersBody = document.getElementById('filtersBody');
      const toggleIcon = document.getElementById('filtersToggleIcon');
      
      if (filtersBody) {
        const isMobile = window.innerWidth <= 768;
        
        if (isMobile) {
          // En m√≥viles, usar clase 'show'
          filtersBody.classList.toggle('show');
          toggleIcon.classList.toggle('rotated');
        } else {
          // En desktop, usar clase 'collapsed'
          filtersBody.classList.toggle('collapsed');
          toggleIcon.classList.toggle('rotated');
        }
      }
    }

    function applyFilters() {
      filters.contract = document.getElementById('filterContract').value;
      filters.eventType = document.getElementById('filterEventType').value;
      filters.dateFrom = document.getElementById('filterDateFrom').value || null;
      filters.dateTo = document.getElementById('filterDateTo').value || null;
      filters.address = document.getElementById('filterAddress').value.trim() || null;
      
      loadFirstPage();
    }

    function clearFilters() {
      document.getElementById('filterContract').value = 'all';
      document.getElementById('filterEventType').value = 'all';
      document.getElementById('filterDateFrom').value = '';
      document.getElementById('filterDateTo').value = '';
      document.getElementById('filterAddress').value = '';
      
      filters.contract = 'all';
      filters.eventType = 'all';
      filters.dateFrom = null;
      filters.dateTo = null;
      filters.address = null;
      
      loadFirstPage();
    }

    // ============================================
    // INITIALIZE ON LOAD
    // ============================================
    document.addEventListener('DOMContentLoaded', init);
  </script>
</body>
</html>

