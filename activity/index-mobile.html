<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>$ADRIAN Ecosystem Activity</title>
  <link rel="icon" type="image/x-icon" href="../favicon.ico">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css">
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/5.7.2/ethers.umd.min.js"></script>
  <script src="./supabase-config.js"></script>
  <style>
    :root {
      --bg-color: #ffffff;
      --text-color: #333333;
      --card-bg: #ffffff;
      --border-color: #dee2e6;
    }

    [data-theme="dark"] {
      --bg-color: #1a1a1a;
      --text-color: #ffffff;
      --card-bg: #2d2d2d;
      --border-color: #404040;
    }

    .bg-purple {
      background-color: #9c27b0 !important;
    }

    body {
      background-color: var(--bg-color);
      color: var(--text-color);
      margin: 0;
      padding: 0;
    }

    #menu-container {
      margin: 0;
      padding: 0;
    }

    #menu-container .navbar {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      width: 100%;
      z-index: 1000;
    }

    .main-container {
      padding-top: 80px;
      min-height: 100vh;
    }

    @media (max-width: 768px) {
      .main-container {
        padding-top: 60px;
      }
    }

    .activity-item {
      border: 1px solid var(--border-color);
      border-radius: 8px;
      padding: 1rem;
      margin-bottom: 1rem;
      background-color: var(--card-bg);
      transition: box-shadow 0.2s;
    }

    .activity-item:hover {
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }

    .activity-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 0.5rem;
      flex-wrap: wrap;
      gap: 0.5rem;
    }

    .activity-badge {
      font-size: 0.75rem;
      padding: 0.25rem 0.5rem;
    }

    .activity-date {
      font-size: 0.85rem;
      color: #6c757d;
    }

    .activity-details {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      flex-wrap: wrap;
    }

    .nft-thumbnail {
      width: 48px;
      height: 48px;
      object-fit: contain;
      border-radius: 4px;
      border: 1px solid var(--border-color);
      background: var(--card-bg);
      flex-shrink: 0;
    }

    .activity-link {
      font-size: 0.85rem;
      text-decoration: none;
    }

    .load-more-container {
      text-align: center;
      padding: 2rem 1rem;
    }

    .loading-spinner {
      text-align: center;
      padding: 2rem;
    }

    .section-header {
      margin-bottom: 1.5rem;
      padding-bottom: 0.5rem;
      border-bottom: 2px solid var(--border-color);
    }

    .section-header h2 {
      margin: 0;
      font-size: 1.5rem;
    }

    .stat-card {
      background: var(--card-bg);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      padding: 1.5rem;
      text-align: center;
      transition: box-shadow 0.2s;
    }

    .stat-card:hover {
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }

    .stat-label {
      font-size: 0.9rem;
      color: #6c757d;
      margin-bottom: 0.5rem;
    }

    .stat-value {
      font-size: 1.5rem;
      font-weight: bold;
      color: var(--text-color);
    }

    .stat-value.positive {
      color: #28a745;
    }

    .stat-value.negative {
      color: #dc3545;
    }

    .stat-subtitle {
      font-size: 0.75rem;
      color: #6c757d;
      margin-top: 0.25rem;
    }

    @media (max-width: 768px) {
      .activity-item {
        padding: 0.75rem;
      }
      
      .activity-header {
        font-size: 0.9rem;
      }
      
      .activity-details {
        font-size: 0.85rem;
      }
      
      .nft-thumbnail {
        width: 40px;
        height: 40px;
      }
    }
  </style>
</head>
<body>
  <!-- Menu -->
  <div id="menu-container">
    <object data="../components/menu.html" type="text/html" style="width: 100%; height: auto;">
      <nav class="navbar navbar-expand-lg bg-light">
        <div class="container-fluid">
          <a class="navbar-brand" href="/">$ADRIAN</a>
        </div>
      </nav>
    </object>
  </div>

  <!-- Main Content -->
  <div class="main-container">
    <div class="container py-4">
      <div class="text-center mb-4">
        <h1>$ADRIAN Ecosystem Statistics</h1>
        <p class="text-muted">Comprehensive analytics for the $ADRIAN ecosystem</p>
      </div>

      <!-- Tabs Navigation -->
      <ul class="nav nav-tabs mb-4" id="mainTabs" role="tablist">
        <li class="nav-item" role="presentation">
          <button class="nav-link active" id="activity-tab" data-bs-toggle="tab" data-bs-target="#activity" type="button" role="tab">
            <i class="bi bi-list-ul"></i> Raw Activity
          </button>
        </li>
        <li class="nav-item" role="presentation">
          <button class="nav-link" id="stats-tab" data-bs-toggle="tab" data-bs-target="#stats" type="button" role="tab">
            <i class="bi bi-graph-up"></i> Statistics
          </button>
        </li>
      </ul>

      <!-- Tab Content -->
      <div class="tab-content" id="mainTabContent">
        <!-- Raw Activity Tab (Principal) -->
        <div class="tab-pane fade show active" id="activity" role="tabpanel">
          <div class="section-header mb-3">
            <h2><i class="bi bi-list-ul"></i> Raw Activity</h2>
          </div>

          <!-- Filters -->
      <div class="card mb-4">
        <div class="card-body">
          <div class="row g-3">
            <div class="col-md-3">
              <label class="form-label">Contract</label>
              <select id="filterContract" class="form-select">
                <option value="all">All Contracts</option>
                <option value="floorengine">FloorEngine</option>
                <option value="erc20">ERC20</option>
                <option value="adrianlabcore">AdrianZERO</option>
                <option value="erc1155">AdrianLAB</option>
                <option value="traitsextensions">Traits</option>
                <option value="adrianshop">Shop</option>
              </select>
            </div>
            <div class="col-md-3">
              <label class="form-label">Event Type</label>
              <select id="filterEventType" class="form-select">
                <option value="all">All Events</option>
              </select>
            </div>
            <div class="col-md-2">
              <label class="form-label">Date From</label>
              <input type="date" id="filterDateFrom" class="form-control">
            </div>
            <div class="col-md-2">
              <label class="form-label">Date To</label>
              <input type="date" id="filterDateTo" class="form-control">
            </div>
            <div class="col-md-2">
              <label class="form-label">Address</label>
              <input type="text" id="filterAddress" class="form-control" placeholder="0x...">
            </div>
          </div>
          <div class="row mt-3">
            <div class="col-12">
              <button class="btn btn-primary" onclick="applyFilters()">Apply Filters</button>
              <button class="btn btn-secondary ms-2" onclick="clearFilters()">Clear</button>
            </div>
          </div>
        </div>
      </div>

      <!-- Activity List -->
      <div id="activityListContainer">
        <div class="loading-spinner">
          <div class="spinner-border" role="status">
            <span class="visually-hidden">Loading...</span>
          </div>
        </div>
      </div>

          <!-- Sentinel para Intersection Observer (scroll infinito) -->
          <div id="scrollSentinel" style="height: 1px; visibility: hidden;"></div>
        </div> <!-- End Raw Activity Tab -->

        <!-- Stats Tab (Secundario) -->
        <div class="tab-pane fade" id="stats" role="tabpanel">
          <!-- FloorEngine Statistics Section -->
          <div class="section-header">
            <h2><i class="bi bi-graph-up"></i> FloorEngine Statistics</h2>
          </div>
          <div id="floorEngineStats" class="row g-3 mb-4">
            <div class="col-md-3">
              <div class="stat-card">
                <div class="stat-label">Total Invested</div>
                <div class="stat-value" id="feTotalInvested">Loading...</div>
              </div>
            </div>
            <div class="col-md-3">
              <div class="stat-card">
                <div class="stat-label">Total Earned</div>
                <div class="stat-value" id="feTotalEarned">Loading...</div>
              </div>
            </div>
            <div class="col-md-3">
              <div class="stat-card">
                <div class="stat-label">Net Profit</div>
                <div class="stat-value" id="feNetProfit">Loading...</div>
              </div>
            </div>
            <div class="col-md-3">
              <div class="stat-card">
                <div class="stat-label">ROI</div>
                <div class="stat-value" id="feROI">Loading...</div>
              </div>
            </div>
            <div class="col-md-3">
              <div class="stat-card">
                <div class="stat-label">Punks Bought</div>
                <div class="stat-value" id="fePunksBought">Loading...</div>
              </div>
            </div>
            <div class="col-md-3">
              <div class="stat-card">
                <div class="stat-label">Punks Sold</div>
                <div class="stat-value" id="fePunksSold">Loading...</div>
              </div>
            </div>
            <div class="col-md-3">
              <div class="stat-card">
                <div class="stat-label">Currently Listed</div>
                <div class="stat-value" id="feCurrentlyListed">Loading...</div>
              </div>
            </div>
            <div class="col-md-3">
              <div class="stat-card">
                <div class="stat-label">Listings Value</div>
                <div class="stat-value" id="feListingsValue">Loading...</div>
              </div>
            </div>
          </div>

          <!-- $ADRIAN Token Statistics Section -->
          <div class="section-header">
            <h2><i class="bi bi-currency-exchange"></i> $ADRIAN Token Statistics</h2>
          </div>
          <div id="tokenStats" class="row g-3 mb-4">
            <div class="col-md-3">
              <div class="stat-card">
                <div class="stat-label">Total Supply</div>
                <div class="stat-value" id="tokenTotalSupply">Loading...</div>
                <div class="stat-subtitle">Minted - Burned</div>
              </div>
            </div>
            <div class="col-md-3">
              <div class="stat-card">
                <div class="stat-label">Circulating Supply</div>
                <div class="stat-value" id="tokenCirculatingSupply">Loading...</div>
                <div class="stat-subtitle">In wallets</div>
              </div>
            </div>
            <div class="col-md-3">
              <div class="stat-card">
                <div class="stat-label">Total Holders</div>
                <div class="stat-value" id="tokenTotalHolders">Loading...</div>
                <div class="stat-subtitle">Unique addresses</div>
              </div>
            </div>
            <div class="col-md-3">
              <div class="stat-card">
                <div class="stat-label">24h Volume</div>
                <div class="stat-value" id="token24hVolume">Loading...</div>
                <div class="stat-subtitle">Last 24 hours</div>
              </div>
            </div>
            <div class="col-md-3">
              <div class="stat-card">
                <div class="stat-label">24h Transactions</div>
                <div class="stat-value" id="token24hTransactions">Loading...</div>
                <div class="stat-subtitle">Last 24 hours</div>
              </div>
            </div>
            <div class="col-md-3">
              <div class="stat-card">
                <div class="stat-label">Total Staked</div>
                <div class="stat-value" id="tokenTotalStaked">Loading...</div>
                <div class="stat-subtitle">Active stakes</div>
              </div>
            </div>
            <div class="col-md-3">
              <div class="stat-card">
                <div class="stat-label">Total Rewards</div>
                <div class="stat-value" id="tokenTotalRewards">Loading...</div>
                <div class="stat-subtitle">Distributed</div>
              </div>
            </div>
            <div class="col-md-3">
              <div class="stat-card">
                <div class="stat-label">Total Transfers</div>
                <div class="stat-value" id="tokenTotalTransfers">Loading...</div>
                <div class="stat-subtitle">All time</div>
              </div>
            </div>
          </div>

          <!-- Top Holders Section -->
          <div class="section-header">
            <h2><i class="bi bi-trophy"></i> Top Holders</h2>
          </div>
          <div class="card mb-5">
            <div class="card-body">
              <div id="topHoldersTable" class="loading-spinner">
                <div class="spinner-border" role="status">
                  <span class="visually-hidden">Loading...</span>
                </div>
              </div>
            </div>
          </div>

          <!-- AdrianLABCore Statistics Section -->
          <div class="section-header">
            <h2><i class="bi bi-palette"></i> AdrianLABCore (AdrianZERO) Statistics</h2>
          </div>
          <div id="adrianlabcoreStats" class="row g-3 mb-4">
            <div class="col-md-3">
              <div class="stat-card">
                <div class="stat-label">Total Supply</div>
                <div class="stat-value" id="alcTotalSupply">Loading...</div>
                <div class="stat-subtitle">Minted - Burned</div>
              </div>
            </div>
            <div class="col-md-3">
              <div class="stat-card">
                <div class="stat-label">Total Minted</div>
                <div class="stat-value" id="alcTotalMinted">Loading...</div>
                <div class="stat-subtitle">All time</div>
              </div>
            </div>
            <div class="col-md-3">
              <div class="stat-card">
                <div class="stat-label">Total Burned</div>
                <div class="stat-value" id="alcTotalBurned">Loading...</div>
                <div class="stat-subtitle">All time</div>
              </div>
            </div>
            <div class="col-md-3">
              <div class="stat-card">
                <div class="stat-label">Unique Holders</div>
                <div class="stat-value" id="alcUniqueHolders">Loading...</div>
                <div class="stat-subtitle">Addresses</div>
              </div>
            </div>
            <div class="col-md-3">
              <div class="stat-card">
                <div class="stat-label">Total Transfers</div>
                <div class="stat-value" id="alcTotalTransfers">Loading...</div>
                <div class="stat-subtitle">All time</div>
              </div>
            </div>
            <div class="col-md-3">
              <div class="stat-card">
                <div class="stat-label">Skins Assigned</div>
                <div class="stat-value" id="alcSkinsAssigned">Loading...</div>
                <div class="stat-subtitle">Total assignments</div>
              </div>
            </div>
            <div class="col-md-3">
              <div class="stat-card">
                <div class="stat-label">Tokens Mutated</div>
                <div class="stat-value" id="alcTokensMutated">Loading...</div>
                <div class="stat-subtitle">With mutations</div>
              </div>
            </div>
            <div class="col-md-3">
              <div class="stat-card">
                <div class="stat-label">Serums Applied</div>
                <div class="stat-value" id="alcSerumsApplied">Loading...</div>
                <div class="stat-subtitle">Total serums</div>
              </div>
            </div>
          </div>

          <!-- ERC1155 (AdrianLAB) Statistics Section -->
          <div class="section-header">
            <h2><i class="bi bi-box"></i> AdrianLAB (ERC1155) Statistics</h2>
          </div>
          <div id="erc1155Stats" class="row g-3 mb-4">
            <div class="col-md-3">
              <div class="stat-card">
                <div class="stat-label">Total Assets Minted</div>
                <div class="stat-value" id="erc1155TotalMinted">Loading...</div>
                <div class="stat-subtitle">All time</div>
              </div>
            </div>
            <div class="col-md-3">
              <div class="stat-card">
                <div class="stat-label">Total Transfers</div>
                <div class="stat-value" id="erc1155TotalTransfers">Loading...</div>
                <div class="stat-subtitle">All time</div>
              </div>
            </div>
            <div class="col-md-3">
              <div class="stat-card">
                <div class="stat-label">Unique Holders</div>
                <div class="stat-value" id="erc1155UniqueHolders">Loading...</div>
                <div class="stat-subtitle">Addresses</div>
              </div>
            </div>
            <div class="col-md-3">
              <div class="stat-card">
                <div class="stat-label">Asset Types</div>
                <div class="stat-value" id="erc1155AssetTypes">Loading...</div>
                <div class="stat-subtitle">Different types</div>
              </div>
            </div>
          </div>

          <!-- TraitsExtensions Statistics Section -->
          <div class="section-header">
            <h2><i class="bi bi-puzzle"></i> TraitsExtensions Statistics</h2>
          </div>
          <div id="traitsExtensionsStats" class="row g-3 mb-4">
            <div class="col-md-3">
              <div class="stat-card">
                <div class="stat-label">Traits Applied</div>
                <div class="stat-value" id="traitsTotalApplied">Loading...</div>
                <div class="stat-subtitle">All time</div>
              </div>
            </div>
            <div class="col-md-3">
              <div class="stat-card">
                <div class="stat-label">Assets Added</div>
                <div class="stat-value" id="traitsAssetsAdded">Loading...</div>
                <div class="stat-subtitle">To inventory</div>
              </div>
            </div>
            <div class="col-md-3">
              <div class="stat-card">
                <div class="stat-label">Trait Types</div>
                <div class="stat-value" id="traitsTraitTypes">Loading...</div>
                <div class="stat-subtitle">Different types</div>
              </div>
            </div>
            <div class="col-md-3">
              <div class="stat-card">
                <div class="stat-label">Total Events</div>
                <div class="stat-value" id="traitsTotalEvents">Loading...</div>
                <div class="stat-subtitle">All time</div>
              </div>
            </div>
          </div>

          <!-- AdrianShop Statistics Section -->
          <div class="section-header">
            <h2><i class="bi bi-cart"></i> AdrianShop Statistics</h2>
          </div>
          <div id="adrianShopStats" class="row g-3 mb-4">
            <div class="col-md-3">
              <div class="stat-card">
                <div class="stat-label">Total Purchases</div>
                <div class="stat-value" id="shopTotalPurchases">Loading...</div>
                <div class="stat-subtitle">All time</div>
              </div>
            </div>
            <div class="col-md-3">
              <div class="stat-card">
                <div class="stat-label">Total Revenue</div>
                <div class="stat-value" id="shopTotalRevenue">Loading...</div>
                <div class="stat-subtitle">$ADRIAN</div>
              </div>
            </div>
            <div class="col-md-3">
              <div class="stat-card">
                <div class="stat-label">Unique Buyers</div>
                <div class="stat-value" id="shopUniqueBuyers">Loading...</div>
                <div class="stat-subtitle">Addresses</div>
              </div>
            </div>
            <div class="col-md-3">
              <div class="stat-card">
                <div class="stat-label">Items Sold</div>
                <div class="stat-value" id="shopItemsSold">Loading...</div>
                <div class="stat-subtitle">Total quantity</div>
              </div>
            </div>
          </div>

          <!-- AdrianNameRegistry Statistics Section -->
          <div class="section-header">
            <h2><i class="bi bi-tag"></i> AdrianNameRegistry Statistics</h2>
          </div>
          <div id="nameRegistryStats" class="row g-3 mb-4">
            <div class="col-md-3">
              <div class="stat-card">
                <div class="stat-label">Total Names</div>
                <div class="stat-value" id="nameRegistryTotalNames">Loading...</div>
                <div class="stat-subtitle">All time</div>
              </div>
            </div>
            <div class="col-md-3">
              <div class="stat-card">
                <div class="stat-label">Tokens with Names</div>
                <div class="stat-value" id="nameRegistryTokensWithNames">Loading...</div>
                <div class="stat-subtitle">Unique tokens</div>
              </div>
            </div>
            <div class="col-md-3">
              <div class="stat-card">
                <div class="stat-label">Paid Names</div>
                <div class="stat-value" id="nameRegistryPaidNames">Loading...</div>
                <div class="stat-subtitle">Revenue generated</div>
              </div>
            </div>
            <div class="col-md-3">
              <div class="stat-card">
                <div class="stat-label">Total Revenue</div>
                <div class="stat-value" id="nameRegistryTotalRevenue">Loading...</div>
                <div class="stat-subtitle">$ADRIAN</div>
              </div>
            </div>
          </div>

          <!-- AdrianSerumModule Statistics Section -->
          <div class="section-header">
            <h2><i class="bi bi-flask"></i> AdrianSerumModule Statistics</h2>
          </div>
          <div id="serumModuleStats" class="row g-3 mb-4">
            <div class="col-md-3">
              <div class="stat-card">
                <div class="stat-label">Total Applications</div>
                <div class="stat-value" id="serumModuleTotalApplications">Loading...</div>
                <div class="stat-subtitle">All time</div>
              </div>
            </div>
            <div class="col-md-3">
              <div class="stat-card">
                <div class="stat-label">Success Rate</div>
                <div class="stat-value" id="serumModuleSuccessRate">Loading...</div>
                <div class="stat-subtitle">Percentage</div>
              </div>
            </div>
            <div class="col-md-3">
              <div class="stat-card">
                <div class="stat-label">Successful</div>
                <div class="stat-value" id="serumModuleSuccessful">Loading...</div>
                <div class="stat-subtitle">Applications</div>
              </div>
            </div>
            <div class="col-md-3">
              <div class="stat-card">
                <div class="stat-label">Failed</div>
                <div class="stat-value" id="serumModuleFailed">Loading...</div>
                <div class="stat-subtitle">Applications</div>
              </div>
            </div>
          </div>

          <!-- PunkQuest Statistics Section -->
          <div class="section-header">
            <h2><i class="bi bi-sword"></i> PunkQuest Statistics</h2>
          </div>
          <div id="punkQuestStats" class="row g-3 mb-4">
            <div class="col-md-3">
              <div class="stat-card">
                <div class="stat-label">Total Stakes</div>
                <div class="stat-value" id="punkQuestTotalStakes">Loading...</div>
                <div class="stat-subtitle">All time</div>
              </div>
            </div>
            <div class="col-md-3">
              <div class="stat-card">
                <div class="stat-label">Currently Staked</div>
                <div class="stat-value" id="punkQuestCurrentlyStaked">Loading...</div>
                <div class="stat-subtitle">Tokens</div>
              </div>
            </div>
            <div class="col-md-3">
              <div class="stat-card">
                <div class="stat-label">Total Rewards</div>
                <div class="stat-value" id="punkQuestTotalRewards">Loading...</div>
                <div class="stat-subtitle">$ADRIAN</div>
              </div>
            </div>
            <div class="col-md-3">
              <div class="stat-card">
                <div class="stat-label">Items Purchased</div>
                <div class="stat-value" id="punkQuestItemsPurchased">Loading...</div>
                <div class="stat-subtitle">Total quantity</div>
              </div>
            </div>
          </div>
        </div> <!-- End Stats Tab -->
      </div> <!-- End Tab Content -->
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
  <script>
    // ============================================
    // CONFIGURATION
    // ============================================
    const SUPABASE_URL = window.SUPABASE_URL || 'YOUR_SUPABASE_URL';
    const SUPABASE_ANON_KEY = window.SUPABASE_ANON_KEY || 'YOUR_SUPABASE_ANON_KEY';
    
    const PAGE_SIZE = 30; // Items por p√°gina
    const MAX_ITEMS_IN_DOM = 100; // M√°ximo de items en el DOM (limpieza autom√°tica)
    
    // Contract addresses
    const FLOOR_ENGINE_ADDRESS = '0x0351F7cBA83277E891D4a85Da498A7eACD764D58';
    const ERC20_ADDRESS = '0x7E99075Ce287F1cF8cBCAaa6A1C7894e404fD7Ea';
    const ADRIANLABCORE_ADDRESS = '0x6e369bf0e4e0c106192d606fb6d85836d684da75';
    const ERC1155_ADDRESS = '0x90546848474fb3c9fda3fdad887969bb244e7e58';
    const TRAITS_EXTENSIONS_ADDRESS = '0x0995c0dA1ca071b792E852b6Ec531b7cD7d1F8D6';
    const ADRIAN_SHOP_ADDRESS = '0x4b265927b1521995ce416bba3bed98231d2e946b';

    // ============================================
    // STATE
    // ============================================
    let supabaseClient = null;
    let currentPage = 0;
    let hasMore = true;
    let isLoading = false;
    let allLoadedEvents = []; // Todos los eventos cargados
    let displayedEvents = []; // Eventos mostrados actualmente
    let addressTagsRules = {};
    let imageRules = {};
    let eventRules = {};
    let intersectionObserver = null;

    // Filters
    const filters = {
      contract: 'all',
      eventType: 'all',
      dateFrom: null,
      dateTo: null,
      address: null
    };

    // ============================================
    // INITIALIZATION
    // ============================================
    async function init() {
      console.log('üöÄ Inicializando aplicaci√≥n...');
      
      // Inicializar Supabase
      if (SUPABASE_URL && SUPABASE_ANON_KEY && SUPABASE_URL !== 'YOUR_SUPABASE_URL') {
        supabaseClient = supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
        console.log('‚úÖ Supabase inicializado');
      } else {
        console.error('‚ùå Credenciales de Supabase no configuradas');
        showError('Error: Credenciales de Supabase no configuradas');
        return;
      }

      // Cargar reglas
      await loadRules();

      // Cargar primera p√°gina
      await loadFirstPage();
      
      // Setup scroll infinito
      setupInfiniteScroll();
      
      // Cargar estad√≠sticas
      await loadAllStats();
    }
    
    // ============================================
    // STATISTICS LOADING
    // ============================================
    async function loadAllStats() {
      if (!supabaseClient) return;
      
      try {
        await Promise.all([
          loadFloorEngineStats(),
          loadTokenStats(),
          loadAdrianLABCoreStats(),
          loadERC1155Stats(),
          loadTraitsExtensionsStats(),
          loadAdrianShopStats(),
          loadAdrianNameRegistryStats(),
          loadAdrianSerumModuleStats(),
          loadPunkQuestStats()
        ]);
      } catch (error) {
        console.error('Error loading stats:', error);
      }
    }
    
    function formatWeiString(weiValue) {
      let weiStr = String(weiValue);
      if (weiStr.includes('e') || weiStr.includes('E')) {
        const num = parseFloat(weiStr);
        weiStr = num.toLocaleString('fullwide', { useGrouping: false, maximumFractionDigits: 0 });
      }
      weiStr = weiStr.replace(/,/g, '');
      return weiStr;
    }
    
    async function loadFloorEngineStats() {
      if (!supabaseClient) return;
      try {
        const { data: sweeps } = await supabaseClient.from('sweep_events').select('buy_price_wei');
        let totalInvested = ethers.BigNumber.from(0);
        if (sweeps) {
          sweeps.forEach(sweep => {
            try {
              const buyPrice = formatWeiString(sweep.buy_price_wei);
              totalInvested = totalInvested.add(ethers.BigNumber.from(buyPrice));
            } catch (e) {}
          });
        }
        const { data: trades } = await supabaseClient.from('trade_events').select('price_wei, is_contract_owned');
        let totalEarned = ethers.BigNumber.from(0);
        let punksSold = 0;
        if (trades) {
          trades.forEach(trade => {
            if (trade.is_contract_owned) {
              try {
                const price = formatWeiString(trade.price_wei);
                totalEarned = totalEarned.add(ethers.BigNumber.from(price));
                punksSold++;
              } catch (e) {}
            }
          });
        }
        const punksBought = sweeps ? sweeps.length : 0;
        const { data: listings } = await supabaseClient.from('punk_listings').select('price_wei').eq('is_contract_owned', true).eq('is_listed', true);
        let currentlyListed = 0;
        let listingsValue = ethers.BigNumber.from(0);
        if (listings) {
          currentlyListed = listings.length;
          listings.forEach(listing => {
            try {
              const price = formatWeiString(listing.price_wei);
              listingsValue = listingsValue.add(ethers.BigNumber.from(price));
            } catch (e) {}
          });
        }
        const netProfit = totalEarned.sub(totalInvested);
        const roi = totalInvested.gt(0) ? netProfit.mul(10000).div(totalInvested).toNumber() / 100 : 0;
        document.getElementById('feTotalInvested').textContent = formatADRIAN(totalInvested.toString()) + ' $ADRIAN';
        document.getElementById('feTotalEarned').textContent = formatADRIAN(totalEarned.toString()) + ' $ADRIAN';
        const netProfitEl = document.getElementById('feNetProfit');
        netProfitEl.textContent = formatADRIAN(netProfit.toString()) + ' $ADRIAN';
        netProfitEl.className = 'stat-value ' + (netProfit.gte(0) ? 'positive' : 'negative');
        const roiEl = document.getElementById('feROI');
        roiEl.textContent = roi.toFixed(2) + '%';
        roiEl.className = 'stat-value ' + (roi >= 0 ? 'positive' : 'negative');
        document.getElementById('fePunksBought').textContent = punksBought;
        document.getElementById('fePunksSold').textContent = punksSold;
        document.getElementById('feCurrentlyListed').textContent = currentlyListed;
        document.getElementById('feListingsValue').textContent = formatADRIAN(listingsValue.toString()) + ' $ADRIAN';
      } catch (error) {
        console.error('Error loading FloorEngine stats:', error);
      }
    }
    
    async function loadTokenStats() {
      if (!supabaseClient) return;
      try {
        const BURN_ADDRESS = '0x0000000000000000000000000000000000000000';
        const { data: mints } = await supabaseClient.from('erc20_transfers').select('value_wei').eq('contract_address', ERC20_ADDRESS.toLowerCase()).eq('from_address', BURN_ADDRESS.toLowerCase());
        let totalMinted = ethers.BigNumber.from(0);
        if (mints) {
          mints.forEach(mint => {
            try {
              const value = formatWeiString(mint.value_wei);
              totalMinted = totalMinted.add(ethers.BigNumber.from(value));
            } catch (e) {}
          });
        }
        const { data: burns } = await supabaseClient.from('erc20_transfers').select('value_wei').eq('contract_address', ERC20_ADDRESS.toLowerCase()).eq('to_address', BURN_ADDRESS.toLowerCase());
        let totalBurned = ethers.BigNumber.from(0);
        if (burns) {
          burns.forEach(burn => {
            try {
              const value = formatWeiString(burn.value_wei);
              totalBurned = totalBurned.add(ethers.BigNumber.from(value));
            } catch (e) {}
          });
        }
        const totalSupply = totalMinted.sub(totalBurned);
        const yesterday = new Date();
        yesterday.setDate(yesterday.getDate() - 1);
        const { data: transfers24h } = await supabaseClient.from('erc20_transfers').select('value_wei').eq('contract_address', ERC20_ADDRESS.toLowerCase()).gte('created_at', yesterday.toISOString());
        let volume24h = ethers.BigNumber.from(0);
        let transactions24h = 0;
        if (transfers24h) {
          transactions24h = transfers24h.length;
          transfers24h.forEach(transfer => {
            try {
              const value = formatWeiString(transfer.value_wei);
              volume24h = volume24h.add(ethers.BigNumber.from(value));
            } catch (e) {}
          });
        }
        const { data: received } = await supabaseClient.from('erc20_transfers').select('to_address, value_wei').eq('contract_address', ERC20_ADDRESS.toLowerCase()).neq('to_address', BURN_ADDRESS.toLowerCase());
        const { data: sent } = await supabaseClient.from('erc20_transfers').select('from_address, value_wei').eq('contract_address', ERC20_ADDRESS.toLowerCase()).neq('from_address', BURN_ADDRESS.toLowerCase());
        const balances = new Map();
        if (received) {
          received.forEach(transfer => {
            try {
              const value = formatWeiString(transfer.value_wei);
              const amount = ethers.BigNumber.from(value);
              const current = balances.get(transfer.to_address) || ethers.BigNumber.from(0);
              balances.set(transfer.to_address, current.add(amount));
            } catch (e) {}
          });
        }
        if (sent) {
          sent.forEach(transfer => {
            try {
              const value = formatWeiString(transfer.value_wei);
              const amount = ethers.BigNumber.from(value);
              const current = balances.get(transfer.from_address) || ethers.BigNumber.from(0);
              balances.set(transfer.from_address, current.sub(amount));
            } catch (e) {}
          });
        }
        const positiveBalances = Array.from(balances.entries()).filter(([address, balance]) => balance.gt(0));
        const totalHolders = positiveBalances.length;
        const circulatingSupply = positiveBalances.reduce((sum, [address, balance]) => sum.add(balance), ethers.BigNumber.from(0));
        const { data: stakes } = await supabaseClient.from('erc20_custom_events').select('event_data').eq('contract_address', ERC20_ADDRESS.toLowerCase()).eq('event_name', 'Staked');
        let totalStaked = ethers.BigNumber.from(0);
        if (stakes) {
          stakes.forEach(stake => {
            try {
              const amount = stake.event_data?.amount;
              if (amount) {
                const value = formatWeiString(amount);
                totalStaked = totalStaked.add(ethers.BigNumber.from(value));
              }
            } catch (e) {}
          });
        }
        const { data: withdrawals } = await supabaseClient.from('erc20_custom_events').select('event_data').eq('contract_address', ERC20_ADDRESS.toLowerCase()).eq('event_name', 'WithdrawnStake');
        let totalRewards = ethers.BigNumber.from(0);
        if (withdrawals) {
          withdrawals.forEach(withdrawal => {
            try {
              const reward = withdrawal.event_data?.reward;
              if (reward) {
                const value = formatWeiString(reward);
                totalRewards = totalRewards.add(ethers.BigNumber.from(value));
              }
            } catch (e) {}
          });
        }
        const { count: totalTransfers } = await supabaseClient.from('erc20_transfers').select('*', { count: 'exact', head: true }).eq('contract_address', ERC20_ADDRESS.toLowerCase());
        document.getElementById('tokenTotalSupply').textContent = formatADRIAN(totalSupply.toString()) + ' $ADRIAN';
        document.getElementById('tokenCirculatingSupply').textContent = formatADRIAN(circulatingSupply.toString()) + ' $ADRIAN';
        document.getElementById('tokenTotalHolders').textContent = totalHolders.toLocaleString();
        document.getElementById('token24hVolume').textContent = formatADRIAN(volume24h.toString()) + ' $ADRIAN';
        document.getElementById('token24hTransactions').textContent = transactions24h.toLocaleString();
        document.getElementById('tokenTotalStaked').textContent = formatADRIAN(totalStaked.toString()) + ' $ADRIAN';
        document.getElementById('tokenTotalRewards').textContent = formatADRIAN(totalRewards.toString()) + ' $ADRIAN';
        document.getElementById('tokenTotalTransfers').textContent = (totalTransfers || 0).toLocaleString();
        const holdersMap = new Map();
        positiveBalances.forEach(([address, balance]) => {
          holdersMap.set(address, balance);
        });
        loadTopHolders(holdersMap);
      } catch (error) {
        console.error('Error loading token stats:', error);
      }
    }
    
    async function loadTopHolders(holdersMap) {
      if (!supabaseClient) return;
      try {
        const sorted = Array.from(holdersMap.entries())
          .sort((a, b) => b[1].sub(a[1]).gt(0) ? 1 : -1)
          .slice(0, 10);
        const table = document.getElementById('topHoldersTable');
        if (table) {
          let html = '<table class="table table-striped"><thead><tr><th>Rank</th><th>Address</th><th>Balance</th></tr></thead><tbody>';
          sorted.forEach(([address, balance], index) => {
            html += `<tr><td>${index + 1}</td><td>${shortAddress(address)}</td><td>${formatADRIAN(balance.toString())} $ADRIAN</td></tr>`;
          });
          html += '</tbody></table>';
          table.innerHTML = html;
        }
      } catch (error) {
        console.error('Error loading top holders:', error);
      }
    }
    
    async function loadAdrianLABCoreStats() {
      if (!supabaseClient) return;
      try {
        const { data: mints } = await supabaseClient.from('erc721_custom_events').select('*').eq('contract_address', ADRIANLABCORE_ADDRESS).eq('event_name', 'TokenMinted');
        const totalMinted = mints ? mints.length : 0;
        const { data: burns } = await supabaseClient.from('erc721_custom_events').select('*').eq('contract_address', ADRIANLABCORE_ADDRESS).eq('event_name', 'TokenBurnt');
        const totalBurned = burns ? burns.length : 0;
        const totalSupply = totalMinted - totalBurned;
        const { data: transfers } = await supabaseClient.from('erc721_transfers').select('to_address').eq('contract_address', ADRIANLABCORE_ADDRESS);
        const uniqueHolders = transfers ? new Set(transfers.map(t => t.to_address)).size : 0;
        const { count: totalTransfers } = await supabaseClient.from('erc721_transfers').select('*', { count: 'exact', head: true }).eq('contract_address', ADRIANLABCORE_ADDRESS);
        const { data: skins } = await supabaseClient.from('erc721_custom_events').select('*').eq('contract_address', ADRIANLABCORE_ADDRESS).eq('event_name', 'SkinAssigned');
        const skinsAssigned = skins ? skins.length : 0;
        const { data: mutations } = await supabaseClient.from('erc721_custom_events').select('*').eq('contract_address', ADRIANLABCORE_ADDRESS).eq('event_name', 'MutationNameAssigned');
        const tokensMutated = mutations ? mutations.length : 0;
        const { data: serums } = await supabaseClient.from('erc721_custom_events').select('*').eq('contract_address', ADRIANLABCORE_ADDRESS).eq('event_name', 'SerumApplied');
        const serumsApplied = serums ? serums.length : 0;
        document.getElementById('alcTotalSupply').textContent = totalSupply.toLocaleString();
        document.getElementById('alcTotalMinted').textContent = totalMinted.toLocaleString();
        document.getElementById('alcTotalBurned').textContent = totalBurned.toLocaleString();
        document.getElementById('alcUniqueHolders').textContent = uniqueHolders.toLocaleString();
        document.getElementById('alcTotalTransfers').textContent = (totalTransfers || 0).toLocaleString();
        document.getElementById('alcSkinsAssigned').textContent = skinsAssigned.toLocaleString();
        document.getElementById('alcTokensMutated').textContent = tokensMutated.toLocaleString();
        document.getElementById('alcSerumsApplied').textContent = serumsApplied.toLocaleString();
      } catch (error) {
        console.error('Error loading AdrianLABCore stats:', error);
      }
    }
    
    async function loadERC1155Stats() {
      if (!supabaseClient) return;
      try {
        const { data: mints } = await supabaseClient.from('erc1155_custom_events').select('event_data').eq('contract_address', ERC1155_ADDRESS).eq('event_name', 'AssetMinted');
        let totalMinted = 0;
        if (mints) {
          totalMinted = mints.reduce((sum, mint) => {
            const amount = parseInt(mint.event_data?.amount || '0', 10);
            return sum + (isNaN(amount) ? 0 : amount);
          }, 0);
        }
        const { count: totalTransfers } = await supabaseClient.from('erc1155_transfers_single').select('*', { count: 'exact', head: true }).eq('contract_address', ERC1155_ADDRESS);
        const { data: allTransfers } = await supabaseClient.from('erc1155_transfers_single').select('to_address').eq('contract_address', ERC1155_ADDRESS);
        const uniqueHolders = allTransfers ? new Set(allTransfers.map(t => t.to_address)).size : 0;
        const { data: assetTypes } = await supabaseClient.from('erc1155_custom_events').select('event_data').eq('contract_address', ERC1155_ADDRESS).eq('event_name', 'AssetMinted');
        const assetTypesCount = assetTypes ? new Set(assetTypes.map(a => a.event_data?.assetType || 'unknown')).size : 0;
        document.getElementById('erc1155TotalMinted').textContent = totalMinted.toLocaleString();
        document.getElementById('erc1155TotalTransfers').textContent = (totalTransfers || 0).toLocaleString();
        document.getElementById('erc1155UniqueHolders').textContent = uniqueHolders.toLocaleString();
        document.getElementById('erc1155AssetTypes').textContent = assetTypesCount.toLocaleString();
      } catch (error) {
        console.error('Error loading ERC1155 stats:', error);
      }
    }
    
    async function loadTraitsExtensionsStats() {
      if (!supabaseClient) return;
      try {
        const { data: traitsApplied } = await supabaseClient.from('traits_extensions_events').select('*').eq('contract_address', TRAITS_EXTENSIONS_ADDRESS.toLowerCase()).eq('event_name', 'TraitApplied');
        const totalApplied = traitsApplied ? traitsApplied.length : 0;
        const { data: assetsAdded } = await supabaseClient.from('traits_extensions_events').select('event_data').eq('contract_address', TRAITS_EXTENSIONS_ADDRESS.toLowerCase()).eq('event_name', 'AssetAddedToInventory');
        let totalAssetsAdded = 0;
        if (assetsAdded) {
          totalAssetsAdded = assetsAdded.reduce((sum, asset) => {
            const amount = parseInt(asset.event_data?.amount || '0', 10);
            return sum + (isNaN(amount) ? 0 : amount);
          }, 0);
        }
        const { data: traitTypes } = await supabaseClient.from('traits_extensions_events').select('event_data').eq('contract_address', TRAITS_EXTENSIONS_ADDRESS.toLowerCase()).eq('event_name', 'TraitApplied');
        const traitTypesCount = traitTypes ? new Set(traitTypes.map(t => t.event_data?.traitId || 'unknown')).size : 0;
        const { count: totalEvents } = await supabaseClient.from('traits_extensions_events').select('*', { count: 'exact', head: true }).eq('contract_address', TRAITS_EXTENSIONS_ADDRESS.toLowerCase());
        document.getElementById('traitsTotalApplied').textContent = totalApplied.toLocaleString();
        document.getElementById('traitsAssetsAdded').textContent = totalAssetsAdded.toLocaleString();
        document.getElementById('traitsTraitTypes').textContent = traitTypesCount.toLocaleString();
        document.getElementById('traitsTotalEvents').textContent = (totalEvents || 0).toLocaleString();
      } catch (error) {
        console.error('Error loading TraitsExtensions stats:', error);
      }
    }
    
    async function loadAdrianShopStats() {
      if (!supabaseClient) return;
      try {
        const { data: purchases } = await supabaseClient.from('shop_events').select('*').eq('contract_address', ADRIAN_SHOP_ADDRESS).in('event_name', ['ItemPurchased', 'BatchPurchase']);
        const totalPurchases = purchases ? purchases.length : 0;
        let totalRevenue = ethers.BigNumber.from(0);
        if (purchases) {
          purchases.forEach(purchase => {
            const cost = purchase.event_data?.totalCost;
            if (cost) {
              try {
                const value = formatWeiString(cost);
                totalRevenue = totalRevenue.add(ethers.BigNumber.from(value));
              } catch (e) {}
            }
          });
        }
        const uniqueBuyers = purchases ? new Set(purchases.map(p => p.event_data?.buyer)).size : 0;
        let itemsSold = 0;
        if (purchases) {
          purchases.forEach(purchase => {
            const amount = parseInt(purchase.event_data?.amount || '0', 10);
            itemsSold += isNaN(amount) ? 0 : amount;
          });
        }
        document.getElementById('shopTotalPurchases').textContent = totalPurchases.toLocaleString();
        document.getElementById('shopTotalRevenue').textContent = formatADRIAN(totalRevenue.toString()) + ' $ADRIAN';
        document.getElementById('shopUniqueBuyers').textContent = uniqueBuyers.toLocaleString();
        document.getElementById('shopItemsSold').textContent = itemsSold.toLocaleString();
      } catch (error) {
        console.error('Error loading AdrianShop stats:', error);
      }
    }
    
    async function loadAdrianNameRegistryStats() {
      if (!supabaseClient) return;
      try {
        // Placeholder - implementar cuando est√© disponible la tabla
        document.getElementById('nameRegistryTotalNames').textContent = 'N/A';
        document.getElementById('nameRegistryTokensWithNames').textContent = 'N/A';
        document.getElementById('nameRegistryPaidNames').textContent = 'N/A';
        document.getElementById('nameRegistryTotalRevenue').textContent = 'N/A';
      } catch (error) {
        console.error('Error loading AdrianNameRegistry stats:', error);
      }
    }
    
    async function loadAdrianSerumModuleStats() {
      if (!supabaseClient) return;
      try {
        // Placeholder - implementar cuando est√© disponible la tabla
        document.getElementById('serumModuleTotalApplications').textContent = 'N/A';
        document.getElementById('serumModuleSuccessRate').textContent = 'N/A';
        document.getElementById('serumModuleSuccessful').textContent = 'N/A';
        document.getElementById('serumModuleFailed').textContent = 'N/A';
      } catch (error) {
        console.error('Error loading AdrianSerumModule stats:', error);
      }
    }
    
    async function loadPunkQuestStats() {
      if (!supabaseClient) return;
      try {
        // Placeholder - implementar cuando est√© disponible la tabla
        document.getElementById('punkQuestTotalStakes').textContent = 'N/A';
        document.getElementById('punkQuestCurrentlyStaked').textContent = 'N/A';
        document.getElementById('punkQuestTotalRewards').textContent = 'N/A';
        document.getElementById('punkQuestItemsPurchased').textContent = 'N/A';
      } catch (error) {
        console.error('Error loading PunkQuest stats:', error);
      }
    }

    // ============================================
    // RULES LOADING
    // ============================================
    async function loadRules() {
      try {
        // Address tags
        const tagsResponse = await fetch('./rules/address-tags.json');
        if (tagsResponse.ok) {
          const data = await tagsResponse.json();
          addressTagsRules = data.addressTags || {};
        }

        // Image rules
        const imagesResponse = await fetch('./rules/image-rules.json');
        if (imagesResponse.ok) {
          const data = await imagesResponse.json();
          imageRules = data.imageRules || {};
        }

        // Event rules
        const eventsResponse = await fetch('./rules/event-rules.json');
        if (eventsResponse.ok) {
          const data = await eventsResponse.json();
          eventRules = data.eventRules || {};
        }
      } catch (error) {
        console.error('Error cargando reglas:', error);
      }
    }

    // ============================================
    // DATA LOADING
    // ============================================
    async function loadFirstPage() {
      if (isLoading) return;
      
      currentPage = 0;
      hasMore = true;
      allLoadedEvents = [];
      displayedEvents = [];
      
      showLoading();
      await loadMore();
    }

    async function loadMore() {
      if (isLoading || !hasMore) return;
      
      isLoading = true;

      try {
        const pageSize = PAGE_SIZE;
        const offset = currentPage * pageSize;
        const newEvents = await fetchEvents(offset, pageSize);
        
        if (newEvents.length === 0) {
          hasMore = false;
        } else {
          allLoadedEvents = allLoadedEvents.concat(newEvents);
          currentPage++;
          
          // Aplicar filtros y renderizar
          applyFiltersAndRender();
          
          // Mover sentinel al final
          moveSentinelToEnd();
        }
      } catch (error) {
        console.error('Error cargando eventos:', error);
        showError('Error cargando eventos: ' + error.message);
      } finally {
        isLoading = false;
        hideLoading();
      }
    }

    async function fetchEvents(offset, limit) {
      const events = [];
      
      // FloorEngine events
      if (filters.contract === 'all' || filters.contract === 'floorengine') {
        // Listing events
        if (filters.eventType === 'all' || filters.eventType === 'Listed' || filters.eventType === 'Cancelled') {
          let query = supabaseClient
            .from('listing_events')
            .select('*')
            .order('created_at', { ascending: false })
            .range(offset, offset + limit - 1);
          
          if (filters.eventType !== 'all') {
            query = query.eq('event_type', filters.eventType);
          }
          if (filters.dateFrom) {
            query = query.gte('created_at', filters.dateFrom + 'T00:00:00Z');
          }
          if (filters.dateTo) {
            query = query.lte('created_at', filters.dateTo + 'T23:59:59Z');
          }
          if (filters.address) {
            query = query.ilike('seller', `%${filters.address}%`);
          }
          
          const { data: listings } = await query;
          if (listings) {
            listings.forEach(event => {
              events.push({
                type: 'FloorEngine',
                eventType: event.event_type,
                data: event,
                timestamp: event.created_at
              });
            });
          }
        }

        // Trade events
        if (filters.eventType === 'all' || filters.eventType === 'Bought') {
          let query = supabaseClient
            .from('trade_events')
            .select('*')
            .order('created_at', { ascending: false })
            .range(offset, offset + limit - 1);
          
          if (filters.dateFrom) {
            query = query.gte('created_at', filters.dateFrom + 'T00:00:00Z');
          }
          if (filters.dateTo) {
            query = query.lte('created_at', filters.dateTo + 'T23:59:59Z');
          }
          if (filters.address) {
            query = query.or(`buyer.ilike.%${filters.address}%,seller.ilike.%${filters.address}%`);
          }
          
          const { data: trades } = await query;
          if (trades) {
            trades.forEach(event => {
              events.push({
                type: 'FloorEngine',
                eventType: 'Bought',
                data: event,
                timestamp: event.created_at
              });
            });
          }
        }

        // Sweep events
        if (filters.eventType === 'all' || filters.eventType === 'FloorSweep') {
          let query = supabaseClient
            .from('sweep_events')
            .select('*')
            .order('created_at', { ascending: false })
            .range(offset, offset + limit - 1);
          
          if (filters.dateFrom) {
            query = query.gte('created_at', filters.dateFrom + 'T00:00:00Z');
          }
          if (filters.dateTo) {
            query = query.lte('created_at', filters.dateTo + 'T23:59:59Z');
          }
          if (filters.address) {
            query = query.ilike('caller', `%${filters.address}%`);
          }
          
          const { data: sweeps } = await query;
          if (sweeps) {
            sweeps.forEach(event => {
              events.push({
                type: 'FloorEngine',
                eventType: 'FloorSweep',
                data: event,
                timestamp: event.created_at
              });
            });
          }
        }
      }

      // ERC20 events
      if (filters.contract === 'all' || filters.contract === 'erc20') {
        // Transfers
        if (filters.eventType === 'all' || filters.eventType === 'Transfer') {
          let query = supabaseClient
            .from('erc20_transfers')
            .select('*')
            .eq('contract_address', ERC20_ADDRESS.toLowerCase())
            .order('created_at', { ascending: false })
            .range(offset, offset + limit - 1);
          
          if (filters.dateFrom) {
            query = query.gte('created_at', filters.dateFrom + 'T00:00:00Z');
          }
          if (filters.dateTo) {
            query = query.lte('created_at', filters.dateTo + 'T23:59:59Z');
          }
          if (filters.address) {
            query = query.or(`from_address.ilike.%${filters.address}%,to_address.ilike.%${filters.address}%`);
          }
          
          const { data: transfers } = await query;
          if (transfers) {
            transfers.forEach(event => {
              events.push({
                type: 'ERC20',
                eventType: 'Transfer',
                data: event,
                timestamp: event.created_at
              });
            });
          }
        }
        
        // Approvals
        if (filters.eventType === 'all' || filters.eventType === 'Approval') {
          let query = supabaseClient
            .from('erc20_approvals')
            .select('*')
            .eq('contract_address', ERC20_ADDRESS.toLowerCase())
            .order('created_at', { ascending: false })
            .range(offset, offset + limit - 1);
          
          if (filters.dateFrom) {
            query = query.gte('created_at', filters.dateFrom + 'T00:00:00Z');
          }
          if (filters.dateTo) {
            query = query.lte('created_at', filters.dateTo + 'T23:59:59Z');
          }
          if (filters.address) {
            query = query.or(`owner.ilike.%${filters.address}%,spender.ilike.%${filters.address}%`);
          }
          
          const { data: approvals } = await query;
          if (approvals) {
            approvals.forEach(event => {
              events.push({
                type: 'ERC20',
                eventType: 'Approval',
                data: event,
                timestamp: event.created_at
              });
            });
          }
        }
        
        // Custom events
        if (filters.eventType === 'all') {
          let query = supabaseClient
            .from('erc20_custom_events')
            .select('*')
            .eq('contract_address', ERC20_ADDRESS.toLowerCase())
            .order('created_at', { ascending: false })
            .range(offset, offset + limit - 1);
          
          if (filters.dateFrom) {
            query = query.gte('created_at', filters.dateFrom + 'T00:00:00Z');
          }
          if (filters.dateTo) {
            query = query.lte('created_at', filters.dateTo + 'T23:59:59Z');
          }
          
          const { data: customs } = await query;
          if (customs) {
            customs.forEach(event => {
              events.push({
                type: 'ERC20',
                eventType: event.event_name,
                data: event,
                timestamp: event.created_at
              });
            });
          }
        } else {
          const customEventTypes = ['Staked', 'WithdrawnStake', 'TaxFeeUpdated', 'CreatorFeeUpdated', 'BurnFeeUpdated'];
          if (customEventTypes.includes(filters.eventType)) {
            let query = supabaseClient
              .from('erc20_custom_events')
              .select('*')
              .eq('contract_address', ERC20_ADDRESS.toLowerCase())
              .eq('event_name', filters.eventType)
              .order('created_at', { ascending: false })
              .range(offset, offset + limit - 1);
            
            if (filters.dateFrom) {
              query = query.gte('created_at', filters.dateFrom + 'T00:00:00Z');
            }
            if (filters.dateTo) {
              query = query.lte('created_at', filters.dateTo + 'T23:59:59Z');
            }
            
            const { data: customs } = await query;
            if (customs) {
              customs.forEach(event => {
                events.push({
                  type: 'ERC20',
                  eventType: event.event_name,
                  data: event,
                  timestamp: event.created_at
                });
              });
            }
          }
        }
      }

      // AdrianLABCore events
      if (filters.contract === 'all' || filters.contract === 'adrianlabcore') {
        // ERC721 Transfers
        if (filters.eventType === 'all' || filters.eventType === 'Transfer') {
          let query = supabaseClient
            .from('erc721_transfers')
            .select('*')
            .eq('contract_address', ADRIANLABCORE_ADDRESS)
            .order('created_at', { ascending: false })
            .range(offset, offset + limit - 1);
          
          if (filters.dateFrom) {
            query = query.gte('created_at', filters.dateFrom + 'T00:00:00Z');
          }
          if (filters.dateTo) {
            query = query.lte('created_at', filters.dateTo + 'T23:59:59Z');
          }
          if (filters.address) {
            query = query.or(`from_address.ilike.%${filters.address}%,to_address.ilike.%${filters.address}%`);
          }
          
          const { data: transfers } = await query;
          if (transfers) {
            transfers.forEach(event => {
              events.push({
                type: 'AdrianLABCore',
                eventType: 'Transfer',
                data: event,
                timestamp: event.created_at
              });
            });
          }
        }
        
        // ERC721 Approvals
        if (filters.eventType === 'all' || filters.eventType === 'Approval') {
          let query = supabaseClient
            .from('erc721_approvals')
            .select('*')
            .eq('contract_address', ADRIANLABCORE_ADDRESS)
            .order('created_at', { ascending: false })
            .range(offset, offset + limit - 1);
          
          if (filters.dateFrom) {
            query = query.gte('created_at', filters.dateFrom + 'T00:00:00Z');
          }
          if (filters.dateTo) {
            query = query.lte('created_at', filters.dateTo + 'T23:59:59Z');
          }
          if (filters.address) {
            query = query.or(`owner.ilike.%${filters.address}%,approved.ilike.%${filters.address}%`);
          }
          
          const { data: approvals } = await query;
          if (approvals) {
            approvals.forEach(event => {
              events.push({
                type: 'AdrianLABCore',
                eventType: 'Approval',
                data: event,
                timestamp: event.created_at
              });
            });
          }
        }
        
        // ERC721 ApprovalForAll
        if (filters.eventType === 'all' || filters.eventType === 'ApprovalForAll') {
          let query = supabaseClient
            .from('erc721_approvals_for_all')
            .select('*')
            .eq('contract_address', ADRIANLABCORE_ADDRESS)
            .order('created_at', { ascending: false })
            .range(offset, offset + limit - 1);
          
          if (filters.dateFrom) {
            query = query.gte('created_at', filters.dateFrom + 'T00:00:00Z');
          }
          if (filters.dateTo) {
            query = query.lte('created_at', filters.dateTo + 'T23:59:59Z');
          }
          if (filters.address) {
            query = query.or(`owner.ilike.%${filters.address}%,operator.ilike.%${filters.address}%`);
          }
          
          const { data: approvalsForAll } = await query;
          if (approvalsForAll) {
            approvalsForAll.forEach(event => {
              events.push({
                type: 'AdrianLABCore',
                eventType: 'ApprovalForAll',
                data: event,
                timestamp: event.created_at
              });
            });
          }
        }
        
        // Custom events
        if (filters.eventType === 'all') {
          let query = supabaseClient
            .from('erc721_custom_events')
            .select('*')
            .eq('contract_address', ADRIANLABCORE_ADDRESS)
            .order('created_at', { ascending: false })
            .range(offset, offset + limit - 1);
          
          if (filters.dateFrom) {
            query = query.gte('created_at', filters.dateFrom + 'T00:00:00Z');
          }
          if (filters.dateTo) {
            query = query.lte('created_at', filters.dateTo + 'T23:59:59Z');
          }
          
          const { data: customs } = await query;
          if (customs) {
            customs.forEach(event => {
              events.push({
                type: 'AdrianLABCore',
                eventType: event.event_name,
                data: event,
                timestamp: event.created_at
              });
            });
          }
        } else {
          const customEventTypes = ['TokenMinted', 'TokenBurnt', 'SkinAssigned', 'SkinCreated', 'MutationAssigned', 
                                   'MutationNameAssigned', 'SerumApplied', 'SpecialSkinApplied'];
          if (customEventTypes.includes(filters.eventType)) {
            let query = supabaseClient
              .from('erc721_custom_events')
              .select('*')
              .eq('contract_address', ADRIANLABCORE_ADDRESS)
              .eq('event_name', filters.eventType)
              .order('created_at', { ascending: false })
              .range(offset, offset + limit - 1);
            
            if (filters.dateFrom) {
              query = query.gte('created_at', filters.dateFrom + 'T00:00:00Z');
            }
            if (filters.dateTo) {
              query = query.lte('created_at', filters.dateTo + 'T23:59:59Z');
            }
            
            const { data: customs } = await query;
            if (customs) {
              customs.forEach(event => {
                events.push({
                  type: 'AdrianLABCore',
                  eventType: event.event_name,
                  data: event,
                  timestamp: event.created_at
                });
              });
            }
          }
        }
      }

      // ERC1155 events (AdrianLAB)
      if (filters.contract === 'all' || filters.contract === 'erc1155') {
        // Single transfers
        if (filters.eventType === 'all' || filters.eventType === 'TransferSingle') {
          let query = supabaseClient
            .from('erc1155_transfers_single')
            .select('*')
            .eq('contract_address', ERC1155_ADDRESS)
            .order('created_at', { ascending: false })
            .range(offset, offset + limit - 1);
          
          if (filters.dateFrom) {
            query = query.gte('created_at', filters.dateFrom + 'T00:00:00Z');
          }
          if (filters.dateTo) {
            query = query.lte('created_at', filters.dateTo + 'T23:59:59Z');
          }
          if (filters.address) {
            query = query.or(`from_address.ilike.%${filters.address}%,to_address.ilike.%${filters.address}%`);
          }
          
          const { data: transfers } = await query;
          if (transfers) {
            transfers.forEach(event => {
              const tokenIdValue = event.token_id || event.tokenId || null;
              events.push({
                type: 'ERC1155',
                eventType: 'TransferSingle',
                data: { ...event, token_id: tokenIdValue },
                timestamp: event.created_at
              });
            });
          }
        }
        
        // Batch transfers
        if (filters.eventType === 'all' || filters.eventType === 'TransferBatch') {
          let query = supabaseClient
            .from('erc1155_transfers_batch')
            .select('*')
            .eq('contract_address', ERC1155_ADDRESS)
            .order('created_at', { ascending: false })
            .range(offset, offset + limit - 1);
          
          if (filters.dateFrom) {
            query = query.gte('created_at', filters.dateFrom + 'T00:00:00Z');
          }
          if (filters.dateTo) {
            query = query.lte('created_at', filters.dateTo + 'T23:59:59Z');
          }
          if (filters.address) {
            query = query.or(`from_address.ilike.%${filters.address}%,to_address.ilike.%${filters.address}%`);
          }
          
          const { data: batchTransfers } = await query;
          if (batchTransfers) {
            batchTransfers.forEach(event => {
              const tokenIds = event.token_ids || [];
              const firstTokenId = Array.isArray(tokenIds) && tokenIds.length > 0 ? tokenIds[0] : null;
              events.push({
                type: 'ERC1155',
                eventType: 'TransferBatch',
                data: { ...event, token_id: firstTokenId, token_ids: tokenIds },
                timestamp: event.created_at
              });
            });
          }
        }
        
        // ApprovalForAll
        if (filters.eventType === 'all' || filters.eventType === 'ApprovalForAll') {
          let query = supabaseClient
            .from('erc1155_approvals_for_all')
            .select('*')
            .eq('contract_address', ERC1155_ADDRESS)
            .order('created_at', { ascending: false })
            .range(offset, offset + limit - 1);
          
          if (filters.dateFrom) {
            query = query.gte('created_at', filters.dateFrom + 'T00:00:00Z');
          }
          if (filters.dateTo) {
            query = query.lte('created_at', filters.dateTo + 'T23:59:59Z');
          }
          if (filters.address) {
            query = query.or(`owner.ilike.%${filters.address}%,operator.ilike.%${filters.address}%`);
          }
          
          const { data: approvalsForAll } = await query;
          if (approvalsForAll) {
            approvalsForAll.forEach(event => {
              events.push({
                type: 'ERC1155',
                eventType: 'ApprovalForAll',
                data: event,
                timestamp: event.created_at
              });
            });
          }
        }
        
        // URI Updates
        if (filters.eventType === 'all' || filters.eventType === 'URI') {
          let query = supabaseClient
            .from('erc1155_uri_updates')
            .select('*')
            .eq('contract_address', ERC1155_ADDRESS)
            .order('created_at', { ascending: false })
            .range(offset, offset + limit - 1);
          
          if (filters.dateFrom) {
            query = query.gte('created_at', filters.dateFrom + 'T00:00:00Z');
          }
          if (filters.dateTo) {
            query = query.lte('created_at', filters.dateTo + 'T23:59:59Z');
          }
          
          const { data: uriUpdates } = await query;
          if (uriUpdates) {
            uriUpdates.forEach(event => {
              events.push({
                type: 'ERC1155',
                eventType: 'URI',
                data: event,
                timestamp: event.created_at
              });
            });
          }
        }
        
        // Custom events
        if (filters.eventType === 'all') {
          let query = supabaseClient
            .from('erc1155_custom_events')
            .select('*')
            .eq('contract_address', ERC1155_ADDRESS)
            .order('created_at', { ascending: false })
            .range(offset, offset + limit - 1);
          
          if (filters.dateFrom) {
            query = query.gte('created_at', filters.dateFrom + 'T00:00:00Z');
          }
          if (filters.dateTo) {
            query = query.lte('created_at', filters.dateTo + 'T23:59:59Z');
          }
          
          const { data: customs } = await query;
          if (customs) {
            customs.forEach(event => {
              events.push({
                type: 'ERC1155',
                eventType: event.event_name,
                data: event,
                timestamp: event.created_at
              });
            });
          }
        } else {
          const customEventTypes = ['AssetMinted', 'AssetBurned', 'PackOpened', 'SerumUsed'];
          if (customEventTypes.includes(filters.eventType)) {
            let query = supabaseClient
              .from('erc1155_custom_events')
              .select('*')
              .eq('contract_address', ERC1155_ADDRESS)
              .eq('event_name', filters.eventType)
              .order('created_at', { ascending: false })
              .range(offset, offset + limit - 1);
            
            if (filters.dateFrom) {
              query = query.gte('created_at', filters.dateFrom + 'T00:00:00Z');
            }
            if (filters.dateTo) {
              query = query.lte('created_at', filters.dateTo + 'T23:59:59Z');
            }
            
            const { data: customs } = await query;
            if (customs) {
              customs.forEach(event => {
                events.push({
                  type: 'ERC1155',
                  eventType: event.event_name,
                  data: event,
                  timestamp: event.created_at
                });
              });
            }
          }
        }
      }

      // TraitsExtensions events
      if (filters.contract === 'all' || filters.contract === 'traitsextensions') {
        if (filters.eventType === 'all') {
          let query = supabaseClient
            .from('traits_extensions_events')
            .select('*')
            .eq('contract_address', TRAITS_EXTENSIONS_ADDRESS.toLowerCase())
            .order('created_at', { ascending: false })
            .range(offset, offset + limit - 1);
          
          if (filters.dateFrom) {
            query = query.gte('created_at', filters.dateFrom + 'T00:00:00Z');
          }
          if (filters.dateTo) {
            query = query.lte('created_at', filters.dateTo + 'T23:59:59Z');
          }
          
          const { data: customs } = await query;
          if (customs) {
            customs.forEach(event => {
              events.push({
                type: 'TraitsExtensions',
                eventType: event.event_name,
                data: event,
                timestamp: event.created_at
              });
            });
          }
        } else {
          const customEventTypes = ['TraitApplied', 'TraitsAppliedBatch', 'AssetAddedToInventory', 'TraitRemoved'];
          if (customEventTypes.includes(filters.eventType)) {
            let query = supabaseClient
              .from('traits_extensions_events')
              .select('*')
              .eq('contract_address', TRAITS_EXTENSIONS_ADDRESS.toLowerCase())
              .eq('event_name', filters.eventType)
              .order('created_at', { ascending: false })
              .range(offset, offset + limit - 1);
            
            if (filters.dateFrom) {
              query = query.gte('created_at', filters.dateFrom + 'T00:00:00Z');
            }
            if (filters.dateTo) {
              query = query.lte('created_at', filters.dateTo + 'T23:59:59Z');
            }
            
            const { data: customs } = await query;
            if (customs) {
              customs.forEach(event => {
                events.push({
                  type: 'TraitsExtensions',
                  eventType: event.event_name,
                  data: event,
                  timestamp: event.created_at
                });
              });
            }
          }
        }
      }

      // AdrianShop events
      if (filters.contract === 'all' || filters.contract === 'adrianshop') {
        if (filters.eventType === 'all') {
          let query = supabaseClient
            .from('shop_events')
            .select('*')
            .eq('contract_address', ADRIAN_SHOP_ADDRESS)
            .order('created_at', { ascending: false })
            .range(offset, offset + limit - 1);
          
          if (filters.dateFrom) {
            query = query.gte('created_at', filters.dateFrom + 'T00:00:00Z');
          }
          if (filters.dateTo) {
            query = query.lte('created_at', filters.dateTo + 'T23:59:59Z');
          }
          if (filters.address) {
            query = query.ilike('event_data->>buyer', `%${filters.address}%`);
          }
          
          const { data: shopEvents } = await query;
          if (shopEvents) {
            shopEvents.forEach(event => {
              events.push({
                type: 'AdrianShop',
                eventType: event.event_name,
                data: event,
                timestamp: event.created_at
              });
            });
          }
        } else {
          const customEventTypes = ['ItemPurchased', 'BatchPurchase', 'ItemListed', 'ItemDelisted'];
          if (customEventTypes.includes(filters.eventType)) {
            let query = supabaseClient
              .from('shop_events')
              .select('*')
              .eq('contract_address', ADRIAN_SHOP_ADDRESS)
              .eq('event_name', filters.eventType)
              .order('created_at', { ascending: false })
              .range(offset, offset + limit - 1);
            
            if (filters.dateFrom) {
              query = query.gte('created_at', filters.dateFrom + 'T00:00:00Z');
            }
            if (filters.dateTo) {
              query = query.lte('created_at', filters.dateTo + 'T23:59:59Z');
            }
            if (filters.address) {
              query = query.ilike('event_data->>buyer', `%${filters.address}%`);
            }
            
            const { data: shopEvents } = await query;
            if (shopEvents) {
              shopEvents.forEach(event => {
                events.push({
                  type: 'AdrianShop',
                  eventType: event.event_name,
                  data: event,
                  timestamp: event.created_at
                });
              });
            }
          }
        }
      }

      // Ordenar por timestamp descendente
      events.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
      
      // Limitar a pageSize
      return events.slice(0, limit);
    }

    // ============================================
    // FILTERING & RENDERING
    // ============================================
    function applyFiltersAndRender() {
      // Aplicar filtros a allLoadedEvents
      let filtered = [...allLoadedEvents];
      
      // Aplicar filtros de fecha y direcci√≥n si existen
      if (filters.dateFrom) {
        filtered = filtered.filter(e => new Date(e.timestamp) >= new Date(filters.dateFrom + 'T00:00:00Z'));
      }
      if (filters.dateTo) {
        filtered = filtered.filter(e => new Date(e.timestamp) <= new Date(filters.dateTo + 'T23:59:59Z'));
      }
      
      // Aplicar reglas de eventos
      filtered = applyEventFilteringRules(filtered);
      applyContextualTagging(filtered);
      
      // Actualizar displayedEvents
      displayedEvents = filtered;
      
      // Limpiar DOM si hay demasiados items
      cleanupOldItems();
      
      // Renderizar
      renderEvents();
    }

    function renderEvents() {
      const container = document.getElementById('activityListContainer');
      if (!container) return;
      
      // Si no hay eventos, mostrar mensaje
      if (displayedEvents.length === 0) {
        container.innerHTML = '<div class="text-center py-5"><p>No hay eventos para mostrar</p></div>';
        return;
      }
      
      // Crear fragment para renderizado eficiente
      const fragment = document.createDocumentFragment();
      
      displayedEvents.forEach(event => {
        const item = createEventItem(event);
        fragment.appendChild(item);
      });
      
      // Limpiar y agregar
      container.innerHTML = '';
      container.appendChild(fragment);
      
      // Mover sentinel al final
      moveSentinelToEnd();
    }

    function createEventItem(event) {
      const div = document.createElement('div');
      div.className = 'activity-item';
      
      // Badge
      let badgeColor = 'bg-secondary';
      let badgeText = event.type;
      if (event.type === 'FloorEngine') badgeColor = 'bg-primary';
      else if (event.type === 'ERC20') badgeColor = 'bg-success';
      else if (event.type === 'AdrianLABCore') badgeColor = 'bg-purple';
      else if (event.type === 'ERC1155') badgeColor = 'bg-info';
      else if (event.type === 'TraitsExtensions') badgeColor = 'bg-warning';
      else if (event.type === 'AdrianShop') badgeColor = 'bg-danger';
      
      // Date
      const date = new Date(event.timestamp);
      const dateStr = date.toLocaleString('es-ES', { 
        year: 'numeric', 
        month: 'short', 
        day: 'numeric', 
        hour: '2-digit', 
        minute: '2-digit' 
      });
      
      // Details
      const details = formatEventDetails(event);
      const image = getEventImage(event);
      const txHash = event.data?.tx_hash || '';
      
      div.innerHTML = `
        <div class="activity-header">
          <div>
            <span class="badge ${badgeColor} activity-badge">${badgeText}</span>
            <span class="badge bg-secondary activity-badge ms-2">${event.eventType}</span>
          </div>
          <div class="activity-date">${dateStr}</div>
        </div>
        <div class="activity-details">
          ${image}
          <span>${details}</span>
        </div>
        ${txHash ? `<div class="mt-2"><a href="https://basescan.org/tx/${txHash}" target="_blank" class="activity-link">View on Basescan <i class="bi bi-box-arrow-up-right"></i></a></div>` : ''}
      `;
      
      return div;
    }

    function formatEventDetails(event) {
      if (event.type === 'FloorEngine') {
        if (event.eventType === 'Listed' || event.eventType === 'Cancelled') {
          const tokenId = event.data.token_id;
          const seller = shortAddress(event.data.seller);
          const price = event.data.price_wei ? formatADRIAN(event.data.price_wei) : '';
          return `Token #${tokenId} - ${event.eventType} by ${seller}${price ? ' - Price: ' + price + ' $ADRIAN' : ''}`;
        } else if (event.eventType === 'Bought') {
          const tokenId = event.data.token_id;
          const buyer = shortAddress(event.data.buyer);
          const seller = shortAddress(event.data.seller);
          const price = event.data.price_wei ? formatADRIAN(event.data.price_wei) : '';
          return `Token #${tokenId} - Bought by ${buyer} from ${seller}${price ? ' - Price: ' + price + ' $ADRIAN' : ''}`;
        } else if (event.eventType === 'FloorSweep') {
          const tokenId = event.data.token_id;
          const caller = shortAddress(event.data.caller);
          const buyPrice = event.data.buy_price_wei ? formatADRIAN(event.data.buy_price_wei) : '';
          const reward = event.data.caller_reward_wei ? formatADRIAN(event.data.caller_reward_wei) : '';
          return `Token #${tokenId} - Sweep by ${caller}${buyPrice ? ' - Buy: ' + buyPrice + ' $ADRIAN' : ''}${reward ? ' - Reward: ' + reward + ' $ADRIAN' : ''}`;
        } else {
          return `${event.eventType}`;
        }
      } else if (event.type === 'ERC20') {
        if (event.eventType === 'Transfer') {
          const from = shortAddress(event.data.from_address);
          const to = shortAddress(event.data.to_address);
          const amount = event.data.value_wei ? formatADRIAN(event.data.value_wei) : '';
          const fromTag = getAddressTagBadge(event.data.from_address, event.contextualTag);
          const toTag = getAddressTagBadge(event.data.to_address);
          return `Transfer from ${from}${fromTag} to ${to}${toTag}${amount ? ' - Amount: ' + amount + ' $ADRIAN' : ''}`;
        } else if (event.eventType === 'Approval') {
          const owner = shortAddress(event.data.owner);
          const spender = shortAddress(event.data.spender);
          const amount = event.data.value_wei ? formatADRIAN(event.data.value_wei) : '';
          const ownerTag = getAddressTagBadge(event.data.owner);
          const spenderTag = getAddressTagBadge(event.data.spender);
          return `Approval by ${owner}${ownerTag} to ${spender}${spenderTag}${amount ? ' - Amount: ' + amount + ' $ADRIAN' : ''}`;
        } else {
          let details = `${event.eventType}`;
          if (event.data?.event_data) {
            const eventData = event.data.event_data;
            if (eventData.staker) details += ` - Staker: ${shortAddress(eventData.staker)}`;
            if (eventData.amount) details += ` - Amount: ${formatADRIAN(eventData.amount)} $ADRIAN`;
            if (eventData.reward) details += ` - Reward: ${formatADRIAN(eventData.reward)} $ADRIAN`;
            if (eventData.newTaxFee) details += ` - Tax Fee: ${eventData.newTaxFee} bps`;
            if (eventData.newCreatorFee) details += ` - Creator Fee: ${eventData.newCreatorFee} bps`;
            if (eventData.newBurnFee) details += ` - Burn Fee: ${eventData.newBurnFee} bps`;
          }
          return details;
        }
      } else if (event.type === 'AdrianLABCore') {
        let tokenId = event.data?.token_id || event.data?.event_data?.tokenId;
        if (event.eventType === 'Transfer') {
          const from = shortAddress(event.data.from_address);
          const to = shortAddress(event.data.to_address);
          return `Token #${tokenId || 'N/A'} - Transfer from ${from} to ${to}`;
        } else if (event.eventType === 'Approval') {
          const owner = shortAddress(event.data.owner);
          const approved = shortAddress(event.data.approved);
          return `Token #${tokenId || 'N/A'} - Approval by ${owner} to ${approved}`;
        } else if (event.eventType === 'ApprovalForAll') {
          const owner = shortAddress(event.data.owner);
          const operator = shortAddress(event.data.operator);
          const approved = event.data.approved || false;
          return `ApprovalForAll by ${owner} to ${operator} - Approved: ${approved}`;
        } else if (event.eventType === 'TokenMinted') {
          const to = shortAddress(event.data.event_data?.to);
          return `Token #${tokenId || 'N/A'} - Minted to ${to}`;
        } else if (event.eventType === 'TokenBurnt') {
          const burner = shortAddress(event.data.event_data?.burner);
          return `Token #${tokenId || 'N/A'} - Burnt by ${burner}`;
        } else if (event.eventType === 'SkinAssigned') {
          const skinName = event.data.event_data?.name || 'Unknown';
          return `Token #${tokenId || 'N/A'} - Skin "${skinName}" assigned`;
        } else if (event.eventType === 'SkinCreated') {
          const skinId = event.data.event_data?.skinId || 'N/A';
          const skinName = event.data.event_data?.name || 'Unknown';
          const rarity = event.data.event_data?.rarity || 'N/A';
          return `Skin #${skinId} "${skinName}" created - Rarity: ${rarity}`;
        } else if (event.eventType === 'MutationNameAssigned') {
          const mutation = event.data.event_data?.newMutation || 'Unknown';
          return `Token #${tokenId || 'N/A'} - Mutation "${mutation}" assigned`;
        } else if (event.eventType === 'SerumApplied') {
          const serumId = event.data.event_data?.serumId || 'N/A';
          return `Token #${tokenId || 'N/A'} - Serum #${serumId} applied`;
        } else if (event.eventType === 'SpecialSkinApplied') {
          const skinId = event.data.event_data?.skinId || 'N/A';
          const mutation = event.data.event_data?.mutation || 'Unknown';
          return `Token #${tokenId || 'N/A'} - Special skin #${skinId} applied (${mutation})`;
        } else {
          return `${event.eventType}`;
        }
      } else if (event.type === 'ERC1155') {
        let tokenId = event.data?.token_id || event.data?.tokenId;
        if (event.eventType === 'TransferSingle') {
          const from = shortAddress(event.data.from_address);
          const to = shortAddress(event.data.to_address);
          const value = event.data.value || '0';
          return `Token #${tokenId || 'N/A'} - Transfer ${value} from ${from} to ${to}`;
        } else if (event.eventType === 'TransferBatch') {
          const tokenIds = event.data?.token_ids || [];
          const from = shortAddress(event.data.from_address);
          const to = shortAddress(event.data.to_address);
          const tokenCount = Array.isArray(tokenIds) ? tokenIds.length : 0;
          return `Batch Transfer (${tokenCount} tokens) - From ${from} to ${to}${tokenCount > 0 && tokenId ? ' - First token: #' + tokenId : ''}`;
        } else if (event.eventType === 'ApprovalForAll') {
          const owner = shortAddress(event.data.owner);
          const operator = shortAddress(event.data.operator);
          const approved = event.data.approved || false;
          return `ApprovalForAll by ${owner} to ${operator} - Approved: ${approved}`;
        } else if (event.eventType === 'URI') {
          const uri = event.data?.uri || 'N/A';
          const id = event.data?.id || 'N/A';
          return `URI Updated - ID: ${id} - URI: ${uri.length > 50 ? uri.substring(0, 50) + '...' : uri}`;
        } else if (event.eventType === 'AssetMinted') {
          tokenId = event.data?.event_data?.assetId || event.data?.event_data?.tokenId || tokenId;
          const to = shortAddress(event.data.event_data?.to);
          return `Token #${tokenId || 'N/A'} - Minted to ${to}`;
        } else if (event.eventType === 'AssetBurned') {
          tokenId = event.data?.event_data?.assetId || event.data?.event_data?.tokenId || tokenId;
          const burner = shortAddress(event.data.event_data?.burner);
          return `Token #${tokenId || 'N/A'} - Burned by ${burner}`;
        } else if (event.eventType === 'PackOpened') {
          tokenId = event.data?.event_data?.packId || tokenId;
          const opener = shortAddress(event.data.event_data?.opener);
          return `Pack #${tokenId || 'N/A'} opened by ${opener}`;
        } else if (event.eventType === 'SerumUsed') {
          tokenId = event.data?.event_data?.serumId || tokenId;
          const user = shortAddress(event.data.event_data?.user);
          return `Serum #${tokenId || 'N/A'} used by ${user}`;
        } else {
          return `${event.eventType}`;
        }
      } else if (event.type === 'TraitsExtensions') {
        if (event.eventType === 'TraitApplied') {
          const tokenId = event.data?.event_data?.tokenId;
          const traitId = event.data?.event_data?.traitId;
          return `Trait #${traitId || 'N/A'} applied to Token #${tokenId || 'N/A'}`;
        } else if (event.eventType === 'TraitsAppliedBatch') {
          const tokenId = event.data?.event_data?.tokenId;
          const traitIds = event.data?.event_data?.traitIds;
          return `Traits ${traitIds ? traitIds.join(', ') : 'N/A'} applied to Token #${tokenId || 'N/A'}`;
        } else if (event.eventType === 'AssetAddedToInventory') {
          const tokenId = event.data?.event_data?.tokenId;
          const assetId = event.data?.event_data?.assetId;
          return `Asset #${assetId || 'N/A'} added to Token #${tokenId || 'N/A'}`;
        } else if (event.eventType === 'TraitRemoved') {
          const tokenId = event.data?.event_data?.tokenId;
          const traitId = event.data?.event_data?.traitId;
          return `Trait #${traitId || 'N/A'} removed from Token #${tokenId || 'N/A'}`;
        } else {
          let details = `${event.eventType}`;
          if (event.data?.event_data) {
            const eventData = event.data.event_data;
            if (eventData.tokenId) details += ` - Token #${eventData.tokenId}`;
            if (eventData.traitId) details += ` - Trait #${eventData.traitId}`;
            if (eventData.traitIds && Array.isArray(eventData.traitIds)) {
              details += ` - Traits: ${eventData.traitIds.join(', ')}`;
            }
            if (eventData.category) details += ` - Category: ${eventData.category}`;
            if (eventData.categories && Array.isArray(eventData.categories)) {
              details += ` - Categories: ${eventData.categories.join(', ')}`;
            }
            if (eventData.amount) details += ` - Amount: ${eventData.amount}`;
            if (eventData.totalCost) details += ` - Cost: ${formatADRIAN(eventData.totalCost)} $ADRIAN`;
          }
          return details;
        }
      } else if (event.type === 'AdrianShop') {
        if (event.eventType === 'ItemPurchased') {
          const buyer = shortAddress(event.data.event_data?.buyer);
          const itemId = event.data.event_data?.itemId || 'N/A';
          const amount = event.data.event_data?.amount || '0';
          const totalCost = event.data.event_data?.totalCost;
          return `Item #${itemId} purchased by ${buyer} - Amount: ${amount}${totalCost ? ' - Cost: ' + formatADRIAN(totalCost) + ' $ADRIAN' : ''}`;
        } else if (event.eventType === 'BatchPurchase') {
          const buyer = shortAddress(event.data.event_data?.buyer);
          const itemCount = event.data.event_data?.items?.length || 0;
          const totalCost = event.data.event_data?.totalCost;
          return `Batch purchase by ${buyer} - ${itemCount} items${totalCost ? ' - Cost: ' + formatADRIAN(totalCost) + ' $ADRIAN' : ''}`;
        } else if (event.eventType === 'ItemListed') {
          const seller = shortAddress(event.data.event_data?.seller);
          const itemId = event.data.event_data?.itemId || 'N/A';
          const price = event.data.event_data?.price;
          return `Item #${itemId} listed by ${seller}${price ? ' - Price: ' + formatADRIAN(price) + ' $ADRIAN' : ''}`;
        } else if (event.eventType === 'ItemDelisted') {
          const seller = shortAddress(event.data.event_data?.seller);
          const itemId = event.data.event_data?.itemId || 'N/A';
          return `Item #${itemId} delisted by ${seller}`;
        } else {
          let details = `${event.eventType}`;
          if (event.data?.event_data) {
            const eventData = event.data.event_data;
            if (eventData.buyer) details += ` - Buyer: ${shortAddress(eventData.buyer)}`;
            if (eventData.seller) details += ` - Seller: ${shortAddress(eventData.seller)}`;
            if (eventData.itemId) details += ` - Item #${eventData.itemId}`;
            if (eventData.amount) details += ` - Amount: ${eventData.amount}`;
            if (eventData.totalCost) details += ` - Cost: ${formatADRIAN(eventData.totalCost)} $ADRIAN`;
          }
          return details;
        }
      }
      
      return `${event.eventType}`;
    }

    function getEventImage(event) {
      // TraitsAppliedBatch - imagen din√°mica
      if (event.type === 'TraitsExtensions' && event.eventType === 'TraitsAppliedBatch') {
        return createTraitsAppliedBatchImage(event);
      }
      
      // TraitApplied - mannequin
      if (event.type === 'TraitsExtensions' && event.eventType === 'TraitApplied') {
        return createEventImage('TraitApplied');
      }
      
      // ERC20 - ADRIAN Coin
      if (event.type === 'ERC20') {
        return createEventImage('ERC20');
      }
      
      // FloorEngine o AdrianLABCore - imagen del NFT
      let tokenId = null;
      if (event.type === 'FloorEngine') {
        tokenId = event.data?.token_id;
      } else if (event.type === 'AdrianLABCore') {
        tokenId = event.data?.token_id || event.data?.event_data?.tokenId;
      }
      
      if (tokenId) {
        return createNFTImage(tokenId);
      }
      
      // ERC1155 - imagen de AdrianLAB
      if (event.type === 'ERC1155') {
        tokenId = event.data?.token_id || event.data?.tokenId || event.data?.event_data?.assetId || event.data?.event_data?.tokenId;
        if (tokenId) {
          return createAdrianLABImage(tokenId);
        }
      }
      
      return '';
    }
    
    // Funciones de im√°genes
    function getNFTImageUrl(tokenId) {
      if (!tokenId || tokenId === 'N/A') return null;
      if (imageRules.adrianPunks) {
        return `${imageRules.adrianPunks.baseUrl}${tokenId}${imageRules.adrianPunks.extension}`;
      }
      return `../market/adrianpunksimages/${tokenId}.png`;
    }
    
    function createNFTImage(tokenId, size = 48) {
      const imgUrl = getNFTImageUrl(tokenId);
      if (!imgUrl) return '';
      return `<img src="${imgUrl}" alt="Punk #${tokenId}" class="nft-thumbnail" style="width: ${size}px; height: ${size}px; object-fit: cover; border-radius: 4px; border: 1px solid var(--border-color);" loading="lazy" decoding="async" onerror="this.style.display='none'" />`;
    }
    
    function getAdrianLABImageUrls(tokenId) {
      if (!tokenId || tokenId === 'N/A') return [];
      const urls = [];
      if (imageRules.adrianLAB) {
        const baseUrl = imageRules.adrianLAB.baseUrl;
        const primaryExtension = imageRules.adrianLAB.extension;
        const fallbackExtensions = imageRules.adrianLAB.fallbackExtensions || [];
        urls.push(`${baseUrl}${tokenId}${primaryExtension}`);
        fallbackExtensions.forEach(ext => {
          urls.push(`${baseUrl}${tokenId}${ext}`);
        });
      } else {
        urls.push(`https://adrianzero.com/traitlab/assets/traits/${tokenId}.svg`);
        urls.push(`https://adrianzero.com/traitlab/assets/traits/${tokenId}.png`);
        urls.push(`https://adrianzero.com/traitlab/assets/traits/${tokenId}.gif`);
      }
      return urls;
    }
    
    function createAdrianLABImage(tokenId, size = 48) {
      const urls = getAdrianLABImageUrls(tokenId);
      if (!urls || urls.length === 0) return '';
      if (urls.length === 1) {
        return `<img src="${urls[0]}" alt="AdrianLAB #${tokenId}" class="nft-thumbnail" style="width: ${size}px; height: ${size}px; object-fit: contain; border-radius: 4px; border: 1px solid var(--border-color); background: var(--card-bg);" loading="lazy" decoding="async" onerror="this.style.display='none'" />`;
      }
      const imageId = `adrianlab-img-${tokenId}-${Date.now()}`;
      const urlsJson = JSON.stringify(urls).replace(/"/g, '&quot;');
      return `<img id="${imageId}" src="${urls[0]}" alt="AdrianLAB #${tokenId}" class="nft-thumbnail" style="width: ${size}px; height: ${size}px; object-fit: contain; border-radius: 4px; border: 1px solid var(--border-color); background: var(--card-bg);" data-fallback-urls="${urlsJson}" data-current-index="0" onerror="tryNextAdrianLABImage(this)" />`;
    }
    
    function tryNextAdrianLABImage(img) {
      if (!img) return;
      try {
        const urlsJson = img.getAttribute('data-fallback-urls');
        if (!urlsJson) {
          img.style.display = 'none';
          return;
        }
        const urls = JSON.parse(urlsJson.replace(/&quot;/g, '"'));
        let currentIndex = parseInt(img.getAttribute('data-current-index') || '0', 10);
        currentIndex++;
        if (currentIndex < urls.length) {
          img.setAttribute('data-current-index', currentIndex.toString());
          img.src = urls[currentIndex];
        } else {
          img.style.display = 'none';
        }
      } catch (error) {
        img.style.display = 'none';
      }
    }
    
    function getEventImageUrl(eventType) {
      if (!imageRules.eventImages || !imageRules.eventImages[eventType]) {
        return null;
      }
      return imageRules.eventImages[eventType].imageUrl;
    }
    
    function createEventImage(eventType, size = 48) {
      const imageUrl = getEventImageUrl(eventType);
      if (!imageUrl) return '';
      return `<img src="${imageUrl}" alt="${eventType}" class="nft-thumbnail" style="width: ${size}px; height: ${size}px; object-fit: contain; border-radius: 4px; border: 1px solid var(--border-color); background: var(--card-bg);" loading="lazy" decoding="async" onerror="this.style.display='none'" />`;
    }
    
    function createTraitsAppliedBatchImage(event, size = 48) {
      if (!event.data?.event_data) return '';
      const eventData = event.data.event_data;
      const tokenId = eventData.tokenId;
      const traitIds = eventData.traitIds;
      if (!tokenId || !traitIds || !Array.isArray(traitIds) || traitIds.length === 0) {
        return '';
      }
      const baseUrl = imageRules.eventImages?.TraitsAppliedBatch?.baseUrl || 
                      'https://adrianlab.vercel.app/api/render/custom/';
      const timestamp = Date.now();
      const traitParams = traitIds.map(traitId => `trait=${traitId}`).join('&');
      const imageUrl = `${baseUrl}${tokenId}?${traitParams}&_t=${timestamp}`;
      return `<img src="${imageUrl}" alt="AdrianZERO #${tokenId} with traits ${traitIds.join(', ')}" class="nft-thumbnail" style="width: ${size}px; height: ${size}px; object-fit: contain; border-radius: 4px; border: 1px solid var(--border-color); background: var(--card-bg);" loading="lazy" decoding="async" onerror="this.style.display='none'" />`;
    }

    // ============================================
    // UTILITY FUNCTIONS
    // ============================================
    function formatADRIAN(weiString) {
      try {
        let weiStr = String(weiString);
        if (weiStr.includes('e') || weiStr.includes('E')) {
          const num = parseFloat(weiStr);
          weiStr = num.toLocaleString('fullwide', { useGrouping: false, maximumFractionDigits: 0 });
        }
        weiStr = weiStr.replace(/,/g, '');
        if (!/^\d+$/.test(weiStr)) return '0.00';
        const wei = ethers.BigNumber.from(weiStr);
        const adrian = parseFloat(ethers.utils.formatUnits(wei, 18));
        return adrian.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
      } catch (error) {
        return '0.00';
      }
    }

    function shortAddress(address) {
      if (!address) return 'N/A';
      return `${address.slice(0, 6)}...${address.slice(-4)}`;
    }

    function getAddressTagBadge(address, contextualTag) {
      if (contextualTag) {
        return `<span class="badge bg-${contextualTag.color} ms-2">${contextualTag.tag}</span>`;
      }
      const tagInfo = addressTagsRules[address?.toLowerCase()];
      if (!tagInfo) return '';
      return `<span class="badge bg-${tagInfo.color} ms-2">${tagInfo.tag}</span>`;
    }

    function applyEventFilteringRules(events) {
      if (!eventRules.filtering) return events;
      
      const filteredEvents = [];
      const eventsToRemove = new Set();
      
      // Aplicar regla de mints redundantes
      if (eventRules.filtering.redundantMints?.enabled) {
        const rule = eventRules.filtering.redundantMints.rules[0];
        if (rule) {
          const sourceEvents = new Map();
          const conflictEvents = new Map();
          
          // Identificar eventos fuente (TransferSingle desde 0x0000...0000)
          events.forEach(event => {
            if (event.type === rule.sourceEvent.type && 
                event.eventType === rule.sourceEvent.eventType) {
              const from = (event.data?.from_address || '').toLowerCase();
              if (from === rule.sourceEvent.conditions.from_address.toLowerCase()) {
                const tokenId = event.data?.token_id || event.data?.tokenId || null;
                const to = (event.data?.to_address || '').toLowerCase();
                if (tokenId) {
                  const key = `${tokenId}-${to}`;
                  if (!sourceEvents.has(key)) {
                    sourceEvents.set(key, []);
                  }
                  sourceEvents.get(key).push(event);
                }
              }
            }
            
            // Identificar eventos de conflicto (AssetMinted)
            if (event.type === rule.conflictEvent.type && 
                event.eventType === rule.conflictEvent.eventType) {
              const tokenId = event.data?.event_data?.assetId || event.data?.event_data?.tokenId || null;
              const to = (event.data?.event_data?.to || '').toLowerCase();
              if (tokenId) {
                const key = `${tokenId}-${to}`;
                conflictEvents.set(key, event);
              }
            }
          });
          
          // Marcar eventos fuente para remover si hay conflicto
          sourceEvents.forEach((sourceList, key) => {
            if (conflictEvents.has(key)) {
              sourceList.forEach(sourceEvent => {
                eventsToRemove.add(sourceEvent);
              });
            }
          });
        }
      }
      
      // Filtrar eventos
      events.forEach(event => {
        if (!eventsToRemove.has(event)) {
          filteredEvents.push(event);
        }
      });
      
      return filteredEvents;
    }

    function applyContextualTagging(events) {
      if (!eventRules.contextualTagging) return;
      
      // Aplicar regla de FloorSweep
      if (eventRules.contextualTagging.floorSweep?.enabled) {
        const rule = eventRules.contextualTagging.floorSweep.rules[0];
        if (rule) {
          // Encontrar todos los FloorSweep
          const floorSweeps = events.filter(e => 
            e.type === rule.triggerEvent.type && 
            e.eventType === rule.triggerEvent.eventType
          );
          
          floorSweeps.forEach(sweepEvent => {
            const sweepData = sweepEvent.data;
            const sweepTimestamp = new Date(sweepEvent.timestamp).getTime();
            const callerAddress = (sweepData?.caller || '').toLowerCase();
            const rewardAmount = String(sweepData?.caller_reward_wei || '0');
            const buyAmount = String(sweepData?.buy_price_wei || '0');
            
            // Buscar transfers de ERC20 relacionados
            rule.targetEvents.forEach(targetRule => {
              events.forEach(event => {
                if (event.type === targetRule.type && 
                    event.eventType === targetRule.eventType) {
                  const eventFrom = (event.data?.from_address || '').toLowerCase();
                  const eventTo = (event.data?.to_address || '').toLowerCase();
                  const eventTimestamp = new Date(event.timestamp).getTime();
                  const eventAmount = String(event.data?.value_wei || '0');
                  
                  // Verificar condiciones
                  if (eventFrom === targetRule.conditions.from_address.toLowerCase() &&
                      eventTo === callerAddress &&
                      Math.abs(eventTimestamp - sweepTimestamp) < 60000 && // Dentro de 1 minuto
                      eventAmount === (targetRule.conditions.matchAmount === 'caller_reward_wei' ? rewardAmount : buyAmount)) {
                    
                    // Asignar tag contextual al evento
                    if (!event.contextualTag) {
                      event.contextualTag = targetRule.tag;
                    }
                  }
                }
              });
            });
          });
        }
      }
    }

    function cleanupOldItems() {
      // Si hay m√°s de MAX_ITEMS_IN_DOM, mantener solo los √∫ltimos
      if (displayedEvents.length > MAX_ITEMS_IN_DOM) {
        const toRemove = displayedEvents.length - MAX_ITEMS_IN_DOM;
        displayedEvents = displayedEvents.slice(toRemove);
      }
    }

    // ============================================
    // UI HELPERS
    // ============================================
    function showLoading() {
      const container = document.getElementById('activityListContainer');
      if (container) {
        container.innerHTML = '<div class="loading-spinner"><div class="spinner-border" role="status"></div></div>';
      }
    }

    function hideLoading() {
      // Loading se oculta cuando renderizamos
    }

    function showError(message) {
      const container = document.getElementById('activityListContainer');
      if (container) {
        container.innerHTML = `<div class="alert alert-danger">${message}</div>`;
      }
    }

    // ============================================
    // INFINITE SCROLL
    // ============================================
    function setupInfiniteScroll() {
      // Limpiar observer anterior si existe
      if (intersectionObserver) {
        intersectionObserver.disconnect();
        intersectionObserver = null;
      }
      
      const sentinel = document.getElementById('scrollSentinel');
      if (!sentinel) return;
      
      // Crear Intersection Observer
      intersectionObserver = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting && hasMore && !isLoading) {
            loadMore();
          }
        });
      }, {
        root: null, // viewport
        rootMargin: '100px', // Cargar cuando est√© a 100px del viewport
        threshold: 0.1
      });
      
      intersectionObserver.observe(sentinel);
    }
    
    function moveSentinelToEnd() {
      const container = document.getElementById('activityListContainer');
      const sentinel = document.getElementById('scrollSentinel');
      if (container && sentinel) {
        if (container.contains(sentinel)) {
          container.appendChild(sentinel);
        } else {
          container.appendChild(sentinel);
        }
      }
    }

    // ============================================
    // FILTER HANDLERS
    // ============================================
    function applyFilters() {
      filters.contract = document.getElementById('filterContract').value;
      filters.eventType = document.getElementById('filterEventType').value;
      filters.dateFrom = document.getElementById('filterDateFrom').value || null;
      filters.dateTo = document.getElementById('filterDateTo').value || null;
      filters.address = document.getElementById('filterAddress').value.trim() || null;
      
      loadFirstPage();
    }

    function clearFilters() {
      document.getElementById('filterContract').value = 'all';
      document.getElementById('filterEventType').value = 'all';
      document.getElementById('filterDateFrom').value = '';
      document.getElementById('filterDateTo').value = '';
      document.getElementById('filterAddress').value = '';
      
      filters.contract = 'all';
      filters.eventType = 'all';
      filters.dateFrom = null;
      filters.dateTo = null;
      filters.address = null;
      
      loadFirstPage();
    }

    // ============================================
    // INITIALIZE ON LOAD
    // ============================================
    document.addEventListener('DOMContentLoaded', init);
  </script>
</body>
</html>

