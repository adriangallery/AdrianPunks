<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Instant Liquidity - AdrianPunks</title>
  <link rel="icon" type="image/x-icon" href="../favicon.ico">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
  <link rel="stylesheet" href="../market/styles.css">
  <link rel="stylesheet" href="styles.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/5.7.2/ethers.umd.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script src="../market/runtime-config.js"></script>
  <script src="../market/supabase-config.js"></script>
</head>
<body>
  <!-- Include the menu -->
  <div id="menu-container"></div>
  <script>
    // Load the menu with proper styling
    (function() {
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', loadMenu);
      } else {
        loadMenu();
      }
      
      function loadMenu() {
        fetch('../components/menu.html')
          .then(response => response.text())
          .then(html => {
            const container = document.getElementById('menu-container');
            if (container) {
              container.innerHTML = html;
              
              // Ensure menu has correct Bootstrap classes and styling
              const menu = container.querySelector('.navbar');
              if (menu) {
                menu.classList.add('navbar-dark', 'bg-dark');
                menu.style.backgroundColor = '#212529';
              }
              
              // Ensure toggler icon is visible
              const togglerIcon = container.querySelector('.navbar-toggler-icon');
              if (togglerIcon) {
                togglerIcon.style.filter = 'invert(100%)';
              }
              
              // Fix script paths in the loaded HTML (menu.js needs relative path from dump/)
              const scripts = container.querySelectorAll('script[src="menu.js"]');
              scripts.forEach(script => {
                script.src = '../components/menu.js';
              });
              
              // Ensure Bootstrap is available and reinitialize if needed
              if (typeof bootstrap !== 'undefined') {
                // Bootstrap is already loaded, ensure nav links work
                const navLinks = container.querySelectorAll('.nav-link');
                navLinks.forEach(link => {
                  // Remove any existing listeners that might interfere
                  const newLink = link.cloneNode(true);
                  link.parentNode.replaceChild(newLink, link);
                });
              }
            }
          })
          .catch(error => console.error('Error loading menu:', error));
      }
    })();
  </script>

  <!-- Main Layout -->
  <div class="main-layout">
    <!-- Sidebar Left: Info -->
    <aside class="sidebar">
      <!-- FloorEngine Balance Panel -->
      <div class="collapsible-panel mb-3">
        <div class="panel-header" data-bs-toggle="collapse" data-bs-target="#floorEnginePanel" aria-expanded="true">
          <h5 class="mb-0">FloorEngine Balance</h5>
          <i class="bi bi-chevron-down collapse-icon"></i>
        </div>
        <div class="collapse show" id="floorEnginePanel">
          <div class="panel-body">
            <div id="floorEngineBalance">
              <div class="spinner-border spinner-border-sm" role="status">
                <span class="visually-hidden">Loading...</span>
              </div>
              <span class="ms-2">Loading...</span>
            </div>
          </div>
        </div>
      </div>

      <!-- Current Floor Price Panel -->
      <div class="collapsible-panel">
        <div class="panel-header" data-bs-toggle="collapse" data-bs-target="#floorPricePanel" aria-expanded="true">
          <h5 class="mb-0">Current Floor Price</h5>
          <i class="bi bi-chevron-down collapse-icon"></i>
        </div>
        <div class="collapse show" id="floorPricePanel">
          <div class="panel-body">
            <div id="currentFloorPrice">
              <div class="spinner-border spinner-border-sm" role="status">
                <span class="visually-hidden">Loading...</span>
              </div>
              <span class="ms-2">Loading...</span>
            </div>
          </div>
        </div>
      </div>
    </aside>

    <!-- Main Content -->
    <main class="main-content">
      <!-- Featured Punk Panel -->
      <div class="collapsible-panel mb-3">
        <div class="panel-header" data-bs-toggle="collapse" data-bs-target="#featuredPunkPanel" aria-expanded="true">
          <h5 class="mb-0">Dump your punk</h5>
          <i class="bi bi-chevron-down collapse-icon"></i>
        </div>
        <div class="collapse show" id="featuredPunkPanel">
          <div class="panel-body">
            <div id="featuredPunkContent">
              <div class="text-center">
                <p class="text-muted">Connect your wallet to see your punks</p>
              </div>
            </div>
            <div id="buttonContainer" class="text-center" style="margin-top: 1rem;">
              <button id="listInstantlyBtn" class="btn btn-primary btn-lg" disabled>
                <span id="listBtnText">Connect wallet to list</span>
              </button>
              <div id="listStatus" class="mt-3"></div>
            </div>
          </div>
        </div>
      </div>

      <!-- Token Selector -->
      <div class="collapsible-panel mb-3">
        <div class="panel-header" data-bs-toggle="collapse" data-bs-target="#tokenSelectorPanel" aria-expanded="true">
          <h5 class="mb-0">Select Token to List</h5>
          <i class="bi bi-chevron-down collapse-icon"></i>
        </div>
        <div class="collapse show" id="tokenSelectorPanel">
          <div class="panel-body">
            <select id="tokenSelector" class="form-select" disabled>
              <option value="">No tokens available</option>
            </select>
          </div>
        </div>
      </div>
    </main>

    <!-- Sidebar Right: Instructions -->
    <aside class="sidebar">
      <div class="collapsible-panel">
        <div class="panel-header" data-bs-toggle="collapse" data-bs-target="#instructionsPanel" aria-expanded="true">
          <h5 class="mb-0">How It Works</h5>
          <i class="bi bi-chevron-down collapse-icon"></i>
        </div>
        <div class="collapse show" id="instructionsPanel">
          <div class="panel-body">
            <ol class="small">
              <li>Connect your wallet</li>
              <li>Select a punk from your collection</li>
              <li>Click "Get instantly X $ADRIAN for your #X Punk"</li>
              <li>Approve the NFT (if needed)</li>
              <li>Confirm the listing transaction</li>
              <li>Wait a few minutes for FloorEngine to buy it</li>
              <li>Receive $ADRIAN in your wallet</li>
            </ol>
            <p class="small text-muted mt-3">
              Your punk will be listed at the current floor price. FloorEngine will automatically purchase it when it has enough liquidity.
            </p>
          </div>
        </div>
      </div>
    </aside>
  </div>

  <script>
    // Contract addresses
    const TOKEN_ADDRESS = "0x7E99075Ce287F1cF8cBCAaa6A1C7894e404fD7Ea"; // $ADRIAN
    const NFT_ADDRESS = "0x79BE8AcdD339C7b92918fcC3fd3875b5Aaad7566"; // AdrianPunks
    const FLOOR_ENGINE_ADDRESS = "0x0351F7cBA83277E891D4a85Da498A7eACD764D58"; // FloorEngine
    const MULTICALL3_ADDRESS = "0xcA11bde05977b3631167028862bE2a173976CA11"; // Multicall3 on Base

    // Alchemy API Configuration (from runtime-config.js)
    const ALCHEMY_API_KEY = window.ALCHEMY_API_KEY || 'YOUR_ALCHEMY_API_KEY';
    const ALCHEMY_RPC_URL = ALCHEMY_API_KEY && ALCHEMY_API_KEY !== 'YOUR_ALCHEMY_API_KEY' 
      ? `https://base-mainnet.g.alchemy.com/v2/${ALCHEMY_API_KEY}`
      : null;
    
    // Debug: Verificar que el API key se carg√≥ correctamente
    if (ALCHEMY_API_KEY && ALCHEMY_API_KEY !== 'YOUR_ALCHEMY_API_KEY' && ALCHEMY_API_KEY !== '') {
      console.log('‚úÖ Alchemy API key loaded successfully');
    } else {
      console.warn('‚ö†Ô∏è Alchemy API key not configured. Using fallback to public RPC.');
    }

    // Supabase configuration (from runtime-config.js)
    const SUPABASE_URL = window.SUPABASE_URL || 'YOUR_SUPABASE_URL';
    const SUPABASE_ANON_KEY = window.SUPABASE_ANON_KEY || 'YOUR_SUPABASE_ANON_KEY';
    let supabaseClient = null;

    function initSupabase() {
      if (SUPABASE_URL && SUPABASE_ANON_KEY && SUPABASE_URL !== 'YOUR_SUPABASE_URL' && SUPABASE_URL !== '') {
        supabaseClient = supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
        console.log('‚úÖ Supabase initialized');
      } else {
        console.warn('‚ö†Ô∏è Supabase credentials not configured');
      }
    }

    // ABIs
    const FLOOR_ENGINE_ABI = [
      "event Listed(uint256 indexed tokenId, address indexed seller, uint256 price, bool isContractOwned)",
      "event Cancelled(uint256 indexed tokenId, address indexed seller)",
      "event Bought(uint256 indexed tokenId, address indexed buyer, address indexed seller, uint256 price, bool isContractOwned)",
      "function list(uint256 tokenId, uint256 price) external",
      "function cancel(uint256 tokenId) external",
      "function buy(uint256 tokenId) external",
      "function listings(uint256 tokenId) external view returns (address seller, uint256 price, bool isContractOwned)",
      "function isListed(uint256 tokenId) external view returns (bool)",
      "function getListedTokenIds() external view returns (uint256[])"
    ];

    const TOKEN_ABI = [
      "function balanceOf(address account) view returns (uint256)",
      "function approve(address spender, uint256 amount) external returns (bool)",
      "function allowance(address owner, address spender) view returns (uint256)"
    ];

    const NFT_ABI = [
      "function tokenURI(uint256 tokenId) view returns (string)",
      "function ownerOf(uint256 tokenId) view returns (address)",
      "function getApproved(uint256 tokenId) view returns (address)",
      "function approve(address to, uint256 tokenId) external",
      "function isApprovedForAll(address owner, address operator) view returns (bool)",
      "function setApprovalForAll(address operator, bool approved) external",
      "function balanceOf(address owner) view returns (uint256)",
      "function tokenOfOwnerByIndex(address owner, uint256 index) view returns (uint256)",
      "function totalMinted() view returns (uint256)"
    ];

    const MULTICALL3_ABI = [
      "function aggregate3(tuple(address target, bool allowFailure, bytes callData)[] calls) external view returns (tuple(bool success, bytes returnData)[] returnData)"
    ];

    // Global variables
    let readProvider = null;
    let nftReadContract = null;
    let tokenReadContract = null;
    let floorEngineReadContract = null;
    let multicallContract = null;
    let nftContract = null;
    let floorEngineContract = null;
    let userAccount = null;
    let userPunks = [];
    let selectedTokenId = null;
    let currentFloorPrice = null;
    let floorEngineBalance = 0; // Balance disponible en FloorEngine
    let activeListingsData = [];

    // GIF token IDs
    const gifIds = ['1', '13', '221', '369', '420', '555', '69', '690', '777', '807', '911'];

    // Initialize
    async function init() {
      try {
        initSupabase();
        
        // Initialize read provider
        const ethers5 = window.ethers5Backup || window.ethers;
        if (!ethers5) {
          console.error('Ethers v5 not loaded');
          return;
        }

        // Use Alchemy RPC if available, otherwise use public RPC (with retry logic)
        const rpcUrl = ALCHEMY_RPC_URL || 'https://mainnet.base.org';
        readProvider = new ethers5.providers.JsonRpcProvider(rpcUrl, {
          name: "base",
          chainId: 8453
        });
        
        // Set timeout for RPC calls to avoid hanging
        if (readProvider._getConnection) {
          readProvider._getConnection = function() {
            const connection = ethers5.providers.JsonRpcProvider.prototype._getConnection.call(this);
            connection.timeout = 10000; // 10 second timeout
            return connection;
          };
        }

        // Initialize read contracts
        nftReadContract = new ethers5.Contract(NFT_ADDRESS, NFT_ABI, readProvider);
        tokenReadContract = new ethers5.Contract(TOKEN_ADDRESS, TOKEN_ABI, readProvider);
        floorEngineReadContract = new ethers5.Contract(FLOOR_ENGINE_ADDRESS, FLOOR_ENGINE_ABI, readProvider);
        multicallContract = new ethers5.Contract(MULTICALL3_ADDRESS, MULTICALL3_ABI, readProvider);

        console.log('‚úÖ Contracts initialized');
        console.log('üìä Using RPC:', ALCHEMY_RPC_URL ? 'Alchemy' : 'Public RPC');

        // Initialize wallet connection (same pattern as market)
        await initWallet();

        // Load initial data (with timing logs)
        console.log('üîÑ Loading initial data...');
        const initStart = performance.now();
        
        await Promise.all([
          updateFloorEngineBalance(),
          loadActiveListings(),
          updateCurrentFloorPrice()
        ]);
        
        console.log(`‚úÖ Initial data loaded in ${(performance.now() - initStart).toFixed(2)}ms`);

        // Set up intervals
        setInterval(updateFloorEngineBalance, 30000); // Every 30 seconds
        setInterval(loadActiveListings, 60000); // Every minute
        setInterval(updateCurrentFloorPrice, 30000); // Every 30 seconds

      } catch (error) {
        console.error('Error initializing:', error);
      }
    }

    async function initWallet() {
      try {
        if (window.ethereum) {
          const ethers5 = window.ethers5Backup || window.ethers;
          window.provider = new ethers5.providers.Web3Provider(window.ethereum);
          window.signer = window.provider.getSigner();
          
          try {
            window.userAccount = await window.signer.getAddress();
            userAccount = window.userAccount;
          } catch (e) {
            console.log("No user connected yet");
            userAccount = null;
          }
        }
        
        // Update local references
        if (userAccount) {
          const ethers5 = window.ethers5Backup || window.ethers;
          if (ethers5 && ethers5.Contract) {
            nftContract = new ethers5.Contract(NFT_ADDRESS, NFT_ABI, window.signer);
            floorEngineContract = new ethers5.Contract(FLOOR_ENGINE_ADDRESS, FLOOR_ENGINE_ABI, window.signer);
            console.log('‚úÖ Wallet contracts initialized');
            await loadUserPunks();
          }
        }
      } catch (error) {
        console.error('Error initializing wallet:', error);
      }
    }

    // Connect wallet function
    async function connectWallet() {
      try {
        if (!window.ethereum) {
          alert('Please install MetaMask!');
          return;
        }

        const ethers5 = window.ethers5Backup || window.ethers;
        if (!ethers5) {
          alert('Ethers library not loaded. Please refresh the page.');
          return;
        }

        const btn = document.getElementById('listInstantlyBtn');
        const btnText = document.getElementById('listBtnText');
        
        if (btn) {
          btn.disabled = true;
        }
        if (btnText) {
          btnText.textContent = 'Connecting...';
        }

        // Request account access
        await window.ethereum.request({ method: 'eth_requestAccounts' });
        
        // Initialize provider and signer
        window.provider = new ethers5.providers.Web3Provider(window.ethereum);
        window.signer = window.provider.getSigner();
        window.userAccount = await window.signer.getAddress();
        userAccount = window.userAccount;

        // Initialize contracts
        nftContract = new ethers5.Contract(NFT_ADDRESS, NFT_ABI, window.signer);
        floorEngineContract = new ethers5.Contract(FLOOR_ENGINE_ADDRESS, FLOOR_ENGINE_ABI, window.signer);
        
        console.log('‚úÖ Wallet connected:', userAccount);
        
        // Load user punks
        await loadUserPunks();
        
        // Update button
        updateListButton();
        
        // Disparar evento para notificar que la wallet est√° conectada
        const event = new CustomEvent('walletConnected', { detail: { address: userAccount } });
        window.dispatchEvent(event);
        
      } catch (error) {
        console.error('Error connecting wallet:', error);
        const btn = document.getElementById('listInstantlyBtn');
        const btnText = document.getElementById('listBtnText');
        
        if (btn) {
          btn.disabled = false;
        }
        if (btnText) {
          btnText.textContent = 'Connect wallet to list';
        }
        
        if (error.code === 4001) {
          alert('Connection rejected by user');
        } else {
          alert('Error connecting wallet: ' + error.message);
        }
      }
    }

    // Load user's punks (optimized with Multicall3)
    async function loadUserPunks() {
      const startTime = performance.now();
      try {
        if (!userAccount || !nftReadContract) {
          userPunks = [];
          updateUI();
          return;
        }

        console.log('üîÑ Loading user punks...');
        const balanceStart = performance.now();
        const balance = await nftReadContract.balanceOf(userAccount);
        const totalTokens = balance.toNumber();
        console.log(`‚è±Ô∏è Balance call took ${(performance.now() - balanceStart).toFixed(2)}ms`);

        if (totalTokens === 0) {
          userPunks = [];
          updateUI();
          console.log('‚úÖ No punks found for user');
          return;
        }

        console.log(`üì¶ User has ${totalTokens} tokens, loading with Multicall3...`);
        
        // Use Multicall3 to get all tokenIds in one batch
        const ethers5 = window.ethers5Backup || window.ethers;
        const nftInterface = new ethers5.utils.Interface(NFT_ABI);
        const tokenIdCalls = [];
        for (let i = 0; i < totalTokens; i++) {
          tokenIdCalls.push({
            target: NFT_ADDRESS,
            allowFailure: true,
            callData: nftInterface.encodeFunctionData('tokenOfOwnerByIndex', [userAccount, i])
          });
        }

        const multicallStart = performance.now();
        let tokenIdResults;
        try {
          tokenIdResults = await multicallContract.callStatic.aggregate3(tokenIdCalls);
          console.log(`‚è±Ô∏è Multicall3 took ${(performance.now() - multicallStart).toFixed(2)}ms`);
        } catch (error) {
          console.warn('Multicall3 failed, falling back to individual calls:', error);
          // Fallback to individual calls
          const tokenIds = [];
          for (let i = 0; i < totalTokens; i++) {
            try {
              const tokenId = await nftReadContract.tokenOfOwnerByIndex(userAccount, i);
              const tokenIdNum = tokenId.toNumber();
              if (tokenIdNum >= 1 && tokenIdNum <= 1000) {
                tokenIds.push(tokenIdNum);
              }
            } catch (err) {
              console.warn(`Error getting token ${i}:`, err);
            }
          }
          userPunks = tokenIds.sort((a, b) => a - b);
          console.log(`‚úÖ Loaded ${userPunks.length} punks (fallback method) in ${(performance.now() - startTime).toFixed(2)}ms`);
          if (userPunks.length > 0) {
            const randomIndex = Math.floor(Math.random() * userPunks.length);
            selectedTokenId = userPunks[randomIndex];
          }
          updateUI();
          loadFeaturedPunk();
          updateTokenSelector();
          return;
        }

        const tokenIds = tokenIdResults
          .filter(result => result.success)
          .map(result => {
            try {
              const decoded = nftInterface.decodeFunctionResult('tokenOfOwnerByIndex', result.returnData);
              return decoded[0].toNumber();
            } catch (e) {
              return null;
            }
          })
          .filter(id => id !== null && id >= 1 && id <= 1000);

        userPunks = tokenIds.sort((a, b) => a - b);
        console.log(`‚úÖ Loaded ${userPunks.length} punks in ${(performance.now() - startTime).toFixed(2)}ms`);

        // Select random punk as default
        if (userPunks.length > 0) {
          const randomIndex = Math.floor(Math.random() * userPunks.length);
          selectedTokenId = userPunks[randomIndex];
        }

        updateUI();
        loadFeaturedPunk();
        updateTokenSelector();
      } catch (error) {
        console.error('Error loading user punks:', error);
        userPunks = [];
        updateUI();
      }
    }

    // Load featured punk display
    function loadFeaturedPunk() {
      if (!selectedTokenId) {
        const content = document.getElementById('featuredPunkContent');
        if (content) {
          content.innerHTML = `
            <div class="text-center">
              <p class="text-muted">No punk selected</p>
            </div>
          `;
        }
        return;
      }

      const extension = gifIds.includes(selectedTokenId.toString()) ? 'gif' : 'png';
      const imageUrl = `/market/adrianpunksimages/${selectedTokenId}.${extension}`;
      const tokenName = `AdrianPunks #${selectedTokenId}`;

      const content = document.getElementById('featuredPunkContent');
      if (content) {
        content.innerHTML = `
          <div class="text-center">
            <img id="featuredPunkImage" src="${imageUrl}" alt="${tokenName}" 
                 class="featured-punk-image" style="max-width: 100%; border-radius: 10px; margin-bottom: 1rem; display: none;">
            <h5>${tokenName}</h5>
          </div>
        `;

        const img = document.getElementById('featuredPunkImage');
        if (img) {
          img.onload = function() {
            this.style.display = 'block';
          };
          img.onerror = function() {
            console.warn('Failed to load image:', imageUrl);
            this.style.display = 'none';
          };
        }
      }
    }

    // Update token selector dropdown
    function updateTokenSelector() {
      const selector = document.getElementById('tokenSelector');
      if (!selector) return;

      selector.innerHTML = '';

      if (userPunks.length === 0) {
        const option = document.createElement('option');
        option.value = '';
        option.textContent = 'No tokens available';
        selector.appendChild(option);
        selector.disabled = true;
        return;
      }

      userPunks.forEach(tokenId => {
        const option = document.createElement('option');
        option.value = tokenId;
        option.textContent = `AdrianPunks #${tokenId}`;
        if (tokenId === selectedTokenId) {
          option.selected = true;
        }
        selector.appendChild(option);
      });

      selector.disabled = false;
    }

    // Change selected token
    function changeSelectedToken() {
      const selector = document.getElementById('tokenSelector');
      if (!selector) return;

      const newTokenId = parseInt(selector.value);
      if (newTokenId && userPunks.includes(newTokenId)) {
        selectedTokenId = newTokenId;
        loadFeaturedPunk();
        updateListButton();
      }
    }

    // Update FloorEngine balance
    async function updateFloorEngineBalance() {
      const startTime = performance.now();
      try {
        const balanceEl = document.getElementById('floorEngineBalance');
        if (!balanceEl || !tokenReadContract) return floorEngineBalance || 0;

        console.log('üîÑ Fetching FloorEngine balance...');
        const contractBalance = await tokenReadContract.balanceOf(FLOOR_ENGINE_ADDRESS);
        const ethers5 = window.ethers5Backup || window.ethers;
        floorEngineBalance = parseFloat(ethers5.utils.formatUnits(contractBalance, 18));
        
        let formattedBalance = floorEngineBalance >= 1000000 ? (floorEngineBalance / 1000000).toFixed(1) + 'M' :
                              floorEngineBalance >= 1000 ? (floorEngineBalance / 1000).toFixed(1) + 'K' :
                              floorEngineBalance.toFixed(1);

        balanceEl.innerHTML = `<span>üí∞ FloorEngine: ${formattedBalance} $ADRIAN</span>`;
        console.log(`‚úÖ FloorEngine balance: ${formattedBalance} $ADRIAN (took ${(performance.now() - startTime).toFixed(2)}ms)`);
        
        // Update button when balance changes
        updateListButton();
        return floorEngineBalance;
      } catch (error) {
        console.error('Error fetching FloorEngine balance:', error);
        const balanceEl = document.getElementById('floorEngineBalance');
        if (balanceEl) {
          balanceEl.innerHTML = '<span class="text-danger">Error loading balance</span>';
        }
        return floorEngineBalance || 0;
      }
    }

    // Load active listings from Supabase
    async function loadActiveListings() {
      try {
        if (!supabaseClient) {
          // Try to get listings from contract if Supabase not available
          await loadListingsFromContract();
          return;
        }

        const { data: listings, error } = await supabaseClient
          .from('active_punk_listings')
          .select('token_id, price_adrian_wei, is_engine_owned, seller')
          .order('price_adrian_wei', { ascending: true });

        if (error) throw error;

        if (!listings || listings.length === 0) {
          activeListingsData = [];
          return;
        }

        const ethers5 = window.ethers5Backup || window.ethers;
        activeListingsData = listings.map(l => {
          // Convertir el precio a string, manejando notaci√≥n cient√≠fica
          let priceWeiStr = l.price_adrian_wei;
          
          // Convertir a string si es necesario
          if (typeof priceWeiStr === 'number') {
            priceWeiStr = priceWeiStr.toString();
          } else {
            priceWeiStr = String(priceWeiStr);
          }
          
          // Si contiene notaci√≥n cient√≠fica (e o E), convertirla
          if (priceWeiStr.includes('e') || priceWeiStr.includes('E')) {
            // Convertir notaci√≥n cient√≠fica a string completo
            // Normalizar a min√∫sculas y manejar signo +
            priceWeiStr = priceWeiStr.toLowerCase().replace('e+', 'e');
            const parts = priceWeiStr.split('e');
            
            if (parts.length === 2) {
              const base = parts[0];
              const exponent = parseInt(parts[1]);
              
              // Separar la parte decimal de la base
              const baseParts = base.split('.');
              const integerPart = baseParts[0] || '0';
              const decimalPart = baseParts[1] || '';
              
              // Calcular el n√∫mero total de d√≠gitos despu√©s del punto decimal
              const decimalDigits = decimalPart.length;
              
              // Si el exponente es positivo
              if (exponent > 0) {
                if (exponent <= decimalDigits) {
                  // El punto decimal permanece dentro del n√∫mero
                  const newInteger = integerPart + decimalPart.substring(0, exponent);
                  const newDecimal = decimalPart.substring(exponent);
                  priceWeiStr = newInteger + (newDecimal ? '.' + newDecimal : '');
                } else {
                  // El punto decimal se mueve m√°s all√° del n√∫mero, agregar ceros
                  priceWeiStr = integerPart + decimalPart + '0'.repeat(exponent - decimalDigits);
                }
              } else if (exponent < 0) {
                // Exponente negativo (mover punto decimal a la izquierda)
                priceWeiStr = '0.' + '0'.repeat(-exponent - 1) + integerPart + decimalPart;
              } else {
                // Exponente 0, solo quitar el punto decimal si existe
                priceWeiStr = integerPart + decimalPart;
              }
              
              // Eliminar cualquier punto decimal restante (debe ser entero en wei)
              priceWeiStr = priceWeiStr.split('.')[0];
            }
          }
          
          // Asegurar que no tenga decimales (debe ser un entero en wei)
          priceWeiStr = priceWeiStr.split('.')[0];
          
          return {
            tokenId: l.token_id,
            seller: l.is_engine_owned ? FLOOR_ENGINE_ADDRESS : (l.seller || ''),
            price: ethers5.BigNumber.from(priceWeiStr),
            isContractOwned: l.is_engine_owned
          };
        });

        console.log(`‚úÖ Loaded ${activeListingsData.length} active listings`);
      } catch (error) {
        console.error('Error loading active listings:', error);
        await loadListingsFromContract();
      }
    }

    // Fallback: Load listings from contract (optimized with Multicall3)
    async function loadListingsFromContract() {
      try {
        if (!floorEngineReadContract || !multicallContract) return;

        const listedTokenIds = await floorEngineReadContract.getListedTokenIds();
        if (!listedTokenIds || listedTokenIds.length === 0) {
          activeListingsData = [];
          return;
        }

        const ethers5 = window.ethers5Backup || window.ethers;
        const floorEngineInterface = new ethers5.utils.Interface(FLOOR_ENGINE_ABI);
        
        // Use Multicall3 to get all listings in one batch
        const listingCalls = listedTokenIds.map(tokenId => ({
          target: FLOOR_ENGINE_ADDRESS,
          allowFailure: true,
          callData: floorEngineInterface.encodeFunctionData('listings', [tokenId])
        }));

        console.log(`üîÑ Loading ${listedTokenIds.length} listings with Multicall3...`);
        const multicallStart = performance.now();
        
        let listingResults;
        try {
          listingResults = await multicallContract.callStatic.aggregate3(listingCalls);
          console.log(`‚è±Ô∏è Multicall3 for listings took ${(performance.now() - multicallStart).toFixed(2)}ms`);
        } catch (error) {
          console.warn('Multicall3 failed, falling back to individual calls:', error);
          // Fallback to individual calls
          activeListingsData = [];
          for (const tokenId of listedTokenIds) {
            try {
              const listing = await floorEngineReadContract.listings(tokenId);
              activeListingsData.push({
                tokenId: tokenId.toNumber(),
                seller: listing.seller,
                price: listing.price,
                isContractOwned: listing.isContractOwned
              });
            } catch (err) {
              console.warn(`Error getting listing for token ${tokenId}:`, err);
            }
          }
          console.log(`‚úÖ Loaded ${activeListingsData.length} listings from contract (fallback method)`);
          return;
        }

        // Decode results
        activeListingsData = [];
        for (let i = 0; i < listingResults.length; i++) {
          if (listingResults[i].success) {
            try {
              const decoded = floorEngineInterface.decodeFunctionResult('listings', listingResults[i].returnData);
              activeListingsData.push({
                tokenId: listedTokenIds[i].toNumber(),
                seller: decoded.seller,
                price: decoded.price,
                isContractOwned: decoded.isContractOwned
              });
            } catch (e) {
              console.warn(`Error decoding listing for token ${listedTokenIds[i]}:`, e);
            }
          }
        }

        console.log(`‚úÖ Loaded ${activeListingsData.length} listings from contract (Multicall3)`);
      } catch (error) {
        console.error('Error loading listings from contract:', error);
      }
    }

    // Get current floor price (cheapest user listing, not from engine)
    async function getCurrentFloorPrice() {
      try {
        // First try to use activeListingsData
        if (activeListingsData && activeListingsData.length > 0) {
          let cheapestListing = null;
          for (const listing of activeListingsData) {
            if (!listing.isContractOwned) {
              if (!cheapestListing || listing.price.lt(cheapestListing.price)) {
                cheapestListing = listing;
              }
            }
          }

          if (cheapestListing) {
            const ethers5 = window.ethers5Backup || window.ethers;
            const price = parseFloat(ethers5.utils.formatUnits(cheapestListing.price, 18));
            return { price: cheapestListing.price, priceFormatted: price };
          }
        }

        // Fallback: query contract directly (optimized with Multicall3)
        if (floorEngineReadContract && multicallContract) {
          const listedTokenIds = await floorEngineReadContract.getListedTokenIds();
          if (!listedTokenIds || listedTokenIds.length === 0) {
            return null;
          }

          const ethers5 = window.ethers5Backup || window.ethers;
          const floorEngineInterface = new ethers5.utils.Interface(FLOOR_ENGINE_ABI);
          
          // Use Multicall3 to get all listings in one batch
          const listingCalls = listedTokenIds.map(tokenId => ({
            target: FLOOR_ENGINE_ADDRESS,
            allowFailure: true,
            callData: floorEngineInterface.encodeFunctionData('listings', [tokenId])
          }));

          let listingResults;
          try {
            listingResults = await multicallContract.callStatic.aggregate3(listingCalls);
          } catch (error) {
            console.warn('Multicall3 failed in getCurrentFloorPrice, falling back to individual calls:', error);
            // Fallback to individual calls
            let cheapestPrice = null;
            for (const tokenId of listedTokenIds) {
              try {
                const listing = await floorEngineReadContract.listings(tokenId);
                if (!listing.isContractOwned) {
                  if (!cheapestPrice || listing.price.lt(cheapestPrice)) {
                    cheapestPrice = listing.price;
                  }
                }
              } catch (err) {
                console.warn(`Error getting listing for token ${tokenId}:`, err);
              }
            }
            if (cheapestPrice) {
              const price = parseFloat(ethers5.utils.formatUnits(cheapestPrice, 18));
              return { price: cheapestPrice, priceFormatted: price };
            }
            return null;
          }

          // Decode results and find cheapest user listing
          let cheapestPrice = null;
          for (let i = 0; i < listingResults.length; i++) {
            if (listingResults[i].success) {
              try {
                const decoded = floorEngineInterface.decodeFunctionResult('listings', listingResults[i].returnData);
                if (!decoded.isContractOwned) {
                  if (!cheapestPrice || decoded.price.lt(cheapestPrice)) {
                    cheapestPrice = decoded.price;
                  }
                }
              } catch (e) {
                console.warn(`Error decoding listing for token ${listedTokenIds[i]}:`, e);
              }
            }
          }

          if (cheapestPrice) {
            const price = parseFloat(ethers5.utils.formatUnits(cheapestPrice, 18));
            return { price: cheapestPrice, priceFormatted: price };
          }
        }

        return null;
      } catch (error) {
        console.error('Error getting current floor price:', error);
        return null;
      }
    }

    // Update current floor price display
    async function updateCurrentFloorPrice() {
      try {
        const priceEl = document.getElementById('currentFloorPrice');
        if (!priceEl) return;

        const floorData = await getCurrentFloorPrice();
        currentFloorPrice = floorData;

        if (floorData) {
          const formatted = floorData.priceFormatted >= 1000000 
            ? (floorData.priceFormatted / 1000000).toFixed(1) + 'M'
            : floorData.priceFormatted >= 1000
            ? (floorData.priceFormatted / 1000).toFixed(1) + 'K'
            : floorData.priceFormatted.toFixed(1);

          priceEl.innerHTML = `<span>üí∞ Floor: ${formatted} $ADRIAN</span>`;
        } else {
          priceEl.innerHTML = '<span class="text-muted">No floor price available</span>';
        }

        updateListButton();
      } catch (error) {
        console.error('Error updating current floor price:', error);
        const priceEl = document.getElementById('currentFloorPrice');
        if (priceEl) {
          priceEl.innerHTML = '<span class="text-danger">Error loading price</span>';
        }
      }
    }

    // Update list button (uses FloorEngine balance, not floor price)
    function updateListButton() {
      const btn = document.getElementById('listInstantlyBtn');
      const btnText = document.getElementById('listBtnText');
      const buttonContainer = document.getElementById('buttonContainer');
      
      if (!btn || !btnText || !buttonContainer) return;

      if (!userAccount) {
        btn.disabled = false; // Habilitar para permitir conectar wallet
        btnText.textContent = 'Connect wallet to list';
        return;
      }

      if (!selectedTokenId) {
        btn.disabled = true;
        btnText.textContent = 'Select a punk to list';
        return;
      }

      // Use FloorEngine balance - no need to wait for floor price
      // If FloorEngine has no balance, show 0
      const availableBalance = floorEngineBalance || 0;
      
      if (availableBalance <= 0) {
        btn.disabled = true;
        btnText.textContent = 'FloorEngine has no liquidity (0 $ADRIAN)';
        return;
      }

      // The amount the user will receive is the FloorEngine balance available
      const formatted = availableBalance >= 1000000
        ? (availableBalance / 1000000).toFixed(1) + 'M'
        : availableBalance >= 1000
        ? (availableBalance / 1000).toFixed(1) + 'K'
        : availableBalance.toFixed(1);

      btn.disabled = false;
      btnText.textContent = `Get instantly ${formatted} $ADRIAN for your #${selectedTokenId} Punk`;
      
      // Log for debugging
      console.log(`üí∞ Button updated: FloorEngine=${availableBalance.toFixed(1)} $ADRIAN`);
    }

    // List punk instantly
    async function listPunkInstantly() {
      try {
        if (!userAccount || !selectedTokenId) {
          alert('Please connect your wallet and select a punk');
          return;
        }

        if (!nftContract || !floorEngineContract) {
          alert('Please connect your wallet');
          return;
        }

        if (!currentFloorPrice) {
          alert('Floor price not available. Please try again in a moment.');
          return;
        }

        const statusEl = document.getElementById('listStatus');
        const btn = document.getElementById('listInstantlyBtn');
        const btnText = document.getElementById('listBtnText');

        // Disable button and show loading
        btn.disabled = true;
        btnText.textContent = 'Processing...';
        statusEl.innerHTML = '<div class="spinner-border spinner-border-sm me-2"></div>Starting transaction...';

        // Step 1: Check approval
        try {
          const approvedAddress = await nftContract.getApproved(selectedTokenId);
          const needsApproval = approvedAddress.toLowerCase() !== FLOOR_ENGINE_ADDRESS.toLowerCase();

          if (needsApproval) {
            statusEl.innerHTML = '<div class="spinner-border spinner-border-sm me-2"></div>Approving NFT...';
            btnText.textContent = 'Approving...';

            const txApprove = await nftContract.approve(FLOOR_ENGINE_ADDRESS, selectedTokenId);
            statusEl.innerHTML = `<div class="spinner-border spinner-border-sm me-2"></div>Waiting for approval confirmation... (tx: ${txApprove.hash.substring(0, 10)}...)`;
            
            await txApprove.wait();
            console.log('‚úÖ NFT approved for FloorEngine');
            statusEl.innerHTML = '<div class="text-success">‚úÖ Approval confirmed!</div>';
          }
        } catch (error) {
          console.error('Error during approval:', error);
          statusEl.innerHTML = `<div class="text-danger">‚ùå Approval failed: ${error.message}</div>`;
          btn.disabled = false;
          updateListButton();
          return;
        }

        // Step 2: Get fresh FloorEngine balance and use it as the listing price
        await updateFloorEngineBalance();
        const availableBalance = floorEngineBalance || 0;
        
        if (availableBalance <= 0) {
          statusEl.innerHTML = '<div class="text-danger">‚ùå FloorEngine has no liquidity. Please try again later.</div>';
          btn.disabled = false;
          updateListButton();
          return;
        }

        // Convert available balance to wei for the listing price
        const ethers5 = window.ethers5Backup || window.ethers;
        const listingPriceWei = ethers5.utils.parseUnits(availableBalance.toFixed(18), 18);

        // Step 3: List the punk at the FloorEngine available balance price
        statusEl.innerHTML = '<div class="spinner-border spinner-border-sm me-2"></div>Creating listing...';
        btnText.textContent = 'Listing...';

        const tx = await floorEngineContract.list(selectedTokenId, listingPriceWei, { gasLimit: 300000 });
        statusEl.innerHTML = `<div class="spinner-border spinner-border-sm me-2"></div>Waiting for confirmation... (tx: ${tx.hash.substring(0, 10)}...)`;
        
        await tx.wait();
        console.log('‚úÖ Listing created successfully');

        // Success message using the available balance
        const formatted = availableBalance >= 1000000
          ? (availableBalance / 1000000).toFixed(1) + 'M'
          : availableBalance >= 1000
          ? (availableBalance / 1000).toFixed(1) + 'K'
          : availableBalance.toFixed(1);

        statusEl.innerHTML = `
          <div class="alert alert-success">
            <strong>‚úÖ Success!</strong><br>
            Your punk #${selectedTokenId} has been listed at ${formatted} $ADRIAN!<br>
            <small>You'll receive ${formatted} $ADRIAN in a few minutes when FloorEngine buys it.</small>
          </div>
        `;

        // Reload user punks (the listed one might still be there, but we refresh)
        setTimeout(() => {
          loadUserPunks();
          loadActiveListings();
          updateCurrentFloorPrice();
        }, 2000);

        // Re-enable button after a delay
        setTimeout(() => {
          btn.disabled = false;
          updateListButton();
          statusEl.innerHTML = '';
        }, 5000);

      } catch (error) {
        console.error('Error listing punk:', error);
        const statusEl = document.getElementById('listStatus');
        const btn = document.getElementById('listInstantlyBtn');
        
        let errorMsg = 'Unknown error';
        if (error.message) {
          errorMsg = error.message;
          if (errorMsg.includes('user rejected')) {
            errorMsg = 'Transaction rejected by user';
          } else if (errorMsg.includes('insufficient funds')) {
            errorMsg = 'Insufficient funds for gas';
          }
        }

        if (statusEl) {
          statusEl.innerHTML = `<div class="alert alert-danger"><strong>‚ùå Error:</strong> ${errorMsg}</div>`;
        }

        if (btn) {
          btn.disabled = false;
          updateListButton();
        }
      }
    }

    // Update UI based on state
    function updateUI() {
      updateListButton();
      updateTokenSelector();
    }

    // Event listeners
    document.addEventListener('DOMContentLoaded', async () => {
      const selector = document.getElementById('tokenSelector');
      if (selector) {
        selector.addEventListener('change', changeSelectedToken);
      }

      const listBtn = document.getElementById('listInstantlyBtn');
      if (listBtn) {
        listBtn.addEventListener('click', async function(e) {
          const btnText = document.getElementById('listBtnText');
          // Si el bot√≥n dice "Connect wallet to list", conectar wallet
          if (btnText && btnText.textContent === 'Connect wallet to list') {
            e.preventDefault();
            await connectWallet();
          } else {
            // Si no, ejecutar la funci√≥n normal de listar
            listPunkInstantly();
          }
        });
      }

      // Listen for wallet connection from menu
      window.addEventListener('walletConnected', async (event) => {
        const address = event.detail?.address || window.userAccount;
        if (address) {
          userAccount = address;
          window.userAccount = address;
          const ethers5 = window.ethers5Backup || window.ethers;
          if (ethers5 && window.ethereum) {
            const provider = new ethers5.providers.Web3Provider(window.ethereum);
            const signer = provider.getSigner();
            window.provider = provider;
            window.signer = signer;
            nftContract = new ethers5.Contract(NFT_ADDRESS, NFT_ABI, signer);
            floorEngineContract = new ethers5.Contract(FLOOR_ENGINE_ADDRESS, FLOOR_ENGINE_ABI, signer);
            await loadUserPunks();
          }
        }
      });

      // Listen for wallet account changes
      if (window.ethereum) {
        window.ethereum.on('accountsChanged', async (accounts) => {
          if (accounts.length > 0) {
            userAccount = accounts[0];
            window.userAccount = userAccount;
            const ethers5 = window.ethers5Backup || window.ethers;
            if (ethers5 && window.ethereum) {
              const provider = new ethers5.providers.Web3Provider(window.ethereum);
              const signer = provider.getSigner();
              window.provider = provider;
              window.signer = signer;
              nftContract = new ethers5.Contract(NFT_ADDRESS, NFT_ABI, signer);
              floorEngineContract = new ethers5.Contract(FLOOR_ENGINE_ADDRESS, FLOOR_ENGINE_ABI, signer);
              await loadUserPunks();
            }
          } else {
            userAccount = null;
            window.userAccount = null;
            userPunks = [];
            selectedTokenId = null;
            updateUI();
          }
        });
      }
      
      // Check if wallet is already connected (from menu)
      if (window.userAccount) {
        userAccount = window.userAccount;
        await initWallet();
      }

      // Initialize
      await init();
    });
  </script>
</body>
</html>
